{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home Introducci\u00f3n b\u00e1sica a Python Material El material est\u00e1 disponible en el siguiente repositorio , para obtener el c\u00f3digo de fuente basta con que ejecutes el siguiente comando: https://gitlab.com/FAAM/python_intro Contenidos","title":"Home"},{"location":"#home","text":"Introducci\u00f3n b\u00e1sica a Python","title":"Home"},{"location":"#material","text":"El material est\u00e1 disponible en el siguiente repositorio , para obtener el c\u00f3digo de fuente basta con que ejecutes el siguiente comando: https://gitlab.com/FAAM/python_intro","title":"Material"},{"location":"#contenidos","text":"","title":"Contenidos"},{"location":"basico/","text":"Nomenclatura Sintaxis Hola mundo! Escribamos nuestro primer programa de Python, \"\u00a1Hola, mundo!\". Es un programa simple que imprime Hello World! en el dispositivo de salida est\u00e1ndar (pantalla). Para eso se ocupa el comando print() . # imprimir \"Hola Mundo!\" print ( \"Hola Mundo!\" ); Hola Mundo! Variables Una variable es una ubicaci\u00f3n con nombre utilizada para almacenar datos en la memoria. Una asignaci\u00f3n es una sentencia que asocia un nombre al resultado de una expresi\u00f3n. # asignar e imprimir variables (numericas) a = 5 print ( \"a =\" , 5 ) a = 5 # asignar e imprimir variables (texto) a = \"cinco\" print ( \"a =\" , a ) a = cinco Imprimir mensajes y variables La formula para imprimir mensajes y variables es: print ( \"mensaje_01\" , variable_01 , \"mensaje_02\" , variable_02 , ... ) # Ejemplo x = 5 y = 4 suma = x + y print ( \"La suma de\" , x , \"con\" , y , \"es igual a\" , suma ) La suma de 5 con 4 es igual a 9 Existen varias formas de imprimir variables y strings, sin embargo, la que m\u00e1s se destaca es la forma Literal String Interpolation (o tambi\u00e9n conocido como f-string ). La formula es la siguiente: print ( f \"mensaje_01 { variable_01 } mensaje_02 { variable_02 } ...\" ) # ejemplo f-string print ( f \"La suma de { x } con { y } es igual a igual a { suma } \" ) La suma de 5 con 4 es igual a igual a 9 Observaci\u00f3n : Se tratara de trabajar siempre con la forma f-string para ser consistente. Inputs por el usuario En Python, puede usar la funci\u00f3n input() para tomar la entrada del usuario. Por ejemplo: # inputs por el usuario inputString = input ( 'Escriba una oracion:' ) print ( f 'Su oracion es: { inputString } ' ) Python tipos Enteros, flotantes y n\u00fameros complejos Python admite enteros, n\u00fameros de coma flotante y n\u00fameros complejos. Se definen como int , float y complex en Python. # entero a = 5 print ( type ( a )) <class 'int'> # flotante b = 1.5 print ( type ( b )) <class 'float'> # complejo c = 5 + 3 j print ( type ( c )) <class 'complex'> Valores l\u00f3gicos Los valores l\u00f3gicos True y False (verdadero y falso) son de tipo bool , que representa valores l\u00f3gicos. El nombre bool viene del matem\u00e1tico George Boole , quien cre\u00f3 un sistema algebraico para la l\u00f3gica binaria. Por lo mismo, a True y False tambi\u00e9n se les llama valores booleanos . El nombre no es muy intuitivo, pero es el que se usa en inform\u00e1tica, as\u00ed que hay que conocerlo. a = True print ( type ( a )) <class 'bool'> b = False print ( type ( b )) <class 'bool'> Texto A los valores que representan texto se les llama strings , y tienen el tipo str . Los strings literales pueden ser representados con texto entre comillas simples o comillas dobles: # comillas simples a = 'hola mundo' print ( type ( a )) <class 'str'> # comillas complejas b = \"hola mundo\" print ( type ( b )) <class 'str'> M\u00e9todos Existe algunas m\u00e9todos aplicable a los strings : # lower texto = \"HOLA MUNDO\" print ( texto . lower ()) hola mundo # upper texto = \"hola mundo\" print ( texto . upper ()) HOLA MUNDO # strip texto = \" hola mundo \" print ( texto . strip ()) hola mundo # replace texto = \" hola mundo \" cambiar = \"universo\" print ( texto . replace ( \"mundo\" , \"universo\" )) hola universo Indexaciones Cada uno de los caracteres de un string (incluidos los espacios) tiene asignado un \u00edndice. Este indice nos permite seleccionar su car\u00e1cter asociado haciendo referencia a \u00e9l entre corchetes ( [] ) en el nombre de la variable que almacena la cadena. # seleccion primer elemento texto = \"Python\" print ( texto [ 0 ]) P # seleccion ultimo elemento print ( texto [ - 1 ]) n Otra operaci\u00f3n que podemos realizar a una cadena es seleccionar solamente una parte de ella. Para ello se usa la notaci\u00f3n [inicio:fin:paso] tambi\u00e9n en el nombre de la variable que almacena la cadena, donde: Inicio : es el \u00edndice del primer car\u00e1cter de la porci\u00f3n de la cadena que queremos seleccionar. Fin : es el \u00edndice del \u00faltimo car\u00e1cter no incluido de la porci\u00f3n de la cadena que queremos seleccionar. Paso : indica cada cuantos caracteres seleccionamos entre las posiciones de inicio y fin. texto = \"Programa en Python\" # seleccionar los elementos del primero al noveno en pasos de uno print ( texto [ 0 : 8 : 1 ]) Programa # seleccionar los elementos del primero al noveno print ( texto [: 8 ]) Programa # seleccionar los elementos del treceavo en adelante print ( texto [ 12 :]) Python Observaci\u00f3n : Para imprimir el largo de un texto, puede usar el comando len . texto = \"Programa en Python\" largo = len ( texto ) print ( f \"El texto tiene { largo } letras\" ) El texto tiene 18 letras Nulo Existe un valor llamado None (en ingl\u00e9s, \u00abninguno\u00bb) que es utilizado para representar casos en que ning\u00fan valor es v\u00e1lido, o para indicar que una variable todav\u00eda no tiene un valor que tenga sentido. El valor None tiene su propio tipo, llamado NoneType , que es diferente al de todos los dem\u00e1s valores. a = None print ( type ( a )) <class 'NoneType'> Conversi\u00f3n de tipo El proceso de convertir el valor de un tipo de datos (entero, cadena, flotante, etc.) en otro se llama conversi\u00f3n de tipo. Python tiene dos tipos de conversi\u00f3n de tipos. a) Impl\u00edcita # correcto (numerico + numerico) num_int = 123 # integer type num_flo = 1.23 # float type num_new = num_int + num_flo print ( f \"Valor de num_new: { num_new } \" ) print ( f \"tipo de datos de num_new: { type ( num_new ) } \" ) Valor de num_new: 124.23 tipo de datos de num_new: <class 'float'> # incorrecto (string + numerico) num_int = 123 # int type num_str = \"456\" # str type print ( num_int + num_str ) --------------------------------------------------------------------------- TypeError Traceback (most recent call last) <ipython-input-8-9704f11297d8> in <module> 3 num_str = \"456\" # str type 4 ----> 5 print(num_int+num_str) TypeError: unsupported operand type(s) for +: 'int' and 'str' b) Expl\u00edcito num_int = 123 # int type num_str = \"456\" # str type # cambiar string a numerico num_str = int ( num_str ) print ( num_int + num_str ) 579 Observaci\u00f3n : el proceso de transformar string a numeric es correcto cuando lo que est\u00e1 escrito en el string es un n\u00famero, en caso contrario, nos dar\u00e1 error. Operaciones Operadores aritm\u00e9ticos Los operadores son s\u00edmbolos especiales que realizan operaciones en operandos (variables y valores). Hablemos de operadores aritm\u00e9ticos y de asignaci\u00f3n en esta parte. # operaciones basicas x = 14 y = 4 # suma print ( f 'x + y = { x + y } ' ) # Output: x + y = 18 # resta print ( f 'x - y = { x - y } ' ) # Output: x - y = 10 # multiplicacion print ( f 'x * y = { x * y } ' ) # Output: x * y = 56 # division print ( f 'x / y = { x / y } ' ) # Output: x / y = 3.5 # cuociente o division entera print ( f 'x // y = { x // y } ' ) # Output: x // y = 3 x + y = 18 x - y = 10 x * y = 56 x / y = 3.5 x // y = 3 Otros operadores ar\u00edtmeticos Potencia La funci\u00f3n potencia de un n\u00famero entero corresponde a multiplicar \\(n\\) veces el mismo n\u00famero. Por ejemplo \\[4^3 = 4*4*4 = 64\\] Cuando el exponente es fracionario, hablamos de ra\u00edces. Por ejemplo: \\[4^{1/2} = \\sqrt{4} = 2\\] # operacion potencia x = 4 y = 3 z = 0.5 print ( f 'potencia entera: x ** y = { x ** y } ' ) print ( f 'potencia fraccionaria: x ** z = { x ** z } ' ) potencia entera: x ** y = 64 potencia fraccionaria: x ** z = 2.0 M\u00f3dulo Cuando dividimos dos enteros, tenemos una ecuaci\u00f3n que se ve como lo siguiente: \\( \\(\\dfrac{A}{B} = Q \\text{ residuo } R,\\) \\) donde: * \\(A\\) es el dividendo * \\(B\\) es el divisor * \\(Q\\) es el cociente * \\(R\\) es el residuo A veces, solo estamos interesados en cu\u00e1nto es el residuo cuando dividimos \\(A\\) entre \\(B\\) . Para estos casos hay un operador llamado el operador m\u00f3dulo (abreviado como mod). Al usar los mismos \\(A\\) , \\(B\\) , \\(Q\\) y \\(R\\) que arriba, tendr\u00edamos: \\(A \\text{ mod } B = R\\) (notaci\u00f3n). Por ejemplo: \\[\\dfrac{13}{4} = 3 \\text{ residuo } 1 \\textrm{, es equivalente a: } 13 \\textrm{ mod } 4 = 1 \\] # modulo x = 13 y = 4 print ( f 'x % y = { x % y } ' ) x % y = 1 Redondear La funci\u00f3n incorporada round() toma como argumento un n\u00famero de coma flotante y retorna un n\u00famero entero seg\u00fan las reglas del redondeo. x = 3.94987545322 # cero decimales print ( round ( x )) 4 # un decimal print ( round ( x , 1 )) 3.9 # dos decimales print ( round ( x , 2 )) 3.95 Operadores de asignaci\u00f3n Los operadores de asignaci\u00f3n se utilizan para asignar valores a las variables. Probemos algunos operadores de asignaci\u00f3n m\u00e1s comunes. # operadores de asignacion x = 5 # x += 5 ----> x = x + 5 x += 5 print ( x ) # Output: 10 10 # x /= 5 ----> x = x / 5 x /= 5 print ( x ) # Output: 2.0 10 2.0 Operadores de String Los operadores de string sirven para poder operar variables tipo str . # suma texto_01 = \"hola \" texto_02 = \"mundo\" print ( texto_01 + texto_02 ) hola mundo # multiplicacion texto = \"hola mundo \" print ( 4 * texto ) hola mundo hola mundo hola mundo hola mundo Operadores relacionales Los operadores relacionales sirven para comparar valores. Sus operandos son cualquier cosa que pueda ser comparada, y sus resultados siempre son valores l\u00f3gicos. Operadores relacionales (num\u00e9ricos) # operadores relacionales (numericos) x = 14 y = 4 # igual a print ( f 'x = y { x == y } ' ) # distinto print ( f 'x != y { x != y } ' ) # mayor que print ( f 'x > y { x > y } ' ) # mayor o igualque print ( f 'x >= y { x >= y } ' ) # menor que print ( f 'x < y { x < y } ' ) # menor o igual que print ( f 'x <= y { x <= y } ' ) x = y False x != y True x > y True x >= y True x < y False x <= y False Operadores relacionales ( string ) # operadores relacionales ( string ) texto = \"Python\" otro_texto = \"programa\" # igualdad print ( texto == otro_texto ) False # desigualdad print ( texto != otro_texto ) True # un string esta en un texto print ( \"thon\" in texto ) True # un string NO esta en un texto print ( \"thon\" not in texto ) False Operaciones Binarias Una tabla de verdad , o tabla de valores de verdades, es una tabla que muestra el valor de verdad de una proposici\u00f3n compuesta, para cada combinaci\u00f3n de verdad que se pueda asignar. p q p \u2227 q p v q \u00acp \u00acq T T T T F F T F F T F T F T F T T F F F F F T T En python, los operadores binarios son: * Conjunci\u00f3n ( y ): and * Disyunci\u00f3n ( o ): or * Negaci\u00f3n ( no ): not # ejemplos 'and' valor = True and False print ( valor ) False # ejemplos 'or' valor = True or False print ( valor ) True # ejemplos 'not' valor = not True print ( valor ) False Ejercicios Ejercicio 01 Escriba un programa que pida al usuario que escriba su nombre, y lo salude llam\u00e1ndolo por su nombre. Ingrese su nombre: Perico Hola, Perico Ejercicio 02 Escriba un programa que reciba como entrada el radio de un c\u00edrculo y entregue como salida su per\u00edmetro y su \u00e1rea: Ingrese el radio: 5 Perimetro: 31.4 \u00c1rea: 78.5 Ejercicio 03 Escriba un programa que calcule el promedio de 4 notas ingresadas por el usuario: Primera nota: 55 Segunda nota: 71 Tercera nota: 46 Cuarta nota: 87 El promedio es: 64.75 Ejercicio 04 Escriba un programa que convierta de cent\u00edmetros a pulgadas. Una pulgada es igual a 2.54 cent\u00edmetros. Ingrese longitud: 45 45 cm = 17.7165 in Ejercicio 05 Escriba un programa que reciba como entrada las longitudes de los dos catetos \\(a\\) y \\(b\\) de un tri\u00e1ngulo rect\u00e1ngulo, y que entregue como salida el largo de la hipotenusa \\(c\\) del triangulo, dado por el teorema de Pit\u00e1goras: \\(c^2=a^2+b^2\\) . Ingrese cateto a: 7 Ingrese cateto b: 5 La hipotenusa es 8.6023252670426267 Ejercicio 06 Escriba un programa que pregunte al usuario la hora actual \\(t\\) del reloj y un n\u00famero entero de horas \\(h\\) , que indique qu\u00e9 hora marcar\u00e1 el reloj dentro de \\(h\\) horas: Hora actual: 3 Cantidad de horas: 5 En 5 horas, el reloj marcara las 8 Ejercicio 07 Un alumno desea saber que nota necesita en el tercer certamen para aprobar un ramo. El promedio del ramo se calcula con la siguiente formula. \\[N_C=(C_1+C_2+C_3)/3 \\\\ N_F=N_C\u22c50.7+N_L\u22c50.3\\] Donde \\(N_C\\) es el promedio de cert\u00e1menes, \\(N_L\\) el promedio de laboratorio y \\(N_F\\) la nota final. Escriba un programa que pregunte al usuario las notas de los dos primeros certamen y la nota de laboratorio, y muestre la nota que necesita el alumno para aprobar el ramo con nota final 60. Ingrese nota certamen 1: 45 Ingrese nota certamen 2: 55 Ingrese nota laboratorio: 65 Necesita nota 74 en el certamen 3","title":"Nomenclatura"},{"location":"basico/#nomenclatura","text":"","title":"Nomenclatura"},{"location":"basico/#sintaxis","text":"","title":"Sintaxis"},{"location":"basico/#hola-mundo","text":"Escribamos nuestro primer programa de Python, \"\u00a1Hola, mundo!\". Es un programa simple que imprime Hello World! en el dispositivo de salida est\u00e1ndar (pantalla). Para eso se ocupa el comando print() . # imprimir \"Hola Mundo!\" print ( \"Hola Mundo!\" ); Hola Mundo!","title":"Hola mundo!"},{"location":"basico/#variables","text":"Una variable es una ubicaci\u00f3n con nombre utilizada para almacenar datos en la memoria. Una asignaci\u00f3n es una sentencia que asocia un nombre al resultado de una expresi\u00f3n. # asignar e imprimir variables (numericas) a = 5 print ( \"a =\" , 5 ) a = 5 # asignar e imprimir variables (texto) a = \"cinco\" print ( \"a =\" , a ) a = cinco","title":"Variables"},{"location":"basico/#imprimir-mensajes-y-variables","text":"La formula para imprimir mensajes y variables es: print ( \"mensaje_01\" , variable_01 , \"mensaje_02\" , variable_02 , ... ) # Ejemplo x = 5 y = 4 suma = x + y print ( \"La suma de\" , x , \"con\" , y , \"es igual a\" , suma ) La suma de 5 con 4 es igual a 9 Existen varias formas de imprimir variables y strings, sin embargo, la que m\u00e1s se destaca es la forma Literal String Interpolation (o tambi\u00e9n conocido como f-string ). La formula es la siguiente: print ( f \"mensaje_01 { variable_01 } mensaje_02 { variable_02 } ...\" ) # ejemplo f-string print ( f \"La suma de { x } con { y } es igual a igual a { suma } \" ) La suma de 5 con 4 es igual a igual a 9 Observaci\u00f3n : Se tratara de trabajar siempre con la forma f-string para ser consistente.","title":"Imprimir mensajes y variables"},{"location":"basico/#inputs-por-el-usuario","text":"En Python, puede usar la funci\u00f3n input() para tomar la entrada del usuario. Por ejemplo: # inputs por el usuario inputString = input ( 'Escriba una oracion:' ) print ( f 'Su oracion es: { inputString } ' )","title":"Inputs por el usuario"},{"location":"basico/#python-tipos","text":"","title":"Python tipos"},{"location":"basico/#enteros-flotantes-y-numeros-complejos","text":"Python admite enteros, n\u00fameros de coma flotante y n\u00fameros complejos. Se definen como int , float y complex en Python. # entero a = 5 print ( type ( a )) <class 'int'> # flotante b = 1.5 print ( type ( b )) <class 'float'> # complejo c = 5 + 3 j print ( type ( c )) <class 'complex'>","title":"Enteros, flotantes y n\u00fameros complejos"},{"location":"basico/#valores-logicos","text":"Los valores l\u00f3gicos True y False (verdadero y falso) son de tipo bool , que representa valores l\u00f3gicos. El nombre bool viene del matem\u00e1tico George Boole , quien cre\u00f3 un sistema algebraico para la l\u00f3gica binaria. Por lo mismo, a True y False tambi\u00e9n se les llama valores booleanos . El nombre no es muy intuitivo, pero es el que se usa en inform\u00e1tica, as\u00ed que hay que conocerlo. a = True print ( type ( a )) <class 'bool'> b = False print ( type ( b )) <class 'bool'>","title":"Valores l\u00f3gicos"},{"location":"basico/#texto","text":"A los valores que representan texto se les llama strings , y tienen el tipo str . Los strings literales pueden ser representados con texto entre comillas simples o comillas dobles: # comillas simples a = 'hola mundo' print ( type ( a )) <class 'str'> # comillas complejas b = \"hola mundo\" print ( type ( b )) <class 'str'>","title":"Texto"},{"location":"basico/#metodos","text":"Existe algunas m\u00e9todos aplicable a los strings : # lower texto = \"HOLA MUNDO\" print ( texto . lower ()) hola mundo # upper texto = \"hola mundo\" print ( texto . upper ()) HOLA MUNDO # strip texto = \" hola mundo \" print ( texto . strip ()) hola mundo # replace texto = \" hola mundo \" cambiar = \"universo\" print ( texto . replace ( \"mundo\" , \"universo\" )) hola universo","title":"M\u00e9todos"},{"location":"basico/#indexaciones","text":"Cada uno de los caracteres de un string (incluidos los espacios) tiene asignado un \u00edndice. Este indice nos permite seleccionar su car\u00e1cter asociado haciendo referencia a \u00e9l entre corchetes ( [] ) en el nombre de la variable que almacena la cadena. # seleccion primer elemento texto = \"Python\" print ( texto [ 0 ]) P # seleccion ultimo elemento print ( texto [ - 1 ]) n Otra operaci\u00f3n que podemos realizar a una cadena es seleccionar solamente una parte de ella. Para ello se usa la notaci\u00f3n [inicio:fin:paso] tambi\u00e9n en el nombre de la variable que almacena la cadena, donde: Inicio : es el \u00edndice del primer car\u00e1cter de la porci\u00f3n de la cadena que queremos seleccionar. Fin : es el \u00edndice del \u00faltimo car\u00e1cter no incluido de la porci\u00f3n de la cadena que queremos seleccionar. Paso : indica cada cuantos caracteres seleccionamos entre las posiciones de inicio y fin. texto = \"Programa en Python\" # seleccionar los elementos del primero al noveno en pasos de uno print ( texto [ 0 : 8 : 1 ]) Programa # seleccionar los elementos del primero al noveno print ( texto [: 8 ]) Programa # seleccionar los elementos del treceavo en adelante print ( texto [ 12 :]) Python Observaci\u00f3n : Para imprimir el largo de un texto, puede usar el comando len . texto = \"Programa en Python\" largo = len ( texto ) print ( f \"El texto tiene { largo } letras\" ) El texto tiene 18 letras","title":"Indexaciones"},{"location":"basico/#nulo","text":"Existe un valor llamado None (en ingl\u00e9s, \u00abninguno\u00bb) que es utilizado para representar casos en que ning\u00fan valor es v\u00e1lido, o para indicar que una variable todav\u00eda no tiene un valor que tenga sentido. El valor None tiene su propio tipo, llamado NoneType , que es diferente al de todos los dem\u00e1s valores. a = None print ( type ( a )) <class 'NoneType'>","title":"Nulo"},{"location":"basico/#conversion-de-tipo","text":"El proceso de convertir el valor de un tipo de datos (entero, cadena, flotante, etc.) en otro se llama conversi\u00f3n de tipo. Python tiene dos tipos de conversi\u00f3n de tipos. a) Impl\u00edcita # correcto (numerico + numerico) num_int = 123 # integer type num_flo = 1.23 # float type num_new = num_int + num_flo print ( f \"Valor de num_new: { num_new } \" ) print ( f \"tipo de datos de num_new: { type ( num_new ) } \" ) Valor de num_new: 124.23 tipo de datos de num_new: <class 'float'> # incorrecto (string + numerico) num_int = 123 # int type num_str = \"456\" # str type print ( num_int + num_str ) --------------------------------------------------------------------------- TypeError Traceback (most recent call last) <ipython-input-8-9704f11297d8> in <module> 3 num_str = \"456\" # str type 4 ----> 5 print(num_int+num_str) TypeError: unsupported operand type(s) for +: 'int' and 'str' b) Expl\u00edcito num_int = 123 # int type num_str = \"456\" # str type # cambiar string a numerico num_str = int ( num_str ) print ( num_int + num_str ) 579 Observaci\u00f3n : el proceso de transformar string a numeric es correcto cuando lo que est\u00e1 escrito en el string es un n\u00famero, en caso contrario, nos dar\u00e1 error.","title":"Conversi\u00f3n de tipo"},{"location":"basico/#operaciones","text":"","title":"Operaciones"},{"location":"basico/#operadores-aritmeticos","text":"Los operadores son s\u00edmbolos especiales que realizan operaciones en operandos (variables y valores). Hablemos de operadores aritm\u00e9ticos y de asignaci\u00f3n en esta parte. # operaciones basicas x = 14 y = 4 # suma print ( f 'x + y = { x + y } ' ) # Output: x + y = 18 # resta print ( f 'x - y = { x - y } ' ) # Output: x - y = 10 # multiplicacion print ( f 'x * y = { x * y } ' ) # Output: x * y = 56 # division print ( f 'x / y = { x / y } ' ) # Output: x / y = 3.5 # cuociente o division entera print ( f 'x // y = { x // y } ' ) # Output: x // y = 3 x + y = 18 x - y = 10 x * y = 56 x / y = 3.5 x // y = 3","title":"Operadores aritm\u00e9ticos"},{"location":"basico/#otros-operadores-aritmeticos","text":"","title":"Otros operadores ar\u00edtmeticos"},{"location":"basico/#potencia","text":"La funci\u00f3n potencia de un n\u00famero entero corresponde a multiplicar \\(n\\) veces el mismo n\u00famero. Por ejemplo \\[4^3 = 4*4*4 = 64\\] Cuando el exponente es fracionario, hablamos de ra\u00edces. Por ejemplo: \\[4^{1/2} = \\sqrt{4} = 2\\] # operacion potencia x = 4 y = 3 z = 0.5 print ( f 'potencia entera: x ** y = { x ** y } ' ) print ( f 'potencia fraccionaria: x ** z = { x ** z } ' ) potencia entera: x ** y = 64 potencia fraccionaria: x ** z = 2.0","title":"Potencia"},{"location":"basico/#modulo","text":"Cuando dividimos dos enteros, tenemos una ecuaci\u00f3n que se ve como lo siguiente: \\( \\(\\dfrac{A}{B} = Q \\text{ residuo } R,\\) \\) donde: * \\(A\\) es el dividendo * \\(B\\) es el divisor * \\(Q\\) es el cociente * \\(R\\) es el residuo A veces, solo estamos interesados en cu\u00e1nto es el residuo cuando dividimos \\(A\\) entre \\(B\\) . Para estos casos hay un operador llamado el operador m\u00f3dulo (abreviado como mod). Al usar los mismos \\(A\\) , \\(B\\) , \\(Q\\) y \\(R\\) que arriba, tendr\u00edamos: \\(A \\text{ mod } B = R\\) (notaci\u00f3n). Por ejemplo: \\[\\dfrac{13}{4} = 3 \\text{ residuo } 1 \\textrm{, es equivalente a: } 13 \\textrm{ mod } 4 = 1 \\] # modulo x = 13 y = 4 print ( f 'x % y = { x % y } ' ) x % y = 1","title":"M\u00f3dulo"},{"location":"basico/#redondear","text":"La funci\u00f3n incorporada round() toma como argumento un n\u00famero de coma flotante y retorna un n\u00famero entero seg\u00fan las reglas del redondeo. x = 3.94987545322 # cero decimales print ( round ( x )) 4 # un decimal print ( round ( x , 1 )) 3.9 # dos decimales print ( round ( x , 2 )) 3.95","title":"Redondear"},{"location":"basico/#operadores-de-asignacion","text":"Los operadores de asignaci\u00f3n se utilizan para asignar valores a las variables. Probemos algunos operadores de asignaci\u00f3n m\u00e1s comunes. # operadores de asignacion x = 5 # x += 5 ----> x = x + 5 x += 5 print ( x ) # Output: 10 10 # x /= 5 ----> x = x / 5 x /= 5 print ( x ) # Output: 2.0 10 2.0","title":"Operadores de asignaci\u00f3n"},{"location":"basico/#operadores-de-string","text":"Los operadores de string sirven para poder operar variables tipo str . # suma texto_01 = \"hola \" texto_02 = \"mundo\" print ( texto_01 + texto_02 ) hola mundo # multiplicacion texto = \"hola mundo \" print ( 4 * texto ) hola mundo hola mundo hola mundo hola mundo","title":"Operadores de String"},{"location":"basico/#operadores-relacionales","text":"Los operadores relacionales sirven para comparar valores. Sus operandos son cualquier cosa que pueda ser comparada, y sus resultados siempre son valores l\u00f3gicos.","title":"Operadores relacionales"},{"location":"basico/#operadores-relacionales-numericos","text":"# operadores relacionales (numericos) x = 14 y = 4 # igual a print ( f 'x = y { x == y } ' ) # distinto print ( f 'x != y { x != y } ' ) # mayor que print ( f 'x > y { x > y } ' ) # mayor o igualque print ( f 'x >= y { x >= y } ' ) # menor que print ( f 'x < y { x < y } ' ) # menor o igual que print ( f 'x <= y { x <= y } ' ) x = y False x != y True x > y True x >= y True x < y False x <= y False","title":"Operadores relacionales (num\u00e9ricos)"},{"location":"basico/#operadores-relacionales-string","text":"# operadores relacionales ( string ) texto = \"Python\" otro_texto = \"programa\" # igualdad print ( texto == otro_texto ) False # desigualdad print ( texto != otro_texto ) True # un string esta en un texto print ( \"thon\" in texto ) True # un string NO esta en un texto print ( \"thon\" not in texto ) False","title":"Operadores relacionales ( string )"},{"location":"basico/#operaciones-binarias","text":"Una tabla de verdad , o tabla de valores de verdades, es una tabla que muestra el valor de verdad de una proposici\u00f3n compuesta, para cada combinaci\u00f3n de verdad que se pueda asignar. p q p \u2227 q p v q \u00acp \u00acq T T T T F F T F F T F T F T F T T F F F F F T T En python, los operadores binarios son: * Conjunci\u00f3n ( y ): and * Disyunci\u00f3n ( o ): or * Negaci\u00f3n ( no ): not # ejemplos 'and' valor = True and False print ( valor ) False # ejemplos 'or' valor = True or False print ( valor ) True # ejemplos 'not' valor = not True print ( valor ) False","title":"Operaciones Binarias"},{"location":"basico/#ejercicios","text":"","title":"Ejercicios"},{"location":"basico/#ejercicio-01","text":"Escriba un programa que pida al usuario que escriba su nombre, y lo salude llam\u00e1ndolo por su nombre. Ingrese su nombre: Perico Hola, Perico","title":"Ejercicio 01"},{"location":"basico/#ejercicio-02","text":"Escriba un programa que reciba como entrada el radio de un c\u00edrculo y entregue como salida su per\u00edmetro y su \u00e1rea: Ingrese el radio: 5 Perimetro: 31.4 \u00c1rea: 78.5","title":"Ejercicio 02"},{"location":"basico/#ejercicio-03","text":"Escriba un programa que calcule el promedio de 4 notas ingresadas por el usuario: Primera nota: 55 Segunda nota: 71 Tercera nota: 46 Cuarta nota: 87 El promedio es: 64.75","title":"Ejercicio 03"},{"location":"basico/#ejercicio-04","text":"Escriba un programa que convierta de cent\u00edmetros a pulgadas. Una pulgada es igual a 2.54 cent\u00edmetros. Ingrese longitud: 45 45 cm = 17.7165 in","title":"Ejercicio 04"},{"location":"basico/#ejercicio-05","text":"Escriba un programa que reciba como entrada las longitudes de los dos catetos \\(a\\) y \\(b\\) de un tri\u00e1ngulo rect\u00e1ngulo, y que entregue como salida el largo de la hipotenusa \\(c\\) del triangulo, dado por el teorema de Pit\u00e1goras: \\(c^2=a^2+b^2\\) . Ingrese cateto a: 7 Ingrese cateto b: 5 La hipotenusa es 8.6023252670426267","title":"Ejercicio 05"},{"location":"basico/#ejercicio-06","text":"Escriba un programa que pregunte al usuario la hora actual \\(t\\) del reloj y un n\u00famero entero de horas \\(h\\) , que indique qu\u00e9 hora marcar\u00e1 el reloj dentro de \\(h\\) horas: Hora actual: 3 Cantidad de horas: 5 En 5 horas, el reloj marcara las 8","title":"Ejercicio 06"},{"location":"basico/#ejercicio-07","text":"Un alumno desea saber que nota necesita en el tercer certamen para aprobar un ramo. El promedio del ramo se calcula con la siguiente formula. \\[N_C=(C_1+C_2+C_3)/3 \\\\ N_F=N_C\u22c50.7+N_L\u22c50.3\\] Donde \\(N_C\\) es el promedio de cert\u00e1menes, \\(N_L\\) el promedio de laboratorio y \\(N_F\\) la nota final. Escriba un programa que pregunte al usuario las notas de los dos primeros certamen y la nota de laboratorio, y muestre la nota que necesita el alumno para aprobar el ramo con nota final 60. Ingrese nota certamen 1: 45 Ingrese nota certamen 2: 55 Ingrese nota laboratorio: 65 Necesita nota 74 en el certamen 3","title":"Ejercicio 07"},{"location":"buenas_practicas/","text":"Buenas pr\u00e1cticas Estilo de codificaci\u00f3n Adem\u00e1s de una correcta y ordenada estructura general que deben tener los programa, es conveniente mantener ciertas buenas pr\u00e1cticas de codificaci\u00f3n y el estilo de codificaci\u00f3n recomendado. Estas normas no son obligatorias, como lo es la propia sintaxis del lenguaje, pero conviene seguir las recomendaciones de los desarrolladores de Python para facilitar la lectura del programa y ayudar a encontrar posibles errores. A continuaci\u00f3n, se presentan algunas buenas pr\u00e1cticas relacionadas con es estilo de codificaci\u00f3n: Variables Cuando sea posible, define variables con nombres que tengan alg\u00fan sentido o que puedas identificar f\u00e1cilmente, no importa que sean m\u00e1s largas. Por ejemplo, en un programa podr\u00edamos escribir: a = 10. b = 3.5 print ( \"El volumen es %.1f \" % ( a * b )) El volumen es 35.0 pero, \u00bfqu\u00e9 significan a y b ? lo sabemos por el comentario (bien hecho), pero si m\u00e1s adelante nos encontramos con esas variables, tendremos que recordar cual es cual. Es mejor usar nombres con significado: altura = 10. base = 3.5 print ( \"El volumen es %.1f \" % ( altura * base )) El volumen es 35.0 Lineas de c\u00f3digos Las l\u00edneas de codigo no deben ser muy largas, como mucho 72 caracteres. Si se tiene una l\u00ednea larga, se puede cortar con una barra invertida ( \\ ) y continuar en la siguiente l\u00ednea: print ( \"Esta es una frase muy larga, se puede cortar con una \\ y seguir en la l\u00ednea inferior.\" ) Esta es una frase muy larga, se puede cortar con una y seguir en la l\u00ednea inferior. Comentarios Los comentarios son muy importantes al escribir un programa. Describen lo que est\u00e1 sucediendo dentro de un programa, para que una persona que mira el c\u00f3digo fuente no tenga dificultades para descifrarlo. # esto es un comentario print ( 'Hola' ) Hola Tambi\u00e9n podemos tener comentarios multil\u00edneas: # Este es un comentario largo # y se extiende # a varias l\u00edneas Identaci\u00f3n Dentro de par\u00e9ntesis, corchetes o llaves, no dejar espacios inmediatamente dentro de ellos: # no: lista_01 = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ,] # si lista_01 = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , ] Aunque en Python se pueden hacer varias declaraciones en una l\u00ednea, se recomienda hacer s\u00f3lo una en cada l\u00ednea: # no a = 10 ; b = 20 # si a = 10 b = 20 Cuando se trabaja con lista, conjuntos y/o tuplas se recomienda poner en cada l\u00ednea sus argumentos. # no lista = [( 1 , 'hola' ),( 2 , 'mundo' ),] # si lista = [ ( 1 , 'hola' ), ( 2 , 'mundo' ), ] Lo anterior se puede extender para funciones con muchos argumentos # no def funcion_01 ( x1 , x2 , x3 , x4 ): print ( x1 , x2 , x3 , x4 ) def funcion_02 ( x1 , x2 , x3 , x4 ): print ( x1 , x2 , x3 , x4 ) # si def funcion_01 ( x1 , x2 , x3 , x4 ): print ( x1 , x2 , x3 , x4 ) def funcion_02 ( x1 , x2 , x3 , x4 ): print ( x1 , x2 , x3 , x4 ) Manipulaci\u00f3n de listas Aunque combinar iterables con elementos de control de flujo para manipular listas es muy sencillo con Python, hay m\u00e9todos espec\u00edficos m\u00e1s eficientes para hacer lo mismo. Pensemos el fitrado de datos de una lista: # Seleccionar los n\u00fameros positivos numeros = [ - 3 , 2 , 1 , - 8 , - 2 , 7 ] positivos = [] for i in numeros : if i > 0 : positivos . append ( i ) print ( f \"positivos: { positivos } \" ) positivos: [2, 1, 7] Aunque t\u00e9cnicamente es correcto, es m\u00e1s eficiente hacer List Comprehension : # comprension de lista numeros = [ - 3 , 2 , 1 , - 8 , - 2 , 7 ] positivos = [ i for i in numeros if i > 0 ] # List Comprehension print ( f \"positivos: { positivos } \" ) positivos: [2, 1, 7] Especificar tipo de error Cuando se ocupa try/except , es necesario especificar el tipo de error que se est\u00e1 cometiendo. # importar librerias import sys # no try : r = 1 / 0 except : print ( \"Oops! ocurrio un\" , sys . exc_info ()[ 0 ]) Oops! ocurrio un <class 'ZeroDivisionError'> # si try : r = 1 / 0 except ZeroDivisionError : print ( \"Oops! ocurrio un\" , sys . exc_info ()[ 0 ]) Oops! ocurrio un <class 'ZeroDivisionError'> Explicitar dependencias de una funci\u00f3n Siempre es mejor definir las variables dentro de una funci\u00f3n y no dejar variables globales. # no valor = 5 def funcion_01 ( variable ): return 2 * variable + valor funcion_01 ( 2 ) 9 # si def funcion_01 ( variable , valor ): return 2 * variable + valor funcion_01 ( 2 , 5 ) 9 Escritura din\u00e1mica y est\u00e1tica Con Python 3 se puede especificar el tipo de par\u00e1metro y el tipo de retorno de una funci\u00f3n. Se definen dos conceptos claves: Escritura din\u00e1mica : no se especifican los atributos de los inputs ni de los ouputs Escritura est\u00e1tica : se especifican los atributos de los inputs y los ouputs # escritura din\u00e1mica def suma ( x , y ): return x + y print ( suma ( 1 , 2 )) 3 # escritura estatica def suma ( x : float , y : float ) -> float : return x + y print ( suma ( 1 , 2 )) 3 Para la escritura est\u00e1tica, si bien se especifica el tipo de atributo (tanto de los inputs o outputs), la funci\u00f3n puede recibir otros tipos de atributos. print ( suma ( \"hola\" , \" mundo\" )) hola mundo Para validar los tipos de datos son los correctos, se deben ocupar librer\u00edas especializadas en la validaci\u00f3n de datos (por ejemplo pydantic ). Documentaci\u00f3n de c\u00f3digo Casi tan importante como la escritura de c\u00f3digo, es su correcta documentaci\u00f3n, una parte fundamental de cualquier programa que a menudo se infravalora o simplemente se ignora. Aparte de los comentarios entre el c\u00f3digo explicando c\u00f3mo funciona, el elemento b\u00e1sico de documentaci\u00f3n de Python es el Docstring o cadena de documentaci\u00f3n, que ya hemos visto. Simplemente es una cadena de texto con triple comillas que se coloca justo despu\u00e9s de la definici\u00f3n de funci\u00f3n o clase que sirve de documentaci\u00f3n a ese elemento. def potencia ( x , y ): \"\"\" Calcula la potencia arbitraria de un numero \"\"\" return x ** y # Acceso a la documentaci\u00f3n potencia . __doc__ '\\n Calcula la potencia arbitraria de un numero\\n ' # Acceso a la documentaci\u00f3n help ( potencia ) Help on function potencia in module __main__: potencia(x, y) Calcula la potencia arbitraria de un numero Lo correcto es detallar lo mejor posible en el Docstring qu\u00e9 hace y c\u00f3mo se usa la funci\u00f3n o clase y los par\u00e1metros que necesita. Se recomienda usar el estilo de documentaci\u00f3n del software de documentaci\u00f3n sphinx , que emplea reStructuredText como lenguaje de marcado. Veamos un ejemplo de una funci\u00f3n bien documentada: def potencia ( x , y ): \"\"\" Calcula la potencia arbitraria de un numero :param x: base :param y: exponente :return: potencia de un numero :ejemplos: >>> potencia(2, 1) 2 >>> potencia(3, 2) 9 \"\"\" return x ** y # Acceso a la documentaci\u00f3n potencia . __doc__ '\\n Calcula la potencia arbitraria de un numero\\n\\n :param x: base\\n :param y: exponente\\n :return: potencia de un numero\\n :ejemplos:\\n \\n >>> potencia(2, 1)\\n 2\\n >>> potencia(3, 2)\\n 9\\n ' # Acceso a la documentaci\u00f3n help ( potencia ) Help on function potencia in module __main__: potencia(x, y) Calcula la potencia arbitraria de un numero :param x: base :param y: exponente :return: potencia de un numero :ejemplos: >>> potencia(2, 1) 2 >>> potencia(3, 2) 9 Tipos de Docstring Existen varias formas de documentar tus funciones, las principales encontradas en la literatura son: * Google docstrings :Google\u2019s recommended form of documentation. * reStructured Text :Official Python documentation standard; Not beginner friendly but feature rich. * NumPy/SciPy docstrings :NumPy\u2019s combination of reStructured and Google Docstrings. * Epytext A Python adaptation of Epydoc; Great for Java developer.\" Zen de python El Zen de Python te dar\u00e1 la gu\u00eda para decidir sobre que hacer con tu c\u00f3digo, no te dice como lo debes escribir, sino como debes pensar si estas programando en Python. Principios importantes: Expl\u00edcito es mejor que impl\u00edcito : Que no se asuma nada, aseg\u00farate que las cosas sean. Simple es mejor que complejo : Evita c\u00f3digo complejo, c\u00f3digo espagueti o que hace mas cosas para poder hacer una simple tarea. Plano es mejor que anidado : Si tu c\u00f3digo tiene mas de 3 niveles de identaci\u00f3n, deber\u00edas mover parte de ese c\u00f3digo a una funci\u00f3n. Los errores nunca deber\u00edan pasar silenciosamente : No uses un Try/Except sin definir que tipo de error vas a cachar, viene de la mano con Explicito es mejor que impl\u00edcito. Si la implementaci\u00f3n es dif\u00edcil de explicar, es mala idea . Tambi\u00e9n, podemos ver el mensaje original del zen de python, ejecutando la siguiente linea de comando. import this The Zen of Python, by Tim Peters Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren't special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you're Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it's a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let's do more of those! M\u00e1s consejos Los consejos que se presentan son de mucha utilidad si usted quiere llevar sus conociminetos de programaci\u00f3n al siguiente nivel, sin embargo, el contenido de cada uno amerita un curso por si solo. Se deja recomienda al lector seguir profundizando en estos temas. Entender programaci\u00f3n multiparadigma Python al ser multiparadigma, nos da una amplia gama de posibilidades de dise\u00f1ar nuestros c\u00f3digos. Dentro de estos se destacan: Programaci\u00f3n orientada a objetos (OOP) Programaci\u00f3n funcional Cu\u00e1ndo ocupar uno o la otra, va a depender de c\u00f3mo queremos abordar una determinada problem\u00e1tica, puesto que en la mayor\u00eda de los casos, se puede pasar de un paradigma a o otro (incluso mezclarlos de ser necesario). Principio S.O.L.I.D En ingenier\u00eda de software, SOLID (Single responsibility, Open-closed, Liskov substitution, Interface segregation and Dependency inversion) es un acr\u00f3nimo mnem\u00f3nico introducido por Robert C. Martin a comienzos de la d\u00e9cada del 2000 que representa cinco principios b\u00e1sicos de la programaci\u00f3n orientada a objetos y el dise\u00f1o. Cuando estos principios se aplican en conjunto es m\u00e1s probable que un desarrollador cree un sistema que sea f\u00e1cil de mantener y ampliar con el tiempo. En el siguiente link se deja una gu\u00eda para poder entender estos conceptos en python. Patrones de dise\u00f1o Los patrones de dise\u00f1o son la base para la b\u00fasqueda de soluciones a problemas comunes en el desarrollo de software y otros \u00e1mbitos referentes al dise\u00f1o de interacci\u00f3n o interfaces. Un patr\u00f3n de dise\u00f1o es una soluci\u00f3n a un problema de dise\u00f1o. Se destacan tres tipos de patrones de dise\u00f1os: Comportamiento Creacionales Estructurales En el siguiente link se deja una gu\u00eda para poder entender estos conceptos en python. Lecturas recomendadas Clean Code: A Handbook of Agile Software - Robert C. Martin (2009): Habla sobre las buenas pr\u00e1cticas que debe seguir todo buen programador al momento de escribir su c\u00f3digo. Si bien el lenguaje de programaci\u00f3n emepleado es Java , la l\u00f3gica se extiende a cualquier lenguaje de programaci\u00f3n. The Clean Coder: A Code Of Conduct For Professional Programmers Robert C. Martin (2011): Habla sobre las conductas que debe seguir todo programador. Adem\u00e1s de hablar aspectos t\u00e9cnicos como estimaci\u00f3n, dise\u00f1o de c\u00f3digo, refactorizaci\u00f3n y testeos, tambi\u00e9n nos habla sobre la actitud que un programador debe tener en distintas situaciones laborales. Referencia clean-code-python Documenting Python Code: A Complete Guide","title":"Buenas pr\u00e1cticas"},{"location":"buenas_practicas/#buenas-practicas","text":"","title":"Buenas pr\u00e1cticas"},{"location":"buenas_practicas/#estilo-de-codificacion","text":"Adem\u00e1s de una correcta y ordenada estructura general que deben tener los programa, es conveniente mantener ciertas buenas pr\u00e1cticas de codificaci\u00f3n y el estilo de codificaci\u00f3n recomendado. Estas normas no son obligatorias, como lo es la propia sintaxis del lenguaje, pero conviene seguir las recomendaciones de los desarrolladores de Python para facilitar la lectura del programa y ayudar a encontrar posibles errores. A continuaci\u00f3n, se presentan algunas buenas pr\u00e1cticas relacionadas con es estilo de codificaci\u00f3n:","title":"Estilo de codificaci\u00f3n"},{"location":"buenas_practicas/#variables","text":"Cuando sea posible, define variables con nombres que tengan alg\u00fan sentido o que puedas identificar f\u00e1cilmente, no importa que sean m\u00e1s largas. Por ejemplo, en un programa podr\u00edamos escribir: a = 10. b = 3.5 print ( \"El volumen es %.1f \" % ( a * b )) El volumen es 35.0 pero, \u00bfqu\u00e9 significan a y b ? lo sabemos por el comentario (bien hecho), pero si m\u00e1s adelante nos encontramos con esas variables, tendremos que recordar cual es cual. Es mejor usar nombres con significado: altura = 10. base = 3.5 print ( \"El volumen es %.1f \" % ( altura * base )) El volumen es 35.0","title":"Variables"},{"location":"buenas_practicas/#lineas-de-codigos","text":"Las l\u00edneas de codigo no deben ser muy largas, como mucho 72 caracteres. Si se tiene una l\u00ednea larga, se puede cortar con una barra invertida ( \\ ) y continuar en la siguiente l\u00ednea: print ( \"Esta es una frase muy larga, se puede cortar con una \\ y seguir en la l\u00ednea inferior.\" ) Esta es una frase muy larga, se puede cortar con una y seguir en la l\u00ednea inferior.","title":"Lineas de c\u00f3digos"},{"location":"buenas_practicas/#comentarios","text":"Los comentarios son muy importantes al escribir un programa. Describen lo que est\u00e1 sucediendo dentro de un programa, para que una persona que mira el c\u00f3digo fuente no tenga dificultades para descifrarlo. # esto es un comentario print ( 'Hola' ) Hola Tambi\u00e9n podemos tener comentarios multil\u00edneas: # Este es un comentario largo # y se extiende # a varias l\u00edneas","title":"Comentarios"},{"location":"buenas_practicas/#identacion","text":"Dentro de par\u00e9ntesis, corchetes o llaves, no dejar espacios inmediatamente dentro de ellos: # no: lista_01 = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ,] # si lista_01 = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , ] Aunque en Python se pueden hacer varias declaraciones en una l\u00ednea, se recomienda hacer s\u00f3lo una en cada l\u00ednea: # no a = 10 ; b = 20 # si a = 10 b = 20 Cuando se trabaja con lista, conjuntos y/o tuplas se recomienda poner en cada l\u00ednea sus argumentos. # no lista = [( 1 , 'hola' ),( 2 , 'mundo' ),] # si lista = [ ( 1 , 'hola' ), ( 2 , 'mundo' ), ] Lo anterior se puede extender para funciones con muchos argumentos # no def funcion_01 ( x1 , x2 , x3 , x4 ): print ( x1 , x2 , x3 , x4 ) def funcion_02 ( x1 , x2 , x3 , x4 ): print ( x1 , x2 , x3 , x4 ) # si def funcion_01 ( x1 , x2 , x3 , x4 ): print ( x1 , x2 , x3 , x4 ) def funcion_02 ( x1 , x2 , x3 , x4 ): print ( x1 , x2 , x3 , x4 )","title":"Identaci\u00f3n"},{"location":"buenas_practicas/#manipulacion-de-listas","text":"Aunque combinar iterables con elementos de control de flujo para manipular listas es muy sencillo con Python, hay m\u00e9todos espec\u00edficos m\u00e1s eficientes para hacer lo mismo. Pensemos el fitrado de datos de una lista: # Seleccionar los n\u00fameros positivos numeros = [ - 3 , 2 , 1 , - 8 , - 2 , 7 ] positivos = [] for i in numeros : if i > 0 : positivos . append ( i ) print ( f \"positivos: { positivos } \" ) positivos: [2, 1, 7] Aunque t\u00e9cnicamente es correcto, es m\u00e1s eficiente hacer List Comprehension : # comprension de lista numeros = [ - 3 , 2 , 1 , - 8 , - 2 , 7 ] positivos = [ i for i in numeros if i > 0 ] # List Comprehension print ( f \"positivos: { positivos } \" ) positivos: [2, 1, 7]","title":"Manipulaci\u00f3n de listas"},{"location":"buenas_practicas/#especificar-tipo-de-error","text":"Cuando se ocupa try/except , es necesario especificar el tipo de error que se est\u00e1 cometiendo. # importar librerias import sys # no try : r = 1 / 0 except : print ( \"Oops! ocurrio un\" , sys . exc_info ()[ 0 ]) Oops! ocurrio un <class 'ZeroDivisionError'> # si try : r = 1 / 0 except ZeroDivisionError : print ( \"Oops! ocurrio un\" , sys . exc_info ()[ 0 ]) Oops! ocurrio un <class 'ZeroDivisionError'>","title":"Especificar tipo de error"},{"location":"buenas_practicas/#explicitar-dependencias-de-una-funcion","text":"Siempre es mejor definir las variables dentro de una funci\u00f3n y no dejar variables globales. # no valor = 5 def funcion_01 ( variable ): return 2 * variable + valor funcion_01 ( 2 ) 9 # si def funcion_01 ( variable , valor ): return 2 * variable + valor funcion_01 ( 2 , 5 ) 9","title":"Explicitar dependencias de una funci\u00f3n"},{"location":"buenas_practicas/#escritura-dinamica-y-estatica","text":"Con Python 3 se puede especificar el tipo de par\u00e1metro y el tipo de retorno de una funci\u00f3n. Se definen dos conceptos claves: Escritura din\u00e1mica : no se especifican los atributos de los inputs ni de los ouputs Escritura est\u00e1tica : se especifican los atributos de los inputs y los ouputs # escritura din\u00e1mica def suma ( x , y ): return x + y print ( suma ( 1 , 2 )) 3 # escritura estatica def suma ( x : float , y : float ) -> float : return x + y print ( suma ( 1 , 2 )) 3 Para la escritura est\u00e1tica, si bien se especifica el tipo de atributo (tanto de los inputs o outputs), la funci\u00f3n puede recibir otros tipos de atributos. print ( suma ( \"hola\" , \" mundo\" )) hola mundo Para validar los tipos de datos son los correctos, se deben ocupar librer\u00edas especializadas en la validaci\u00f3n de datos (por ejemplo pydantic ).","title":"Escritura din\u00e1mica y est\u00e1tica"},{"location":"buenas_practicas/#documentacion-de-codigo","text":"Casi tan importante como la escritura de c\u00f3digo, es su correcta documentaci\u00f3n, una parte fundamental de cualquier programa que a menudo se infravalora o simplemente se ignora. Aparte de los comentarios entre el c\u00f3digo explicando c\u00f3mo funciona, el elemento b\u00e1sico de documentaci\u00f3n de Python es el Docstring o cadena de documentaci\u00f3n, que ya hemos visto. Simplemente es una cadena de texto con triple comillas que se coloca justo despu\u00e9s de la definici\u00f3n de funci\u00f3n o clase que sirve de documentaci\u00f3n a ese elemento. def potencia ( x , y ): \"\"\" Calcula la potencia arbitraria de un numero \"\"\" return x ** y # Acceso a la documentaci\u00f3n potencia . __doc__ '\\n Calcula la potencia arbitraria de un numero\\n ' # Acceso a la documentaci\u00f3n help ( potencia ) Help on function potencia in module __main__: potencia(x, y) Calcula la potencia arbitraria de un numero Lo correcto es detallar lo mejor posible en el Docstring qu\u00e9 hace y c\u00f3mo se usa la funci\u00f3n o clase y los par\u00e1metros que necesita. Se recomienda usar el estilo de documentaci\u00f3n del software de documentaci\u00f3n sphinx , que emplea reStructuredText como lenguaje de marcado. Veamos un ejemplo de una funci\u00f3n bien documentada: def potencia ( x , y ): \"\"\" Calcula la potencia arbitraria de un numero :param x: base :param y: exponente :return: potencia de un numero :ejemplos: >>> potencia(2, 1) 2 >>> potencia(3, 2) 9 \"\"\" return x ** y # Acceso a la documentaci\u00f3n potencia . __doc__ '\\n Calcula la potencia arbitraria de un numero\\n\\n :param x: base\\n :param y: exponente\\n :return: potencia de un numero\\n :ejemplos:\\n \\n >>> potencia(2, 1)\\n 2\\n >>> potencia(3, 2)\\n 9\\n ' # Acceso a la documentaci\u00f3n help ( potencia ) Help on function potencia in module __main__: potencia(x, y) Calcula la potencia arbitraria de un numero :param x: base :param y: exponente :return: potencia de un numero :ejemplos: >>> potencia(2, 1) 2 >>> potencia(3, 2) 9","title":"Documentaci\u00f3n de c\u00f3digo"},{"location":"buenas_practicas/#tipos-de-docstring","text":"Existen varias formas de documentar tus funciones, las principales encontradas en la literatura son: * Google docstrings :Google\u2019s recommended form of documentation. * reStructured Text :Official Python documentation standard; Not beginner friendly but feature rich. * NumPy/SciPy docstrings :NumPy\u2019s combination of reStructured and Google Docstrings. * Epytext A Python adaptation of Epydoc; Great for Java developer.\"","title":"Tipos de Docstring"},{"location":"buenas_practicas/#zen-de-python","text":"El Zen de Python te dar\u00e1 la gu\u00eda para decidir sobre que hacer con tu c\u00f3digo, no te dice como lo debes escribir, sino como debes pensar si estas programando en Python. Principios importantes: Expl\u00edcito es mejor que impl\u00edcito : Que no se asuma nada, aseg\u00farate que las cosas sean. Simple es mejor que complejo : Evita c\u00f3digo complejo, c\u00f3digo espagueti o que hace mas cosas para poder hacer una simple tarea. Plano es mejor que anidado : Si tu c\u00f3digo tiene mas de 3 niveles de identaci\u00f3n, deber\u00edas mover parte de ese c\u00f3digo a una funci\u00f3n. Los errores nunca deber\u00edan pasar silenciosamente : No uses un Try/Except sin definir que tipo de error vas a cachar, viene de la mano con Explicito es mejor que impl\u00edcito. Si la implementaci\u00f3n es dif\u00edcil de explicar, es mala idea . Tambi\u00e9n, podemos ver el mensaje original del zen de python, ejecutando la siguiente linea de comando. import this The Zen of Python, by Tim Peters Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren't special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you're Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it's a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let's do more of those!","title":"Zen de python"},{"location":"buenas_practicas/#mas-consejos","text":"Los consejos que se presentan son de mucha utilidad si usted quiere llevar sus conociminetos de programaci\u00f3n al siguiente nivel, sin embargo, el contenido de cada uno amerita un curso por si solo. Se deja recomienda al lector seguir profundizando en estos temas.","title":"M\u00e1s consejos"},{"location":"buenas_practicas/#entender-programacion-multiparadigma","text":"Python al ser multiparadigma, nos da una amplia gama de posibilidades de dise\u00f1ar nuestros c\u00f3digos. Dentro de estos se destacan: Programaci\u00f3n orientada a objetos (OOP) Programaci\u00f3n funcional Cu\u00e1ndo ocupar uno o la otra, va a depender de c\u00f3mo queremos abordar una determinada problem\u00e1tica, puesto que en la mayor\u00eda de los casos, se puede pasar de un paradigma a o otro (incluso mezclarlos de ser necesario).","title":"Entender programaci\u00f3n multiparadigma"},{"location":"buenas_practicas/#principio-solid","text":"En ingenier\u00eda de software, SOLID (Single responsibility, Open-closed, Liskov substitution, Interface segregation and Dependency inversion) es un acr\u00f3nimo mnem\u00f3nico introducido por Robert C. Martin a comienzos de la d\u00e9cada del 2000 que representa cinco principios b\u00e1sicos de la programaci\u00f3n orientada a objetos y el dise\u00f1o. Cuando estos principios se aplican en conjunto es m\u00e1s probable que un desarrollador cree un sistema que sea f\u00e1cil de mantener y ampliar con el tiempo. En el siguiente link se deja una gu\u00eda para poder entender estos conceptos en python.","title":"Principio S.O.L.I.D"},{"location":"buenas_practicas/#patrones-de-diseno","text":"Los patrones de dise\u00f1o son la base para la b\u00fasqueda de soluciones a problemas comunes en el desarrollo de software y otros \u00e1mbitos referentes al dise\u00f1o de interacci\u00f3n o interfaces. Un patr\u00f3n de dise\u00f1o es una soluci\u00f3n a un problema de dise\u00f1o. Se destacan tres tipos de patrones de dise\u00f1os: Comportamiento Creacionales Estructurales En el siguiente link se deja una gu\u00eda para poder entender estos conceptos en python.","title":"Patrones de dise\u00f1o"},{"location":"buenas_practicas/#lecturas-recomendadas","text":"Clean Code: A Handbook of Agile Software - Robert C. Martin (2009): Habla sobre las buenas pr\u00e1cticas que debe seguir todo buen programador al momento de escribir su c\u00f3digo. Si bien el lenguaje de programaci\u00f3n emepleado es Java , la l\u00f3gica se extiende a cualquier lenguaje de programaci\u00f3n. The Clean Coder: A Code Of Conduct For Professional Programmers Robert C. Martin (2011): Habla sobre las conductas que debe seguir todo programador. Adem\u00e1s de hablar aspectos t\u00e9cnicos como estimaci\u00f3n, dise\u00f1o de c\u00f3digo, refactorizaci\u00f3n y testeos, tambi\u00e9n nos habla sobre la actitud que un programador debe tener en distintas situaciones laborales.","title":"Lecturas recomendadas"},{"location":"buenas_practicas/#referencia","text":"clean-code-python Documenting Python Code: A Complete Guide","title":"Referencia"},{"location":"error/","text":"Excepciones Introducci\u00f3n Existen muchos tipos de errores que pueden estar presentes en un programa. No todos los errores pueden ser detectados por el computador. Veamos el siguiente ejemplo: # error semantico n = 4 doble = 3 * n print ( f 'El doble de n es { doble } ' ) El doble de n es 12 El computador no se dar\u00e1 cuenta del error, pues todas las instrucciones del programa son correctas. El programa simplemente entregar\u00e1 siempre la respuesta equivocada. Existen otros errores que s\u00ed pueden ser detectados. Cuando un error es detectado durante la ejecuci\u00f3n del programa ocurre una excepci\u00f3n . Si no se manejan las excepciones, se escupe un mensaje de error y nuestro programa se detiene repentinamente e inesperadamente. En python, existen varios tipos de excepciones (ver el siguiente link ), sin embargo, en esta secci\u00f3n se presentan algunas de ellas. Error de sintaxis Un error de sintaxis ocurre cuando el programa no cumple las reglas del lenguaje. Cuando ocurre este error, significa que el programa est\u00e1 mal escrito. El nombre del error es SyntaxError . # SyntaxError 2 * ( 3 + 4 )) Error de nombre Un error de nombre ocurre al usar una variable que no ha sido creada con anterioridad. El nombre de la excepci\u00f3n es NameError . # NameError x = 20 x + y Error de tipo En general, todas las operaciones en un programa pueden ser aplicadas sobre valores de tipos bien espec\u00edficos. Un error de tipo ocurre al aplicar una operaci\u00f3n sobre operandos de tipo incorrecto. El nombre de la excepci\u00f3n es TypeError . # type error 'seis' * 'ocho' Error de valor El error de valor ocurre cuando los operandos son del tipo correcto, pero la operaci\u00f3n no tiene sentido para ese valor. El nombre de la excepci\u00f3n es ValueError . # ValueError int ( 'perro' ) Error de divisi\u00f3n por cero El error de division por cero ocurre al intentar dividir por cero. El nombre de la excepci\u00f3n es ZeroDivisionError : # ZeroDivisionError 1 / 0 Error de desborde El error de desborde ocurre cuando el resultado de una operaci\u00f3n es tan grande que el computador no puede representarlo internamente. El nombre de la excepci\u00f3n es OverflowError . # OverflowError 20.0 ** 20.0 ** 20.0 Uso de raise Tambi\u00e9n podemos ser nosotros los que levantemos o lancemos una excepci\u00f3n. Volviendo a los ejemplos usados en el apartado anterior, podemos ser nosotros los que levantemos ZeroDivisionError o NameError usando raise . La sintaxis es muy f\u00e1cil. # ejemplo sencillo raise ZeroDivisionError --------------------------------------------------------------------------- ZeroDivisionError Traceback (most recent call last) <ipython-input-2-f1e7e3a602af> in <module> 1 # ejemplo sencillo ----> 2 raise ZeroDivisionError ZeroDivisionError: # ejemplo con mensaje raise ZeroDivisionError ( \"Informaci\u00f3n de la excepci\u00f3n\" ) --------------------------------------------------------------------------- ZeroDivisionError Traceback (most recent call last) <ipython-input-3-847ce2b0c57e> in <module> 1 # ejemplo con mensaje ----> 2 raise ZeroDivisionError(\"Informaci\u00f3n de la excepci\u00f3n\") ZeroDivisionError: Informaci\u00f3n de la excepci\u00f3n Visto esto, ya sabemos como una excepci\u00f3n puede ser lanzada. Existen dos maneras principalmente: Hacemos una operaci\u00f3n que no puede ser realizada (como dividir por cero). En este caso Python se encarga de lanzar autom\u00e1ticamente la excepci\u00f3n. O tambi\u00e9n podemos lanzar nosotros una excepci\u00f3n manualmente, usando raise . Menajando excepciones Uso de try y excepet En Python, las excepciones se pueden manejar usando la declaraci\u00f3n try . Cuando se detectan excepciones, depende de usted qu\u00e9 operador realizar. a = 5 b = 0 try : c = a / b except : print ( \"No se ha podido realizar la divisi\u00f3n\" ) No se ha podido realizar la divisi\u00f3n En este caso no verificamos que b!=0 . Directamente intentamos realizar la divisi\u00f3n y en el caso de que se lance la excepci\u00f3n ZeroDivisionError , la capturamos y la tratamos adecuadamente. Uso de else Al ya explicado try y except le podemos a\u00f1adir un bloque m\u00e1s, el else . Dicho bloque se ejecutar\u00e1 si no ha ocurrido ninguna excepci\u00f3n. F\u00edjate en la diferencia entre los siguientes c\u00f3digos. try : # Forzamos una excepci\u00f3n al dividir entre 0 x = 2 / 0 except : print ( \"Entra en except, ha ocurrido una excepci\u00f3n\" ) else : print ( \"Entra en else, no ha ocurrido ninguna excepci\u00f3n\" ) Entra en except, ha ocurrido una excepci\u00f3n Sin embargo en el siguiente c\u00f3digo la divisi\u00f3n se puede realizar sin problema, por lo que el bloque except no se ejecuta pero el else si es ejecutado. try : # La divisi\u00f3n puede realizarse sin problema x = 2 / 2 except : print ( \"Entra en except, ha ocurrido una excepci\u00f3n\" ) else : print ( \"Entra en else, no ha ocurrido ninguna excepci\u00f3n\" ) Entra en else, no ha ocurrido ninguna excepci\u00f3n Uso de finally A los ya vistos bloques try , except y else podemos a\u00f1adir un bloque m\u00e1s, el finally . Dicho bloque se ejecuta siempre, haya o no haya habido excepci\u00f3n. Este bloque se suele usar si queremos ejecutar alg\u00fan tipo de acci\u00f3n de limpieza . Si por ejemplo estamos escribiendo datos en un fichero pero ocurre una excepci\u00f3n, tal vez queramos borrar el contenido que hemos escrito con anterioridad, para no dejar datos inconsistenes en el fichero. En el siguiente c\u00f3digo vemos un ejemplo. Haya o no haya excepci\u00f3n el c\u00f3digo que haya dentro de finally ser\u00e1 ejecutado. try : # Forzamos excepci\u00f3n x = 2 / 0 except : # Se entra ya que ha habido una excepci\u00f3n print ( \"Entra en except, ha ocurrido una excepci\u00f3n\" ) finally : # Tambi\u00e9n entra porque finally es ejecutado siempre print ( \"Entra en finally, se ejecuta el bloque finally\" ) Entra en except, ha ocurrido una excepci\u00f3n Entra en finally, se ejecuta el bloque finally Aserciones en python Las aserciones son expresiones booleanas que comprueban si las condiciones devuelven verdaderas o no. Si es cierto, el programa no hace nada y pasa a la siguiente l\u00ednea de c\u00f3digo. Sin embargo, si es falso, el programa se detiene y arroja un error. Las aserciones son importantes al momento de realizar tests unitarios o asegurar que un resultado siempre sea el mismo. assert en testing La funci\u00f3n assert() puede ser tambi\u00e9n muy \u00fatil para escribir tests unitarios o units tests. Veamos un ejemplo. # definir funcion def suma ( x , y ): return x + y # ejemplo correcto assert suma ( 1 , 1 ) == 2 , \"ejemplo invalido\" # ejemplo incorrecto assert suma ( 1 , 1 ) == 3 , \"ejemplo invalido\" --------------------------------------------------------------------------- AssertionError Traceback (most recent call last) <ipython-input-13-e3b3e004fc0f> in <module> 1 # ejemplo incorrecto ----> 2 assert suma(1,1)==3, \"ejemplo invalido\" AssertionError: ejemplo invalido assert en funciones Puede resultar \u00fatil usar assert( ) cuando queremos realizar alguna comprobaci\u00f3n, como podr\u00eda ser dentro de una funci\u00f3n. En el siguiente ejemplo tenemos una funci\u00f3n suma() que s\u00f3lo suma las variables si son n\u00fameros enteros. # Funcion suma de variables enteras def suma ( a , b ): assert ( type ( a ) == int ) assert ( type ( b ) == int ) return a + b # Ok, los argumentos son int suma ( 3 , 5 ) 8 # Error, ya que las variables no son int suma ( 3.0 , 5.0 ) --------------------------------------------------------------------------- AssertionError Traceback (most recent call last) <ipython-input-18-15e6a3a9ef4e> in <module> 1 # Error, ya que las variables no son int ----> 2 suma(3.0, 5.0) <ipython-input-14-96c9f786f568> in suma(a, b) 1 # Funcion suma de variables enteras 2 def suma(a, b): ----> 3 assert(type(a) == int) 4 assert(type(b) == int) 5 return a+b AssertionError: assert en clases Otro ejemplo podr\u00eda verificar que un objeto pertenece a una clase determinada. class MiClase (): pass class MiOtraClase (): pass mi_objeto = MiClase () mi_otro_objeto = MiOtraClase () # Ok assert ( isinstance ( mi_objeto , MiClase )) # Ok assert ( isinstance ( mi_otro_objeto , MiOtraClase )) # Error, mi_objeto no pertenece a MiOtraClase assert ( isinstance ( mi_objeto , MiOtraClase )) --------------------------------------------------------------------------- AssertionError Traceback (most recent call last) <ipython-input-23-a5b5276f8d9c> in <module> 1 # Error, mi_objeto no pertenece a MiOtraClase ----> 2 assert(isinstance(mi_objeto, MiOtraClase)) AssertionError: # Error, mi_otro_objeto no pertenece a MiClase assert ( isinstance ( mi_otro_objeto , MiClase )) --------------------------------------------------------------------------- AssertionError Traceback (most recent call last) <ipython-input-24-819cb8cdefde> in <module> 1 # Error, mi_otro_objeto no pertenece a MiClase ----> 2 assert(isinstance(mi_otro_objeto, MiClase)) AssertionError:","title":"Excepciones"},{"location":"error/#excepciones","text":"","title":"Excepciones"},{"location":"error/#introduccion","text":"Existen muchos tipos de errores que pueden estar presentes en un programa. No todos los errores pueden ser detectados por el computador. Veamos el siguiente ejemplo: # error semantico n = 4 doble = 3 * n print ( f 'El doble de n es { doble } ' ) El doble de n es 12 El computador no se dar\u00e1 cuenta del error, pues todas las instrucciones del programa son correctas. El programa simplemente entregar\u00e1 siempre la respuesta equivocada. Existen otros errores que s\u00ed pueden ser detectados. Cuando un error es detectado durante la ejecuci\u00f3n del programa ocurre una excepci\u00f3n . Si no se manejan las excepciones, se escupe un mensaje de error y nuestro programa se detiene repentinamente e inesperadamente. En python, existen varios tipos de excepciones (ver el siguiente link ), sin embargo, en esta secci\u00f3n se presentan algunas de ellas.","title":"Introducci\u00f3n"},{"location":"error/#error-de-sintaxis","text":"Un error de sintaxis ocurre cuando el programa no cumple las reglas del lenguaje. Cuando ocurre este error, significa que el programa est\u00e1 mal escrito. El nombre del error es SyntaxError . # SyntaxError 2 * ( 3 + 4 ))","title":"Error de sintaxis"},{"location":"error/#error-de-nombre","text":"Un error de nombre ocurre al usar una variable que no ha sido creada con anterioridad. El nombre de la excepci\u00f3n es NameError . # NameError x = 20 x + y","title":"Error de nombre"},{"location":"error/#error-de-tipo","text":"En general, todas las operaciones en un programa pueden ser aplicadas sobre valores de tipos bien espec\u00edficos. Un error de tipo ocurre al aplicar una operaci\u00f3n sobre operandos de tipo incorrecto. El nombre de la excepci\u00f3n es TypeError . # type error 'seis' * 'ocho'","title":"Error de tipo"},{"location":"error/#error-de-valor","text":"El error de valor ocurre cuando los operandos son del tipo correcto, pero la operaci\u00f3n no tiene sentido para ese valor. El nombre de la excepci\u00f3n es ValueError . # ValueError int ( 'perro' )","title":"Error de valor"},{"location":"error/#error-de-division-por-cero","text":"El error de division por cero ocurre al intentar dividir por cero. El nombre de la excepci\u00f3n es ZeroDivisionError : # ZeroDivisionError 1 / 0","title":"Error de divisi\u00f3n por cero"},{"location":"error/#error-de-desborde","text":"El error de desborde ocurre cuando el resultado de una operaci\u00f3n es tan grande que el computador no puede representarlo internamente. El nombre de la excepci\u00f3n es OverflowError . # OverflowError 20.0 ** 20.0 ** 20.0","title":"Error de desborde"},{"location":"error/#uso-de-raise","text":"Tambi\u00e9n podemos ser nosotros los que levantemos o lancemos una excepci\u00f3n. Volviendo a los ejemplos usados en el apartado anterior, podemos ser nosotros los que levantemos ZeroDivisionError o NameError usando raise . La sintaxis es muy f\u00e1cil. # ejemplo sencillo raise ZeroDivisionError --------------------------------------------------------------------------- ZeroDivisionError Traceback (most recent call last) <ipython-input-2-f1e7e3a602af> in <module> 1 # ejemplo sencillo ----> 2 raise ZeroDivisionError ZeroDivisionError: # ejemplo con mensaje raise ZeroDivisionError ( \"Informaci\u00f3n de la excepci\u00f3n\" ) --------------------------------------------------------------------------- ZeroDivisionError Traceback (most recent call last) <ipython-input-3-847ce2b0c57e> in <module> 1 # ejemplo con mensaje ----> 2 raise ZeroDivisionError(\"Informaci\u00f3n de la excepci\u00f3n\") ZeroDivisionError: Informaci\u00f3n de la excepci\u00f3n Visto esto, ya sabemos como una excepci\u00f3n puede ser lanzada. Existen dos maneras principalmente: Hacemos una operaci\u00f3n que no puede ser realizada (como dividir por cero). En este caso Python se encarga de lanzar autom\u00e1ticamente la excepci\u00f3n. O tambi\u00e9n podemos lanzar nosotros una excepci\u00f3n manualmente, usando raise .","title":"Uso de raise"},{"location":"error/#menajando-excepciones","text":"","title":"Menajando excepciones"},{"location":"error/#uso-de-try-y-excepet","text":"En Python, las excepciones se pueden manejar usando la declaraci\u00f3n try . Cuando se detectan excepciones, depende de usted qu\u00e9 operador realizar. a = 5 b = 0 try : c = a / b except : print ( \"No se ha podido realizar la divisi\u00f3n\" ) No se ha podido realizar la divisi\u00f3n En este caso no verificamos que b!=0 . Directamente intentamos realizar la divisi\u00f3n y en el caso de que se lance la excepci\u00f3n ZeroDivisionError , la capturamos y la tratamos adecuadamente.","title":"Uso de try y excepet"},{"location":"error/#uso-de-else","text":"Al ya explicado try y except le podemos a\u00f1adir un bloque m\u00e1s, el else . Dicho bloque se ejecutar\u00e1 si no ha ocurrido ninguna excepci\u00f3n. F\u00edjate en la diferencia entre los siguientes c\u00f3digos. try : # Forzamos una excepci\u00f3n al dividir entre 0 x = 2 / 0 except : print ( \"Entra en except, ha ocurrido una excepci\u00f3n\" ) else : print ( \"Entra en else, no ha ocurrido ninguna excepci\u00f3n\" ) Entra en except, ha ocurrido una excepci\u00f3n Sin embargo en el siguiente c\u00f3digo la divisi\u00f3n se puede realizar sin problema, por lo que el bloque except no se ejecuta pero el else si es ejecutado. try : # La divisi\u00f3n puede realizarse sin problema x = 2 / 2 except : print ( \"Entra en except, ha ocurrido una excepci\u00f3n\" ) else : print ( \"Entra en else, no ha ocurrido ninguna excepci\u00f3n\" ) Entra en else, no ha ocurrido ninguna excepci\u00f3n","title":"Uso de else"},{"location":"error/#uso-de-finally","text":"A los ya vistos bloques try , except y else podemos a\u00f1adir un bloque m\u00e1s, el finally . Dicho bloque se ejecuta siempre, haya o no haya habido excepci\u00f3n. Este bloque se suele usar si queremos ejecutar alg\u00fan tipo de acci\u00f3n de limpieza . Si por ejemplo estamos escribiendo datos en un fichero pero ocurre una excepci\u00f3n, tal vez queramos borrar el contenido que hemos escrito con anterioridad, para no dejar datos inconsistenes en el fichero. En el siguiente c\u00f3digo vemos un ejemplo. Haya o no haya excepci\u00f3n el c\u00f3digo que haya dentro de finally ser\u00e1 ejecutado. try : # Forzamos excepci\u00f3n x = 2 / 0 except : # Se entra ya que ha habido una excepci\u00f3n print ( \"Entra en except, ha ocurrido una excepci\u00f3n\" ) finally : # Tambi\u00e9n entra porque finally es ejecutado siempre print ( \"Entra en finally, se ejecuta el bloque finally\" ) Entra en except, ha ocurrido una excepci\u00f3n Entra en finally, se ejecuta el bloque finally","title":"Uso de finally"},{"location":"error/#aserciones-en-python","text":"Las aserciones son expresiones booleanas que comprueban si las condiciones devuelven verdaderas o no. Si es cierto, el programa no hace nada y pasa a la siguiente l\u00ednea de c\u00f3digo. Sin embargo, si es falso, el programa se detiene y arroja un error. Las aserciones son importantes al momento de realizar tests unitarios o asegurar que un resultado siempre sea el mismo.","title":"Aserciones en python"},{"location":"error/#assert-en-testing","text":"La funci\u00f3n assert() puede ser tambi\u00e9n muy \u00fatil para escribir tests unitarios o units tests. Veamos un ejemplo. # definir funcion def suma ( x , y ): return x + y # ejemplo correcto assert suma ( 1 , 1 ) == 2 , \"ejemplo invalido\" # ejemplo incorrecto assert suma ( 1 , 1 ) == 3 , \"ejemplo invalido\" --------------------------------------------------------------------------- AssertionError Traceback (most recent call last) <ipython-input-13-e3b3e004fc0f> in <module> 1 # ejemplo incorrecto ----> 2 assert suma(1,1)==3, \"ejemplo invalido\" AssertionError: ejemplo invalido","title":"assert en testing"},{"location":"error/#assert-en-funciones","text":"Puede resultar \u00fatil usar assert( ) cuando queremos realizar alguna comprobaci\u00f3n, como podr\u00eda ser dentro de una funci\u00f3n. En el siguiente ejemplo tenemos una funci\u00f3n suma() que s\u00f3lo suma las variables si son n\u00fameros enteros. # Funcion suma de variables enteras def suma ( a , b ): assert ( type ( a ) == int ) assert ( type ( b ) == int ) return a + b # Ok, los argumentos son int suma ( 3 , 5 ) 8 # Error, ya que las variables no son int suma ( 3.0 , 5.0 ) --------------------------------------------------------------------------- AssertionError Traceback (most recent call last) <ipython-input-18-15e6a3a9ef4e> in <module> 1 # Error, ya que las variables no son int ----> 2 suma(3.0, 5.0) <ipython-input-14-96c9f786f568> in suma(a, b) 1 # Funcion suma de variables enteras 2 def suma(a, b): ----> 3 assert(type(a) == int) 4 assert(type(b) == int) 5 return a+b AssertionError:","title":"assert en funciones"},{"location":"error/#assert-en-clases","text":"Otro ejemplo podr\u00eda verificar que un objeto pertenece a una clase determinada. class MiClase (): pass class MiOtraClase (): pass mi_objeto = MiClase () mi_otro_objeto = MiOtraClase () # Ok assert ( isinstance ( mi_objeto , MiClase )) # Ok assert ( isinstance ( mi_otro_objeto , MiOtraClase )) # Error, mi_objeto no pertenece a MiOtraClase assert ( isinstance ( mi_objeto , MiOtraClase )) --------------------------------------------------------------------------- AssertionError Traceback (most recent call last) <ipython-input-23-a5b5276f8d9c> in <module> 1 # Error, mi_objeto no pertenece a MiOtraClase ----> 2 assert(isinstance(mi_objeto, MiOtraClase)) AssertionError: # Error, mi_otro_objeto no pertenece a MiClase assert ( isinstance ( mi_otro_objeto , MiClase )) --------------------------------------------------------------------------- AssertionError Traceback (most recent call last) <ipython-input-24-819cb8cdefde> in <module> 1 # Error, mi_otro_objeto no pertenece a MiClase ----> 2 assert(isinstance(mi_otro_objeto, MiClase)) AssertionError:","title":"assert en clases"},{"location":"estructura/","text":"Estructura de datos Son una utilidad de Python dispuesta para almacenar y guardar cualquier tipo de Dato, tanto as\u00ed que pueden contenerse entre s\u00ed. Cada una posee un tipo de par\u00e9ntesis, o comillas en el caso de los strings, siendo f\u00e1cil diferenciarlos unos de otro. Strings \u2018 \u2019 : Representan texto , siendo una cadena ordenada de caracteres y un tipo de dato, como los n\u00fameros y booleanos, pero con una complejidad mayor al ser tambi\u00e9n una estructura. Pueden estar entre comillas \u2018simples\u2019 o \u201cdobles\u201d. Listas [ ] : Son una cadena ordenada de datos, los cuales, al igual que en los strings y tuplas, tienen la relaci\u00f3n dato-posici\u00f3n. Tuplas ( ) : Son una cadena ordenada de datos, pero a diferencia de las listas, y al igual que los strings, es inmutable, es decir, no se puede modificar. Diccionarios { : } : Son un conjunto de pares de datos que se caracteriza por utilizar una relaci\u00f3n llave-dato. Debido a esto no necesitan orden, ya que al tener una llave se puede sacar su dato relacionado. Las estructuras de datos de string ya fueron estudiados en secciones pasada. En esta secci\u00f3n nos centraremos en las estructuras de Listas , Tuplas y Diccionarios . Listas Una lista es una colecci\u00f3n ordenada de valores. Una lista puede contener cualquier cosa. En Python, el tipo de datos que representa a las listas se llama list . Creando listas en python Existen varias formas de crear listas: # lista vacia lista = [] print ( lista ) # lista de enteros lista = [ 1 , 2 , 3 ] print ( lista ) [1, 2, 3] # lista mixta lista = [ 1 , \"hola\" , 3.4 ] print ( lista ) [1, 'hola', 3.4] Operaciones sobre listas Operador len len(lista) entrega el largo de la lista; es decir, cu\u00e1ntos elementos tiene: colores = [ 'azul' , 'rojo' , 'verde' , 'amarillo' ] print ( len ( colores )) 4 Acceder al \u00edndice l[i] entrega el i-\u00e9simo valor de la lista. El valor \\(i\\) se llama \u00edndice del valor. Al igual que para los strings, los \u00edndices parten de cero: colores = [ 'azul' , 'rojo' , 'verde' , 'amarillo' ] print ( f 'primer elemento de la lista: { colores [ 0 ] } ' ) print ( f 'tercer elemento de la lista: { colores [ 2 ] } ' ) primer elemento de la lista: azul tercer elemento de la lista: verde # elemento fuera de la lista print ( colores [ 4 ]) --------------------------------------------------------------------------- IndexError Traceback (most recent call last) <ipython-input-12-f7eb673eabf2> in <module> 1 # elemento fuera de la lista ----> 2 print( colores[4]) IndexError: list index out of range \u00cdndice negativo Si el \u00edndice es negativo, los elementos se cuentan desde el final hacia atr\u00e1s: colores = [ 'azul' , 'rojo' , 'verde' , 'amarillo' ] print ( colores [ - 1 ]) amarillo Agregar un elemento l.append(x) agrega el elemento x al final de la lista: primos = [ 2 , 3 , 5 , 7 , 11 ] primos . append ( 13 ) print ( primos ) [2, 3, 5, 7, 11, 13] Concatenar dos listas l1 + l2 concatena las listas l1 y l2 : l1 = [ 1 , 2 , 3 ] l2 = [ 4 , 5 , 6 ] print ( l1 + l2 ) [1, 2, 3, 4, 5, 6] Repetir lista l * n repite \\(n\\) veces la lista l : lista = [ 1 , 2 , 3 ] print ( 2 * lista ) [1, 2, 3, 1, 2, 3] Elemento en una lista Para saber si un elemento x est\u00e1 en la lista l , se usa x in l . La versi\u00f3n negativa de in es not in : lista = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] print ( 12 in lista ) False print ( 12 not in lista ) True Operador rebanado l[i:j] es el operador de rebanado, que entrega una nueva lista que tiene desde el i-\u00e9simo hasta justo antes del j-\u00e9simo elemento de la lista l: l = [ 1.5 , 3.3 , 8.4 , 3.1 , 2.9 ] print ( l [ 2 : 4 ]) [8.4, 3.1] Operador \u00edndice l.index(x) entrega cu\u00e1l es el \u00edndice del valor x: colores = [ 'azul' , 'rojo' , 'verde' , 'amarillo' ] print ( colores . index ( 'verde' )) 2 Operador remover l.remove(x) elimina el elemento x de la lista: l = [ 7 , 0 , 3 , 9 , 8 , 2 , 4 ] l . remove ( 2 ) print ( l ) [7, 0, 3, 9, 8, 4] Operador borrar del l[i] elimina el i-\u00e9simo elemento de la lista: l = [ 7 , 0 , 3 , 9 , 8 , 2 , 4 ] del l [ 2 ] print ( l ) [7, 0, 9, 8, 2, 4] Operador reversa l.reverse() invierte la lista: l = [ 7 , 0 , 3 , 9 , 8 , 2 , 4 ] l . reverse () print ( l ) [4, 2, 8, 9, 3, 0, 7] Operador ordenar l.sort() ordena la lista: l = [ 7 , 0 , 3 , 9 , 8 , 2 , 4 ] l . sort () print ( l ) [0, 2, 3, 4, 7, 8, 9] Iterar sobre una lista Una lista es un objeto iterable . Esto significa que sus valores se pueden recorrer usando un ciclo for : valores = [ 1 , 2 , 3 , 4 , 5 ] for i in valores : print ( i ** 2 ) 1 4 9 16 25 Tuplas Una tupla es una secuencia de valores agrupados. Una tupla sirve para agrupar, como si fueran un \u00fanico valor, varios valores que, por su naturaleza, deben ir juntos. El tipo de datos que representa a las tuplas se llama tuple . El tipo tuple es **inmutable: una tupla no puede ser modificada una vez que ha sido creada. numeros = ( \"uno\" , \"dos\" , \"tres\" , \"cuatro\" ) print ( numeros ) Desempaquetado de tuplas Los valores individuales de una tupla pueden ser recuperados asignando la tupla a las variables respectivas. Esto se llama desempaquetar la tupla (en ingl\u00e9s: unpack): persona = ( 'Javier' , 'Perez' ) nombre , apellido = persona print ( nombre , apellido ) Javier Perez Si se intenta desempaquetar una cantidad incorrecta de valores, ocurre un error de valor: a , b , c = persona --------------------------------------------------------------------------- ValueError Traceback (most recent call last) <ipython-input-4-998bf8320296> in <module> ----> 1 a, b, c = persona ValueError: not enough values to unpack (expected 3, got 2) Comparaci\u00f3n de tuplas Dos tuplas son iguales cuando tienen el mismo tama\u00f1o y cada uno de sus elementos correspondientes tienen el mismo valor: ( 1 , 2 ) == ( 2 / 2 , 1 + 1 ) True ( 6 , 1 ) == ( 6 , 2 ) False Para determinar si una tupla es menor que otra, se utiliza lo que se denomina orden lexicogr\u00e1fico . Si los elementos en la primera posici\u00f3n de ambas tuplas son distintos, ellos determinan el ordenamiento de las tuplas: ( 1 , 4 , 7 ) < ( 2 , 0 , 0 , 1 ) True ( 1 , 9 , 10 ) < ( 0 , 5 ) False Acceder a valores de una tupla Al igual que las listas, se pueden acceder a distintos elemntos de las tuplas de la siguiente forma: numeros = ( \"uno\" , \"dos\" , \"tres\" , \"cuatro\" ) print ( numeros [ 1 ]) #Output: dos print ( numeros [ 3 ]) #Output: cuatro print ( numeros [ - 1 ]) # Output: cuatro Iteraci\u00f3n sobre tuplas Al igual que las listas, las tuplas son iterables: for valor in ( 1 , 2 , 3 , 4 , 5 ): print ( valor ** 2 ) 1 4 9 16 25 Adem\u00e1s, se puede convertir una tupla en una lista usando la funci\u00f3n list , y una lista en una tupla usando la funci\u00f3n tuple : a = ( 1 , 2 , 3 ) b = [ 4 , 5 , 6 ] #lista list ( a ) [1, 2, 3] # tupla tuple ( b ) (4, 5, 6) Conjuntos Un conjunto es una colecci\u00f3n desordenada de valores no repetidos. Los conjuntos de Python son an\u00e1logos a los conjuntos matem\u00e1ticos. El tipo de datos que representa a los conjuntos se llama set . C\u00f3mo crear conjuntos Las dos maneras principales de crear un conjunto son: # usar un conjunto literal, entre llave conjunto = { 1 , 2 , 3 } print ( conjunto ) {1, 2, 3} # set aplicada sobre un iterable conjunto = set ([ 1 , 2 , 3 ]) print ( conjunto ) {1, 2, 3} Los elementos de un conjunto deben ser inmutables. Por ejemplo, no es posible crear un conjunto de listas, pero s\u00ed un conjunto de tuplas: conjunto = {[ 2 , 4 ], [ 6 , 1 ]} --------------------------------------------------------------------------- TypeError Traceback (most recent call last) <ipython-input-34-c1f516a9affc> in <module> ----> 1 s = {[2, 4], [6, 1]} TypeError: unhashable type: 'list' Como un conjunto no es ordenado, no tiene sentido intentar obtener un elemento usando un \u00edndice: conjunto = { 'a' , 'b' , 'c' } conjunto [ 0 ] --------------------------------------------------------------------------- TypeError Traceback (most recent call last) <ipython-input-35-501605a4a770> in <module> 1 conjunto = {'a', 'b', 'c'} ----> 2 conjunto[0] TypeError: 'set' object is not subscriptable Sin embargo, s\u00ed es posible iterar sobre un conjunto usando un ciclo for: conjunto = { 'a' , 'b' , 'c' } for i in conjunto : print ( i ) a c b Operaciones sobre conjuntos Largo del conjunto len(s) entrega el n\u00famero de elementos del conjunto s: len ({ 'azul' , 'verde' , 'rojo' }) 3 Elementos en el conjunto x in s permite saber si el elemento x est\u00e1 en el conjunto s: 3 in { 2 , 3 , 4 } True x not in s permite saber si x no est\u00e1 en s: 3 not in { 2 , 3 , 4 } False Agregar elementos al conjunto s.add(x) agrega el elemento x al conjunto s: s = { 6 , 1 , 5 , 4 , 3 } s . add ( - 37 ) s {-37, 1, 3, 4, 5, 6} Remover elementos al conjunto s.remove(x) elimina el elemento x del conjunto s: s = { 6 , 1 , 5 , 4 , 3 } s . remove ( 1 ) s {3, 4, 5, 6} Si el elemento x no est\u00e1 en el conjunto, ocurre un error de llave: s . remove ( 10 ) --------------------------------------------------------------------------- KeyError Traceback (most recent call last) <ipython-input-42-23b5f1bb77c8> in <module> ----> 1 s.remove(10) KeyError: 10 Operaciones sobre conjuntos & y | son los operadores de intersecci\u00f3n y uni\u00f3n repectivamente: # crear dos conjuntos a = { 1 , 2 , 3 , 4 } b = { 2 , 4 , 6 , 8 } # interseccion a & b {2, 4} # union a | b {1, 2, 3, 4, 6, 8} s - t entrega la diferencia entre s y t; es decir, los elementos de s que no est\u00e1n en t: # diferencia a - b {1, 3} s ^ t entrega la diferencia sim\u00e9trica entre s y t; es decir, los elementos que est\u00e1n en s o en t, pero no en ambos: # diferencia simetrica a ^ b {1, 3, 6, 8} El operador < aplicado sobre conjuntos significa \u00abes subconjunto de\u00bb: { 1 , 2 } < { 1 , 2 , 3 } True { 1 , 4 } < { 1 , 2 , 3 } False s <= t tambi\u00e9n indica si s es subconjunto de t. La distinci\u00f3n ocurre cuando los conjuntos son iguales: { 1 , 2 , 3 } < { 1 , 2 , 3 } False { 1 , 2 , 3 } <= { 1 , 2 , 3 } True Diccionarios Un diccionario es un tipo de datos que sirve para asociar pares de objetos. Un diccionario puede ser visto como una colecci\u00f3n de llaves, cada una de las cuales tiene asociada un valor. Las llaves no est\u00e1n ordenadas y no hay llaves repetidas. La \u00fanica manera de acceder a un valor es a trav\u00e9s de su llave. C\u00f3mo crear diccionarios Los diccionarios literales se crean usando llaves ({ y }). La llave y el valor van separados por dos puntos: # diccionario vacio dct = {} dct = dict () # diccionario de enteros dct = { 1 : 'apple' , 2 : 'ball' } # diccionario dde llaves mixtas dct = { 'name' : 'John' , 1 : [ 2 , 4 , 3 ]} C\u00f3mo usar un diccionario El valor asociado a la llave \\(k\\) en el diccionario \\(dct\\) se puede obtener mediante \\(dct[k]\\) : dct = { 'nombre' : 'Jack' , 'edad' : 26 , 'salario' : 4534.2 } print ( dct [ 'edad' ]) # Output: 26 26 Si se asigna un valor a una llave que ya estaba en el diccionario, el valor anterior se sobreescribe. Recuerde que un diccionario no puede tener llaves repetidas: dct = { 'nombre' : 'Jack' , 'edad' : 26 } # cambiar edad dct [ 'edad' ] = 36 print ( dct ) # Output: {'name': 'Jack', 'age': 36} Tambi\u00e9n se pueden adherir llaves al diccionario # adherir llave salario dct [ 'salario' ] = 4342.4 print ( dct ) # Output: {'name': 'Jack', 'age': 36, 'salary': 4342.4} Por otro lado, si se quiere borrar una llave o el mismo diccionario, se ocupa el comando del # borrar llave edad del dct [ 'edad' ] print ( dct ) # Output: {'name': 'Jack', 'salary': 4342.4} # borrar diccionario del dct Iterar un diccionario Los diccionarios son iterables. Al iterar sobre un diccionario en un ciclo for , se obtiene las llaves: dct = { 1 : 'apple' , 2 : 'ball' } for k in dct : print ( k ) 1 2 Para iterar sobre las llaves, se usa values() : for v in dct . values (): print ( v ) apple ball Para iterar sobre las llaves y los valores simult\u00e1neamente, se usa el m\u00e9todo items() : for k , v in dct . items (): print ( f \"llave: { k } , valor: { v } \" ) llave: 1, valor: apple llave: 2, valor: ball Restricciones sobre las llaves No se puede usar cualquier objeto como llave de un diccionario. Las llaves deben ser de un tipo de datos inmutable. Por ejemplo, no se puede usar listas: dct = {[ 1 , 2 , 3 ]: 'hola' } --------------------------------------------------------------------------- TypeError Traceback (most recent call last) <ipython-input-30-873bc4fce75e> in <module> ----> 1 dct = {[1, 2, 3]: 'hola'} TypeError: unhashable type: 'list' T\u00edpicamente, se usa n\u00fameros, tuplas y strings como llaves de los diccionarios. Otras estructuras de datos Python range() range() devuelve una secuencia inmutable de n\u00fameros entre el entero de inicio dado al entero de parada. print ( range ( 1 , 10 )) # Output: range(1, 10) range(1, 10) Hemos omitido el par\u00e1metro de step opcional para range() en los ejemplos anteriores. Cuando se omite, el paso predeterminado es 1. Probemos algunos ejemplos con el par\u00e1metro de paso. numero1 = range ( 1 , 6 , 1 ) print ( list ( numero1 )) # Output: [1, 2, 3, 4, 5] [1, 2, 3, 4, 5] numero2 = range ( 1 , 6 , 2 ) print ( list ( numero2 )) # Output: [1, 3, 5] [1, 3, 5] numero3 = range ( 5 , 0 , - 1 ) print ( list ( numero3 )) # Output: [5, 4, 3, 2, 1] [5, 4, 3, 2, 1] El resultado es iterable y puede convertirlo en list , tuple , set , etc. Por ejemplo: numeros = range ( 1 , 6 ) print ( list ( numeros )) # Output: [1, 2, 3, 4, 5] print ( tuple ( numeros )) # Output: (1, 2, 3, 4, 5) print ( set ( numeros )) # Output: {1, 2, 3, 4, 5} # Output: {1: 99, 2: 99, 3: 99, 4: 99, 5: 99} print ( dict . fromkeys ( numeros , 99 )) Ejercicios Ejercicio 01 Escriba un programa que muestre la tabla de multiplicar del 1 al 10 del n\u00famero ingresado por el usuario: Ingrese un numero: 9 9 x 1 = 9 9 x 2 = 18 9 x 3 = 27 9 x 4 = 36 9 x 5 = 45 9 x 6 = 54 9 x 7 = 63 9 x 8 = 72 9 x 9 = 81 9 x 10 = 90 Ejercicio 02 Escriba un programa que genere todas las potencias de 2, desde la 0-\u00e9sima hasta la ingresada por el usuario: Ingrese num: 10 1 2 4 8 16 32 64 128 256 512 1024 Ejercicio 03 Escribir un programa que almacene las asignaturas de un curso (por ejemplo Matem\u00e1ticas, F\u00edsica, Qu\u00edmica, Historia y Lengua) en una lista y la muestre por pantalla el mensaje Yo estudio <asignatura> , donde <asignatura> es cada una de las asignaturas de la lista. Ejercicio 04 Un n\u00famero natural es un pal\u00edndromo si se lee igual de izquierda a derecha y de derecha a izquierda. Por ejemplo, \\(14941\\) es un pal\u00edndromo, mientras que \\(81924\\) no lo es. Escriba un programa que indique si el n\u00famero ingresado es o no pal\u00edndromo: Ingrese un numero: 14941 14941 es palindromo Ingrese un numero: 81924 81924 no es palindromo Ejercicio 05 Escribir una funci\u00f3n que reciba una lista de tuplas, y que devuelva un diccionario en donde las claves sean los primeros elementos de las tuplas, y los valores una lista con los segundos. Por ejemplo, dado una lista: l = [ ( 'Nola' , 'don Pepito' ), ( 'Nola' , 'don Jose' ), ( 'Buenos' , 'd\u00edas' ) ] Deber\u00e1 mostrar: { 'Nola': ['don Pepito', 'don Jose'], 'Buenos': ['d\u00edas'] }","title":"Estructura de datos"},{"location":"estructura/#estructura-de-datos","text":"Son una utilidad de Python dispuesta para almacenar y guardar cualquier tipo de Dato, tanto as\u00ed que pueden contenerse entre s\u00ed. Cada una posee un tipo de par\u00e9ntesis, o comillas en el caso de los strings, siendo f\u00e1cil diferenciarlos unos de otro. Strings \u2018 \u2019 : Representan texto , siendo una cadena ordenada de caracteres y un tipo de dato, como los n\u00fameros y booleanos, pero con una complejidad mayor al ser tambi\u00e9n una estructura. Pueden estar entre comillas \u2018simples\u2019 o \u201cdobles\u201d. Listas [ ] : Son una cadena ordenada de datos, los cuales, al igual que en los strings y tuplas, tienen la relaci\u00f3n dato-posici\u00f3n. Tuplas ( ) : Son una cadena ordenada de datos, pero a diferencia de las listas, y al igual que los strings, es inmutable, es decir, no se puede modificar. Diccionarios { : } : Son un conjunto de pares de datos que se caracteriza por utilizar una relaci\u00f3n llave-dato. Debido a esto no necesitan orden, ya que al tener una llave se puede sacar su dato relacionado. Las estructuras de datos de string ya fueron estudiados en secciones pasada. En esta secci\u00f3n nos centraremos en las estructuras de Listas , Tuplas y Diccionarios .","title":"Estructura de datos"},{"location":"estructura/#listas","text":"Una lista es una colecci\u00f3n ordenada de valores. Una lista puede contener cualquier cosa. En Python, el tipo de datos que representa a las listas se llama list .","title":"Listas"},{"location":"estructura/#creando-listas-en-python","text":"Existen varias formas de crear listas: # lista vacia lista = [] print ( lista ) # lista de enteros lista = [ 1 , 2 , 3 ] print ( lista ) [1, 2, 3] # lista mixta lista = [ 1 , \"hola\" , 3.4 ] print ( lista ) [1, 'hola', 3.4]","title":"Creando listas en python"},{"location":"estructura/#operaciones-sobre-listas","text":"Operador len len(lista) entrega el largo de la lista; es decir, cu\u00e1ntos elementos tiene: colores = [ 'azul' , 'rojo' , 'verde' , 'amarillo' ] print ( len ( colores )) 4 Acceder al \u00edndice l[i] entrega el i-\u00e9simo valor de la lista. El valor \\(i\\) se llama \u00edndice del valor. Al igual que para los strings, los \u00edndices parten de cero: colores = [ 'azul' , 'rojo' , 'verde' , 'amarillo' ] print ( f 'primer elemento de la lista: { colores [ 0 ] } ' ) print ( f 'tercer elemento de la lista: { colores [ 2 ] } ' ) primer elemento de la lista: azul tercer elemento de la lista: verde # elemento fuera de la lista print ( colores [ 4 ]) --------------------------------------------------------------------------- IndexError Traceback (most recent call last) <ipython-input-12-f7eb673eabf2> in <module> 1 # elemento fuera de la lista ----> 2 print( colores[4]) IndexError: list index out of range \u00cdndice negativo Si el \u00edndice es negativo, los elementos se cuentan desde el final hacia atr\u00e1s: colores = [ 'azul' , 'rojo' , 'verde' , 'amarillo' ] print ( colores [ - 1 ]) amarillo Agregar un elemento l.append(x) agrega el elemento x al final de la lista: primos = [ 2 , 3 , 5 , 7 , 11 ] primos . append ( 13 ) print ( primos ) [2, 3, 5, 7, 11, 13] Concatenar dos listas l1 + l2 concatena las listas l1 y l2 : l1 = [ 1 , 2 , 3 ] l2 = [ 4 , 5 , 6 ] print ( l1 + l2 ) [1, 2, 3, 4, 5, 6] Repetir lista l * n repite \\(n\\) veces la lista l : lista = [ 1 , 2 , 3 ] print ( 2 * lista ) [1, 2, 3, 1, 2, 3] Elemento en una lista Para saber si un elemento x est\u00e1 en la lista l , se usa x in l . La versi\u00f3n negativa de in es not in : lista = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] print ( 12 in lista ) False print ( 12 not in lista ) True Operador rebanado l[i:j] es el operador de rebanado, que entrega una nueva lista que tiene desde el i-\u00e9simo hasta justo antes del j-\u00e9simo elemento de la lista l: l = [ 1.5 , 3.3 , 8.4 , 3.1 , 2.9 ] print ( l [ 2 : 4 ]) [8.4, 3.1] Operador \u00edndice l.index(x) entrega cu\u00e1l es el \u00edndice del valor x: colores = [ 'azul' , 'rojo' , 'verde' , 'amarillo' ] print ( colores . index ( 'verde' )) 2 Operador remover l.remove(x) elimina el elemento x de la lista: l = [ 7 , 0 , 3 , 9 , 8 , 2 , 4 ] l . remove ( 2 ) print ( l ) [7, 0, 3, 9, 8, 4] Operador borrar del l[i] elimina el i-\u00e9simo elemento de la lista: l = [ 7 , 0 , 3 , 9 , 8 , 2 , 4 ] del l [ 2 ] print ( l ) [7, 0, 9, 8, 2, 4] Operador reversa l.reverse() invierte la lista: l = [ 7 , 0 , 3 , 9 , 8 , 2 , 4 ] l . reverse () print ( l ) [4, 2, 8, 9, 3, 0, 7] Operador ordenar l.sort() ordena la lista: l = [ 7 , 0 , 3 , 9 , 8 , 2 , 4 ] l . sort () print ( l ) [0, 2, 3, 4, 7, 8, 9]","title":"Operaciones sobre listas"},{"location":"estructura/#iterar-sobre-una-lista","text":"Una lista es un objeto iterable . Esto significa que sus valores se pueden recorrer usando un ciclo for : valores = [ 1 , 2 , 3 , 4 , 5 ] for i in valores : print ( i ** 2 ) 1 4 9 16 25","title":"Iterar sobre una lista"},{"location":"estructura/#tuplas","text":"Una tupla es una secuencia de valores agrupados. Una tupla sirve para agrupar, como si fueran un \u00fanico valor, varios valores que, por su naturaleza, deben ir juntos. El tipo de datos que representa a las tuplas se llama tuple . El tipo tuple es **inmutable: una tupla no puede ser modificada una vez que ha sido creada. numeros = ( \"uno\" , \"dos\" , \"tres\" , \"cuatro\" ) print ( numeros )","title":"Tuplas"},{"location":"estructura/#desempaquetado-de-tuplas","text":"Los valores individuales de una tupla pueden ser recuperados asignando la tupla a las variables respectivas. Esto se llama desempaquetar la tupla (en ingl\u00e9s: unpack): persona = ( 'Javier' , 'Perez' ) nombre , apellido = persona print ( nombre , apellido ) Javier Perez Si se intenta desempaquetar una cantidad incorrecta de valores, ocurre un error de valor: a , b , c = persona --------------------------------------------------------------------------- ValueError Traceback (most recent call last) <ipython-input-4-998bf8320296> in <module> ----> 1 a, b, c = persona ValueError: not enough values to unpack (expected 3, got 2)","title":"Desempaquetado de tuplas"},{"location":"estructura/#comparacion-de-tuplas","text":"Dos tuplas son iguales cuando tienen el mismo tama\u00f1o y cada uno de sus elementos correspondientes tienen el mismo valor: ( 1 , 2 ) == ( 2 / 2 , 1 + 1 ) True ( 6 , 1 ) == ( 6 , 2 ) False Para determinar si una tupla es menor que otra, se utiliza lo que se denomina orden lexicogr\u00e1fico . Si los elementos en la primera posici\u00f3n de ambas tuplas son distintos, ellos determinan el ordenamiento de las tuplas: ( 1 , 4 , 7 ) < ( 2 , 0 , 0 , 1 ) True ( 1 , 9 , 10 ) < ( 0 , 5 ) False","title":"Comparaci\u00f3n de tuplas"},{"location":"estructura/#acceder-a-valores-de-una-tupla","text":"Al igual que las listas, se pueden acceder a distintos elemntos de las tuplas de la siguiente forma: numeros = ( \"uno\" , \"dos\" , \"tres\" , \"cuatro\" ) print ( numeros [ 1 ]) #Output: dos print ( numeros [ 3 ]) #Output: cuatro print ( numeros [ - 1 ]) # Output: cuatro","title":"Acceder a  valores de una tupla"},{"location":"estructura/#iteracion-sobre-tuplas","text":"Al igual que las listas, las tuplas son iterables: for valor in ( 1 , 2 , 3 , 4 , 5 ): print ( valor ** 2 ) 1 4 9 16 25 Adem\u00e1s, se puede convertir una tupla en una lista usando la funci\u00f3n list , y una lista en una tupla usando la funci\u00f3n tuple : a = ( 1 , 2 , 3 ) b = [ 4 , 5 , 6 ] #lista list ( a ) [1, 2, 3] # tupla tuple ( b ) (4, 5, 6)","title":"Iteraci\u00f3n sobre tuplas"},{"location":"estructura/#conjuntos","text":"Un conjunto es una colecci\u00f3n desordenada de valores no repetidos. Los conjuntos de Python son an\u00e1logos a los conjuntos matem\u00e1ticos. El tipo de datos que representa a los conjuntos se llama set .","title":"Conjuntos"},{"location":"estructura/#como-crear-conjuntos","text":"Las dos maneras principales de crear un conjunto son: # usar un conjunto literal, entre llave conjunto = { 1 , 2 , 3 } print ( conjunto ) {1, 2, 3} # set aplicada sobre un iterable conjunto = set ([ 1 , 2 , 3 ]) print ( conjunto ) {1, 2, 3} Los elementos de un conjunto deben ser inmutables. Por ejemplo, no es posible crear un conjunto de listas, pero s\u00ed un conjunto de tuplas: conjunto = {[ 2 , 4 ], [ 6 , 1 ]} --------------------------------------------------------------------------- TypeError Traceback (most recent call last) <ipython-input-34-c1f516a9affc> in <module> ----> 1 s = {[2, 4], [6, 1]} TypeError: unhashable type: 'list' Como un conjunto no es ordenado, no tiene sentido intentar obtener un elemento usando un \u00edndice: conjunto = { 'a' , 'b' , 'c' } conjunto [ 0 ] --------------------------------------------------------------------------- TypeError Traceback (most recent call last) <ipython-input-35-501605a4a770> in <module> 1 conjunto = {'a', 'b', 'c'} ----> 2 conjunto[0] TypeError: 'set' object is not subscriptable Sin embargo, s\u00ed es posible iterar sobre un conjunto usando un ciclo for: conjunto = { 'a' , 'b' , 'c' } for i in conjunto : print ( i ) a c b","title":"C\u00f3mo crear conjuntos"},{"location":"estructura/#operaciones-sobre-conjuntos","text":"Largo del conjunto len(s) entrega el n\u00famero de elementos del conjunto s: len ({ 'azul' , 'verde' , 'rojo' }) 3 Elementos en el conjunto x in s permite saber si el elemento x est\u00e1 en el conjunto s: 3 in { 2 , 3 , 4 } True x not in s permite saber si x no est\u00e1 en s: 3 not in { 2 , 3 , 4 } False Agregar elementos al conjunto s.add(x) agrega el elemento x al conjunto s: s = { 6 , 1 , 5 , 4 , 3 } s . add ( - 37 ) s {-37, 1, 3, 4, 5, 6} Remover elementos al conjunto s.remove(x) elimina el elemento x del conjunto s: s = { 6 , 1 , 5 , 4 , 3 } s . remove ( 1 ) s {3, 4, 5, 6} Si el elemento x no est\u00e1 en el conjunto, ocurre un error de llave: s . remove ( 10 ) --------------------------------------------------------------------------- KeyError Traceback (most recent call last) <ipython-input-42-23b5f1bb77c8> in <module> ----> 1 s.remove(10) KeyError: 10 Operaciones sobre conjuntos & y | son los operadores de intersecci\u00f3n y uni\u00f3n repectivamente: # crear dos conjuntos a = { 1 , 2 , 3 , 4 } b = { 2 , 4 , 6 , 8 } # interseccion a & b {2, 4} # union a | b {1, 2, 3, 4, 6, 8} s - t entrega la diferencia entre s y t; es decir, los elementos de s que no est\u00e1n en t: # diferencia a - b {1, 3} s ^ t entrega la diferencia sim\u00e9trica entre s y t; es decir, los elementos que est\u00e1n en s o en t, pero no en ambos: # diferencia simetrica a ^ b {1, 3, 6, 8} El operador < aplicado sobre conjuntos significa \u00abes subconjunto de\u00bb: { 1 , 2 } < { 1 , 2 , 3 } True { 1 , 4 } < { 1 , 2 , 3 } False s <= t tambi\u00e9n indica si s es subconjunto de t. La distinci\u00f3n ocurre cuando los conjuntos son iguales: { 1 , 2 , 3 } < { 1 , 2 , 3 } False { 1 , 2 , 3 } <= { 1 , 2 , 3 } True","title":"Operaciones sobre conjuntos"},{"location":"estructura/#diccionarios","text":"Un diccionario es un tipo de datos que sirve para asociar pares de objetos. Un diccionario puede ser visto como una colecci\u00f3n de llaves, cada una de las cuales tiene asociada un valor. Las llaves no est\u00e1n ordenadas y no hay llaves repetidas. La \u00fanica manera de acceder a un valor es a trav\u00e9s de su llave.","title":"Diccionarios"},{"location":"estructura/#como-crear-diccionarios","text":"Los diccionarios literales se crean usando llaves ({ y }). La llave y el valor van separados por dos puntos: # diccionario vacio dct = {} dct = dict () # diccionario de enteros dct = { 1 : 'apple' , 2 : 'ball' } # diccionario dde llaves mixtas dct = { 'name' : 'John' , 1 : [ 2 , 4 , 3 ]}","title":"C\u00f3mo crear diccionarios"},{"location":"estructura/#como-usar-un-diccionario","text":"El valor asociado a la llave \\(k\\) en el diccionario \\(dct\\) se puede obtener mediante \\(dct[k]\\) : dct = { 'nombre' : 'Jack' , 'edad' : 26 , 'salario' : 4534.2 } print ( dct [ 'edad' ]) # Output: 26 26 Si se asigna un valor a una llave que ya estaba en el diccionario, el valor anterior se sobreescribe. Recuerde que un diccionario no puede tener llaves repetidas: dct = { 'nombre' : 'Jack' , 'edad' : 26 } # cambiar edad dct [ 'edad' ] = 36 print ( dct ) # Output: {'name': 'Jack', 'age': 36} Tambi\u00e9n se pueden adherir llaves al diccionario # adherir llave salario dct [ 'salario' ] = 4342.4 print ( dct ) # Output: {'name': 'Jack', 'age': 36, 'salary': 4342.4} Por otro lado, si se quiere borrar una llave o el mismo diccionario, se ocupa el comando del # borrar llave edad del dct [ 'edad' ] print ( dct ) # Output: {'name': 'Jack', 'salary': 4342.4} # borrar diccionario del dct","title":"C\u00f3mo usar un diccionario"},{"location":"estructura/#iterar-un-diccionario","text":"Los diccionarios son iterables. Al iterar sobre un diccionario en un ciclo for , se obtiene las llaves: dct = { 1 : 'apple' , 2 : 'ball' } for k in dct : print ( k ) 1 2 Para iterar sobre las llaves, se usa values() : for v in dct . values (): print ( v ) apple ball Para iterar sobre las llaves y los valores simult\u00e1neamente, se usa el m\u00e9todo items() : for k , v in dct . items (): print ( f \"llave: { k } , valor: { v } \" ) llave: 1, valor: apple llave: 2, valor: ball","title":"Iterar un diccionario"},{"location":"estructura/#restricciones-sobre-las-llaves","text":"No se puede usar cualquier objeto como llave de un diccionario. Las llaves deben ser de un tipo de datos inmutable. Por ejemplo, no se puede usar listas: dct = {[ 1 , 2 , 3 ]: 'hola' } --------------------------------------------------------------------------- TypeError Traceback (most recent call last) <ipython-input-30-873bc4fce75e> in <module> ----> 1 dct = {[1, 2, 3]: 'hola'} TypeError: unhashable type: 'list' T\u00edpicamente, se usa n\u00fameros, tuplas y strings como llaves de los diccionarios.","title":"Restricciones sobre las llaves"},{"location":"estructura/#otras-estructuras-de-datos","text":"","title":"Otras estructuras de datos"},{"location":"estructura/#python-range","text":"range() devuelve una secuencia inmutable de n\u00fameros entre el entero de inicio dado al entero de parada. print ( range ( 1 , 10 )) # Output: range(1, 10) range(1, 10) Hemos omitido el par\u00e1metro de step opcional para range() en los ejemplos anteriores. Cuando se omite, el paso predeterminado es 1. Probemos algunos ejemplos con el par\u00e1metro de paso. numero1 = range ( 1 , 6 , 1 ) print ( list ( numero1 )) # Output: [1, 2, 3, 4, 5] [1, 2, 3, 4, 5] numero2 = range ( 1 , 6 , 2 ) print ( list ( numero2 )) # Output: [1, 3, 5] [1, 3, 5] numero3 = range ( 5 , 0 , - 1 ) print ( list ( numero3 )) # Output: [5, 4, 3, 2, 1] [5, 4, 3, 2, 1] El resultado es iterable y puede convertirlo en list , tuple , set , etc. Por ejemplo: numeros = range ( 1 , 6 ) print ( list ( numeros )) # Output: [1, 2, 3, 4, 5] print ( tuple ( numeros )) # Output: (1, 2, 3, 4, 5) print ( set ( numeros )) # Output: {1, 2, 3, 4, 5} # Output: {1: 99, 2: 99, 3: 99, 4: 99, 5: 99} print ( dict . fromkeys ( numeros , 99 ))","title":"Python range()"},{"location":"estructura/#ejercicios","text":"","title":"Ejercicios"},{"location":"estructura/#ejercicio-01","text":"Escriba un programa que muestre la tabla de multiplicar del 1 al 10 del n\u00famero ingresado por el usuario: Ingrese un numero: 9 9 x 1 = 9 9 x 2 = 18 9 x 3 = 27 9 x 4 = 36 9 x 5 = 45 9 x 6 = 54 9 x 7 = 63 9 x 8 = 72 9 x 9 = 81 9 x 10 = 90","title":"Ejercicio 01"},{"location":"estructura/#ejercicio-02","text":"Escriba un programa que genere todas las potencias de 2, desde la 0-\u00e9sima hasta la ingresada por el usuario: Ingrese num: 10 1 2 4 8 16 32 64 128 256 512 1024","title":"Ejercicio 02"},{"location":"estructura/#ejercicio-03","text":"Escribir un programa que almacene las asignaturas de un curso (por ejemplo Matem\u00e1ticas, F\u00edsica, Qu\u00edmica, Historia y Lengua) en una lista y la muestre por pantalla el mensaje Yo estudio <asignatura> , donde <asignatura> es cada una de las asignaturas de la lista.","title":"Ejercicio 03"},{"location":"estructura/#ejercicio-04","text":"Un n\u00famero natural es un pal\u00edndromo si se lee igual de izquierda a derecha y de derecha a izquierda. Por ejemplo, \\(14941\\) es un pal\u00edndromo, mientras que \\(81924\\) no lo es. Escriba un programa que indique si el n\u00famero ingresado es o no pal\u00edndromo: Ingrese un numero: 14941 14941 es palindromo Ingrese un numero: 81924 81924 no es palindromo","title":"Ejercicio 04"},{"location":"estructura/#ejercicio-05","text":"Escribir una funci\u00f3n que reciba una lista de tuplas, y que devuelva un diccionario en donde las claves sean los primeros elementos de las tuplas, y los valores una lista con los segundos. Por ejemplo, dado una lista: l = [ ( 'Nola' , 'don Pepito' ), ( 'Nola' , 'don Jose' ), ( 'Buenos' , 'd\u00edas' ) ] Deber\u00e1 mostrar: { 'Nola': ['don Pepito', 'don Jose'], 'Buenos': ['d\u00edas'] }","title":"Ejercicio 05"},{"location":"flujo/","text":"Control de Flujo EL control de flujo o sentencias de control permiten modificar el flujo del programa introduciendo ciclos y condicionales . Un condicional es un conjunto de sentencias que pueden o no ejecutarse, dependiendo del resultado de una condici\u00f3n. Un ciclo es un conjunto de sentencias que son ejecutadas varias veces, hasta que una condici\u00f3n de t\u00e9rmino es satisfecha. Tanto los condicionales como los ciclos contienen a otras sentencias. Para indicar esta relaci\u00f3n se utiliza la indentaci\u00f3n : las sentencias contenidas no se escriben en la misma columna que la sentencia de control, sino un poco m\u00e1s a la derecha. # definir variables n = 5 m = 10 # inicializar flujo if m < n : t = m m = n n = t # sentencia despues del flujo print ( m , n ) 10 5 Condicional if-elif-else La sentencia if-elif-else depende de dos o m\u00e1s condiciones, que son evaluadas en orden. La primera que es verdadera determina qu\u00e9 instrucciones ser\u00e1n ejecutadas: La sintaxis es la siguiente: if condici\u00f3n1 : qu\u00e9 hacer si condici\u00f3n1 es verdadera elif condici\u00f3n2 : qu\u00e9 hacer si condici\u00f3n2 es verdadera ... else : qu\u00e9 hacer cuando ninguna de las condiciones anteriores es verdadera num = - 1 if num > 0 : print ( \"numero positivo\" ) elif num == 0 : print ( \"cero\" ) else : print ( \"numero negativo\" ) # Output: numero negativo numero negativo Puede haber cero o m\u00e1s partes elif , y la parte else es opcional. La mayor\u00eda de los lenguajes de programaci\u00f3n usan {} para especificar el bloque de c\u00f3digo. Python usa sangr\u00eda. Un bloque de c\u00f3digo comienza con sangr\u00eda y termina con la primera l\u00ednea sin sangr\u00eda. La cantidad de sangr\u00eda depende de usted, pero debe ser consistente a lo largo de ese bloque. En general, se utilizan cuatro espacios en blanco para la sangr\u00eda y se prefieren a las pesta\u00f1as. Probemos con otro ejemplo: if False : print ( \"Hola\" ) print ( \"mundo\" ) print ( \"!!!\" ) # Output: !!! While Loop El ciclo while (\u00abmientras\u00bb) ejecuta una secuencia de instrucciones mientras una condici\u00f3n sea verdadera: Cada una de las veces que el cuerpo del ciclo es ejecutado se llama iteraci\u00f3n. La condici\u00f3n es evaluada antes de cada iteraci\u00f3n. Si la condici\u00f3n es inicialmente falsa, el ciclo no se ejecutar\u00e1 ninguna vez. La sintaxis es la siguiente: while condici\u00f3n : sentencias # definir limite n = 100 # inicializar contador suma = 0 i = 1 while i <= n : suma = suma + i i = i + 1 # actualizar contador print ( f \"La suma es { suma } \" ) # Output: La suma es La suma es 5050 CIclo For Los ciclos for permiten ejecutar una o varias instrucciones de forma iterativa, una vez por cada elemento en la colecci\u00f3n. Las colecciones pueden ser de varios tipos, el for puede recibir una colecci\u00f3n predefinida o directamente de la salida de una funci\u00f3n. numbers = [ 6 , 5 , 3 , 8 , 4 , 2 ] # lista de elementos suma = 0 # iterar sobre la lista for val in numbers : suma = suma + val print ( f \"La suma es { suma } \" ) # Output: La suma es 28 La suma es 28 Salir o continuar un ciclo Break Adem\u00e1s de las condiciones de t\u00e9rmino propias de los ciclos while y for , siempre es posible salir de un ciclo en medio de una iteraci\u00f3n usando la sentencia break . Lo l\u00f3gico es que sea usada dentro de un if , para evitar que el ciclo termine prematuramente en la primera iteraci\u00f3n: numbers = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] for n in numbers : if n % 3 == 0 : break print ( n ) print ( \"Fin\" ) 1 2 Fin Continue La sentencia continue se usa para saltar a la iteraci\u00f3n siguiente sin llegar al final de la que est\u00e1 en curso. numbers = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] for n in numbers : if n % 3 == 0 : continue print ( n ) print ( \"Fin\" ) 1 2 4 5 7 8 Fin Observaci\u00f3n: Supongamos que tiene un bucle o una funci\u00f3n que a\u00fan no est\u00e1 implementada, pero desea implementarla en el futuro. No pueden tener un cuerpo vac\u00edo. El int\u00e9rprete se quejar\u00eda. Por lo tanto, utiliza la instrucci\u00f3n pass para construir un cuerpo que no hace nada. sequence = { 'p' , 'a' , 's' , 's' } for val in sequence : pass La diferencia entre continue y pass es que continue termina la iteraci\u00f3n actual, pero continua con el ciclo, volviendo al inicio del bucle en la siguiente iteraci\u00f3n. En cambio pass simplemente no hace nada y pasa a la siguiente instrucci\u00f3n. Ejercicios Ejercicio 01 Escriba un programa que determine si el n\u00famero entero ingresado por el usuario es par o no. Ingrese un n\u00famero: 4 Su n\u00famero es par Ingrese un n\u00famero: 3 Su n\u00famero es impar Ejercicio 02 Escriba un programa que pida dos n\u00fameros enteros y que calcule la divisi\u00f3n, indicando si la divisi\u00f3n es exacta o no. Dividendo: 14 Divisor: 5 La divisi\u00f3n no es exacta. Cociente: 2 Resto: 4 Dividendo : 100 Divisor : 10 La divisi\u00f3n es exacta . Cociente : 10 Resto : 0 Ejercicio 03 Escriba un programa que pida al usuario dos palabras, y que indique cu\u00e1l de ellas es la m\u00e1s larga y por cu\u00e1ntas letras lo es. Palabra 1: edificio Palabra 2: tren La palabra edificio tiene 4 letras mas que tren. Palabra 1: sol Palabra 2: paralelepipedo La palabra paralelepipedo tiene 11 letras mas que sol Palabra 1: plancha Palabra 2: lapices Las dos palabras tienen el mismo largo Ejercicio 04 Cuando la Tierra completa una \u00f3rbita alrededor del Sol, no han transcurrido exactamente 365 rotaciones sobre s\u00ed misma, sino un poco m\u00e1s. M\u00e1s precisamente, la diferencia es de m\u00e1s o menos un cuarto de d\u00eda. Para evitar que las estaciones se desfasen con el calendario, el calendario juliano introdujo la regla de introducir un d\u00eda adicional en los a\u00f1os divisibles por 4 (llamados bisiestos ), para tomar en consideraci\u00f3n los cuatro cuartos de d\u00eda acumulados. Sin embargo, bajo esta regla sigue habiendo un desfase, que es de aproximadamente 3/400 de d\u00eda. Para corregir este desfase, en el a\u00f1o 1582 el papa Gregorio XIII introdujo un nuevo calendario, en el que el \u00faltimo a\u00f1o de cada siglo dejaba de ser bisiesto, a no ser que fuera divisible por 400. Escriba un programa que indique si un a\u00f1o es bisiesto o no, teniendo en cuenta cu\u00e1l era el calendario vigente en ese a\u00f1o: Ingrese un anno: 1988 1988 es bisiesto Ingrese un anno: 2011 2011 no es bisiesto Ingrese un anno: 1700 1700 no es bisiesto Ingrese un anno: 1500 1500 es bisiesto Ingrese un anno: 2400 2400 es bisiesto Ejercicio 05 Los tres lados \\(a, b\\) y \\(c\\) de un tri\u00e1ngulo deben satisfacer la desigualdad triangular : cada uno de los lados no puede ser m\u00e1s largo que la suma de los otros dos. Escriba un programa que reciba como entrada los tres lados de un tri\u00e1ngulo, e indique: si acaso el tri\u00e1ngulo es inv\u00e1lido si el tri\u00e1ngulo es v\u00e1lido, qu\u00e9 tipo de tri\u00e1ngulo es. Ingrese a: 3.9 Ingrese b: 6.0 Ingrese c: 1.2 No es un triangulo valido. Ingrese a: 1.9 Ingrese b: 2 Ingrese c: 2 El triangulo es isoceles. Ingrese a: 3.0 Ingrese b: 5.0 Ingrese c: 4.0 El triangulo es escaleno. Ingrese a: 2 Ingrese b: 2 Ingrese c: 2 El triangulo es equilatero. Ejercicio 06 El riesgo de que una persona sufra enfermedades coronarias depende de su edad y su \u00edndice de masa corporal: edad < 45 edad \u2265 45 IMC < 22.0 bajo medio IMC \u2265 22.0 medio alto El \u00edndice de masa corporal es el cuociente entre el peso del individuo en kilos y el cuadrado de su estatura en metros ($IMC = \\dfrac{peso}{estatura^2} $). Escriba un programa que reciba como entrada la estatura, el peso y la edad de una persona, y le entregue su condici\u00f3n de riesgo. Ejercicio 07 Escriba un programa que pida dos n\u00fameros enteros. El programa pedir\u00e1 de nuevo el segundo n\u00famero mientras no sea mayor que el primero. El programa terminar\u00e1 escribiendo los dos n\u00fameros. Escriba un n\u00famero: 6 Escriba un n\u00famero mayor que 6: 6 6 no es mayor que 6. Int\u00e9ntelo de nuevo: 1 1 no es mayor que 6. Int\u00e9ntelo de nuevo: 8 Los n\u00fameros que ha escrito son 6 y 8. Ejercicio 08 Escriba un programa que pida n\u00fameros mientras no se escriba un n\u00famero negativo. El programa terminar\u00e1 escribiendo la suma de los n\u00fameros introducidos. Escriba un n\u00famero: -4 La suma de los n\u00fameros positivos introducidos es 0. Escriba un n\u00famero: 12 Escriba otro n\u00famero: 3 Escriba otro n\u00famero: 0 Escriba otro n\u00famero: 7 Escriba otro n\u00famero: -1 La suma de los n\u00fameros positivos introducidos es 22.","title":"Control de Flujo"},{"location":"flujo/#control-de-flujo","text":"EL control de flujo o sentencias de control permiten modificar el flujo del programa introduciendo ciclos y condicionales . Un condicional es un conjunto de sentencias que pueden o no ejecutarse, dependiendo del resultado de una condici\u00f3n. Un ciclo es un conjunto de sentencias que son ejecutadas varias veces, hasta que una condici\u00f3n de t\u00e9rmino es satisfecha. Tanto los condicionales como los ciclos contienen a otras sentencias. Para indicar esta relaci\u00f3n se utiliza la indentaci\u00f3n : las sentencias contenidas no se escriben en la misma columna que la sentencia de control, sino un poco m\u00e1s a la derecha. # definir variables n = 5 m = 10 # inicializar flujo if m < n : t = m m = n n = t # sentencia despues del flujo print ( m , n ) 10 5","title":"Control de Flujo"},{"location":"flujo/#condicional-if-elif-else","text":"La sentencia if-elif-else depende de dos o m\u00e1s condiciones, que son evaluadas en orden. La primera que es verdadera determina qu\u00e9 instrucciones ser\u00e1n ejecutadas: La sintaxis es la siguiente: if condici\u00f3n1 : qu\u00e9 hacer si condici\u00f3n1 es verdadera elif condici\u00f3n2 : qu\u00e9 hacer si condici\u00f3n2 es verdadera ... else : qu\u00e9 hacer cuando ninguna de las condiciones anteriores es verdadera num = - 1 if num > 0 : print ( \"numero positivo\" ) elif num == 0 : print ( \"cero\" ) else : print ( \"numero negativo\" ) # Output: numero negativo numero negativo Puede haber cero o m\u00e1s partes elif , y la parte else es opcional. La mayor\u00eda de los lenguajes de programaci\u00f3n usan {} para especificar el bloque de c\u00f3digo. Python usa sangr\u00eda. Un bloque de c\u00f3digo comienza con sangr\u00eda y termina con la primera l\u00ednea sin sangr\u00eda. La cantidad de sangr\u00eda depende de usted, pero debe ser consistente a lo largo de ese bloque. En general, se utilizan cuatro espacios en blanco para la sangr\u00eda y se prefieren a las pesta\u00f1as. Probemos con otro ejemplo: if False : print ( \"Hola\" ) print ( \"mundo\" ) print ( \"!!!\" ) # Output: !!!","title":"Condicional if-elif-else"},{"location":"flujo/#while-loop","text":"El ciclo while (\u00abmientras\u00bb) ejecuta una secuencia de instrucciones mientras una condici\u00f3n sea verdadera: Cada una de las veces que el cuerpo del ciclo es ejecutado se llama iteraci\u00f3n. La condici\u00f3n es evaluada antes de cada iteraci\u00f3n. Si la condici\u00f3n es inicialmente falsa, el ciclo no se ejecutar\u00e1 ninguna vez. La sintaxis es la siguiente: while condici\u00f3n : sentencias # definir limite n = 100 # inicializar contador suma = 0 i = 1 while i <= n : suma = suma + i i = i + 1 # actualizar contador print ( f \"La suma es { suma } \" ) # Output: La suma es La suma es 5050","title":"While Loop"},{"location":"flujo/#ciclo-for","text":"Los ciclos for permiten ejecutar una o varias instrucciones de forma iterativa, una vez por cada elemento en la colecci\u00f3n. Las colecciones pueden ser de varios tipos, el for puede recibir una colecci\u00f3n predefinida o directamente de la salida de una funci\u00f3n. numbers = [ 6 , 5 , 3 , 8 , 4 , 2 ] # lista de elementos suma = 0 # iterar sobre la lista for val in numbers : suma = suma + val print ( f \"La suma es { suma } \" ) # Output: La suma es 28 La suma es 28","title":"CIclo For"},{"location":"flujo/#salir-o-continuar-un-ciclo","text":"","title":"Salir o continuar un ciclo"},{"location":"flujo/#break","text":"Adem\u00e1s de las condiciones de t\u00e9rmino propias de los ciclos while y for , siempre es posible salir de un ciclo en medio de una iteraci\u00f3n usando la sentencia break . Lo l\u00f3gico es que sea usada dentro de un if , para evitar que el ciclo termine prematuramente en la primera iteraci\u00f3n: numbers = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] for n in numbers : if n % 3 == 0 : break print ( n ) print ( \"Fin\" ) 1 2 Fin","title":"Break"},{"location":"flujo/#continue","text":"La sentencia continue se usa para saltar a la iteraci\u00f3n siguiente sin llegar al final de la que est\u00e1 en curso. numbers = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] for n in numbers : if n % 3 == 0 : continue print ( n ) print ( \"Fin\" ) 1 2 4 5 7 8 Fin Observaci\u00f3n: Supongamos que tiene un bucle o una funci\u00f3n que a\u00fan no est\u00e1 implementada, pero desea implementarla en el futuro. No pueden tener un cuerpo vac\u00edo. El int\u00e9rprete se quejar\u00eda. Por lo tanto, utiliza la instrucci\u00f3n pass para construir un cuerpo que no hace nada. sequence = { 'p' , 'a' , 's' , 's' } for val in sequence : pass La diferencia entre continue y pass es que continue termina la iteraci\u00f3n actual, pero continua con el ciclo, volviendo al inicio del bucle en la siguiente iteraci\u00f3n. En cambio pass simplemente no hace nada y pasa a la siguiente instrucci\u00f3n.","title":"Continue"},{"location":"flujo/#ejercicios","text":"","title":"Ejercicios"},{"location":"flujo/#ejercicio-01","text":"Escriba un programa que determine si el n\u00famero entero ingresado por el usuario es par o no. Ingrese un n\u00famero: 4 Su n\u00famero es par Ingrese un n\u00famero: 3 Su n\u00famero es impar","title":"Ejercicio 01"},{"location":"flujo/#ejercicio-02","text":"Escriba un programa que pida dos n\u00fameros enteros y que calcule la divisi\u00f3n, indicando si la divisi\u00f3n es exacta o no. Dividendo: 14 Divisor: 5 La divisi\u00f3n no es exacta. Cociente: 2 Resto: 4 Dividendo : 100 Divisor : 10 La divisi\u00f3n es exacta . Cociente : 10 Resto : 0","title":"Ejercicio 02"},{"location":"flujo/#ejercicio-03","text":"Escriba un programa que pida al usuario dos palabras, y que indique cu\u00e1l de ellas es la m\u00e1s larga y por cu\u00e1ntas letras lo es. Palabra 1: edificio Palabra 2: tren La palabra edificio tiene 4 letras mas que tren. Palabra 1: sol Palabra 2: paralelepipedo La palabra paralelepipedo tiene 11 letras mas que sol Palabra 1: plancha Palabra 2: lapices Las dos palabras tienen el mismo largo","title":"Ejercicio 03"},{"location":"flujo/#ejercicio-04","text":"Cuando la Tierra completa una \u00f3rbita alrededor del Sol, no han transcurrido exactamente 365 rotaciones sobre s\u00ed misma, sino un poco m\u00e1s. M\u00e1s precisamente, la diferencia es de m\u00e1s o menos un cuarto de d\u00eda. Para evitar que las estaciones se desfasen con el calendario, el calendario juliano introdujo la regla de introducir un d\u00eda adicional en los a\u00f1os divisibles por 4 (llamados bisiestos ), para tomar en consideraci\u00f3n los cuatro cuartos de d\u00eda acumulados. Sin embargo, bajo esta regla sigue habiendo un desfase, que es de aproximadamente 3/400 de d\u00eda. Para corregir este desfase, en el a\u00f1o 1582 el papa Gregorio XIII introdujo un nuevo calendario, en el que el \u00faltimo a\u00f1o de cada siglo dejaba de ser bisiesto, a no ser que fuera divisible por 400. Escriba un programa que indique si un a\u00f1o es bisiesto o no, teniendo en cuenta cu\u00e1l era el calendario vigente en ese a\u00f1o: Ingrese un anno: 1988 1988 es bisiesto Ingrese un anno: 2011 2011 no es bisiesto Ingrese un anno: 1700 1700 no es bisiesto Ingrese un anno: 1500 1500 es bisiesto Ingrese un anno: 2400 2400 es bisiesto","title":"Ejercicio 04"},{"location":"flujo/#ejercicio-05","text":"Los tres lados \\(a, b\\) y \\(c\\) de un tri\u00e1ngulo deben satisfacer la desigualdad triangular : cada uno de los lados no puede ser m\u00e1s largo que la suma de los otros dos. Escriba un programa que reciba como entrada los tres lados de un tri\u00e1ngulo, e indique: si acaso el tri\u00e1ngulo es inv\u00e1lido si el tri\u00e1ngulo es v\u00e1lido, qu\u00e9 tipo de tri\u00e1ngulo es. Ingrese a: 3.9 Ingrese b: 6.0 Ingrese c: 1.2 No es un triangulo valido. Ingrese a: 1.9 Ingrese b: 2 Ingrese c: 2 El triangulo es isoceles. Ingrese a: 3.0 Ingrese b: 5.0 Ingrese c: 4.0 El triangulo es escaleno. Ingrese a: 2 Ingrese b: 2 Ingrese c: 2 El triangulo es equilatero.","title":"Ejercicio 05"},{"location":"flujo/#ejercicio-06","text":"El riesgo de que una persona sufra enfermedades coronarias depende de su edad y su \u00edndice de masa corporal: edad < 45 edad \u2265 45 IMC < 22.0 bajo medio IMC \u2265 22.0 medio alto El \u00edndice de masa corporal es el cuociente entre el peso del individuo en kilos y el cuadrado de su estatura en metros ($IMC = \\dfrac{peso}{estatura^2} $). Escriba un programa que reciba como entrada la estatura, el peso y la edad de una persona, y le entregue su condici\u00f3n de riesgo.","title":"Ejercicio 06"},{"location":"flujo/#ejercicio-07","text":"Escriba un programa que pida dos n\u00fameros enteros. El programa pedir\u00e1 de nuevo el segundo n\u00famero mientras no sea mayor que el primero. El programa terminar\u00e1 escribiendo los dos n\u00fameros. Escriba un n\u00famero: 6 Escriba un n\u00famero mayor que 6: 6 6 no es mayor que 6. Int\u00e9ntelo de nuevo: 1 1 no es mayor que 6. Int\u00e9ntelo de nuevo: 8 Los n\u00fameros que ha escrito son 6 y 8.","title":"Ejercicio 07"},{"location":"flujo/#ejercicio-08","text":"Escriba un programa que pida n\u00fameros mientras no se escriba un n\u00famero negativo. El programa terminar\u00e1 escribiendo la suma de los n\u00fameros introducidos. Escriba un n\u00famero: -4 La suma de los n\u00fameros positivos introducidos es 0. Escriba un n\u00famero: 12 Escriba otro n\u00famero: 3 Escriba otro n\u00famero: 0 Escriba otro n\u00famero: 7 Escriba otro n\u00famero: -1 La suma de los n\u00fameros positivos introducidos es 22.","title":"Ejercicio 08"},{"location":"funcional/","text":"Programaci\u00f3n Funcional Paradigmas de programaci\u00f3n Python es un lenguaje de programaci\u00f3n interpretado cuya filosof\u00eda hace hincapi\u00e9 en la legibilidad de su c\u00f3digo. Se trata de un lenguaje de programaci\u00f3n multiparadigma, ya que soporta orientaci\u00f3n a objetos, programaci\u00f3n imperativa y, en menor medida, programaci\u00f3n funcional. Quiere decir que acepta diversas formar de trabajar con el lenguaje. B\u00e1sicamente existen 3 paradigmas predominantes, o dicho de otra manera, 3 formatos globales de organizar un c\u00f3digo. Programaci\u00f3n imperativa (estructurada), el c\u00f3digo ser\u00e1 ejecutado desde el principio del fichero al final sin seguir ning\u00fan tipo de desviaci\u00f3n. Su mayor ventaja radica en su simplicidad y poco peso. Su peligrosidad es el c\u00f3digo espagueti, archivos con centenares o miles de l\u00edneas donde solo unos pocos seres humanos son capaces de modificar y salir victoriosos. Programaci\u00f3n orientada a objetos (OOP o Object Oriented Programming), donde se encapsulan las variables y funciones en peque\u00f1os m\u00f3dulos capaces de clonarse y modificarse. Su punto fuerte es la capacidad de re-utilizaci\u00f3n y aislamiento para evitar problemas con otras funcionalidades. La parte negativa recae en la complejidad de crear buenos objetos y la depuraci\u00f3n. Programaci\u00f3n funcional (FP o Functional programming), donde el c\u00f3digo se reparte en sencillas funciones capaces de ser invocadas con variables u otras funciones. Su facilidad de uso por atomicidad logra un mantenimiento s\u00f3lido y compatible con casi cualquier lenguaje. Adem\u00e1s su inmutabilidad de variables evita gran parte de los problemas que si sufre la programaci\u00f3n orientada a objetos. Para seguir profundizando, leer el libro Clean Architecture - Robert C. Martin . Principios de la programaci\u00f3n funcional Uso de funciones : Como su nombre indica, todo se construye por medio de funciones. Funciones de primera clase : Las funciones son tratadas como una variable m\u00e1s. Incluso pueden ser devueltas. Funciones puras : Totalmente predictivo, los mismos datos de entrada producir\u00e1n los mismos datos de salida. Puedes sustituir el par\u00e1metro de entrada de sin que ello altere el flujo del programa. Recursividad : Las funciones se pueden llamar a si mismas simplificando tareas como recorrer \u00e1rboles de datos o la gesti\u00f3n de bucles controlados. Inmutabilidad : No hay variables, solo constantes. Evaluaci\u00f3n perezosa (no estricta): En la programaci\u00f3n funcional podemos trabajar con expresiones que no han sido evaluadas, o dicho de otra manera, podemos disponer de variables con operaciones cuyo resultado a\u00fan no se conoce. Funciones Las funciones en Python es que estas pueden ser asignadas a variables, lo cual nos abre la puerta a que funciones puedan ser usadas como argumento de otras funciones y que funciones retornen funciones. # funcion suma de dos numeros def suma ( val1 = 0 , val2 = 0 ): return val1 + val2 resultado = suma ( 10 , 20 ) print ( resultado ) 30 Funciones an\u00f3nimas o lambdas Habr\u00e1 ocasiones en las cuales necesitemos crear funciones de manera r\u00e1pida, en tiempo de ejecuci\u00f3n. Funciones las cuales realizan una tarea en concreto, regularmente peque\u00f1a. En estos casos haremos uso de funciones lambda . Una funci\u00f3n lambda es una funci\u00f3n an\u00f3nima, una funci\u00f3n que no posee un nombre. En Python la estructura de una funci\u00f3n lambda es la siguiente. lambda argumentos : cuerpo de la funci\u00f3n # un argumento funcion = lambda a : 1 + a print ( funcion ( 3 )) 4 # varios argumentos suma = lambda val1 = 0 , val2 = 0 : val1 + val2 print ( suma ( 10 , 20 )) 30 Funci\u00f3n map La funci\u00f3n map permite aplicar una funci\u00f3n a una secuencia de elementos como un iterable (Listas, tuplas, etc...). Es una forma r\u00e1pida, limpia y, lo que es m\u00e1s importante, legible de realizar la operaci\u00f3n. La estructura de la funci\u00f3n es la siguiente. map(funci\u00f3n a aplicar, objeto iterable) #Obtener el cuadrado de todos los elementos en la lista. def cuadrado ( elemento = 0 ): return elemento * elemento lista = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] resultado = list ( map ( cuadrado , lista ) ) print ( resultado ) [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] Funci\u00f3n filter La funci\u00f3n filter , es quiz\u00e1s, una de las funciones m\u00e1s utilizadas al momento de trabajar con colecciones. C\u00f3mo su nombre lo indica, esta funci\u00f3n nos permite realizar un filtro sobre los elementos de la colecci\u00f3n. La estructura de la funci\u00f3n es la siguiente. filter(funci\u00f3n a aplicar, objeto iterable) #Obtener la cantidad de elementos mayores a 5 en la tupla. def mayor_a_cinco ( elemento ): return elemento > 5 tupla = ( 5 , 2 , 6 , 7 , 8 , 10 , 77 , 55 , 2 , 1 , 30 , 4 , 2 , 3 ) resultado = tuple ( filter ( mayor_a_cinco , tupla )) print ( resultado ) (6, 7, 8, 10, 77, 55, 30) Funci\u00f3n reduce Usaremos la funci\u00f3n reduce cuando poseamos una colecci\u00f3n de elementos y necesitemos generar un \u00fanico resultado. reduce nos permitir\u00e1 reducir los elementos de la colecci\u00f3n. Podemos ver a esta funci\u00f3n como un acumulador. La estructura de la funci\u00f3n es la siguiente. reduce(funci\u00f3n a aplicar, objeto iterable) #Obtener la suma de todos los elementos en la lista lista = [ 1 , 2 , 3 , 4 ] acumulador = 0 ; for elemento in lista : acumulador += elemento print ( acumulador ) 10 Como observamos, para resolver el problema tuvimos que declarar una variable (acumulador). Variable que comienza con el valor de 0. Al recorrer la lista, el valor de nuestra variable incrementa. Su nuevo valor es el valor actual m\u00e1s el valor del elemento en la lista. Hasta aqu\u00ed no creo que exista alguna duda. Ahora veamos el mismo ejemplo utilizando la funci\u00f3n reduce . from functools import reduce lista = [ 1 , 2 , 3 , 4 ] def funcion_acumulador ( acumulador = 0 , elemento = 0 ): return acumulador + elemento resultado = reduce ( funcion_acumulador , lista ) print ( resultado ) 10 Por cada elemento de la colecci\u00f3n se ejecuta la funci\u00f3n, funcion_acumulador . La funci\u00f3n retorna la suma de los par\u00e1metros, este valor es almacenado en nuestro acumulador. Al finalizar la iteraci\u00f3n de todos los elementos, reduce retornar\u00e1 el valor del acumulador. Ejercicios Ejercicio 01 Ocupando la notaci\u00f3n lambda , crear las funciones operacionales b\u00e1sicas, es decir, suma resta multiplicaici\u00f3n divisi\u00f3n resto potencia Ejercicio 02 Ocupando la notaci\u00f3n map , crear una funci\u00f3n que tome una lista de d\u00edgitos y analice si el n\u00famero objetivo es primo o no. Ejercicio 03 Ocupando la notaci\u00f3n filter , crear una funci\u00f3n que tome una lista de d\u00edgitos y analice si el n\u00famero objetivo es un cuadrado perfecto o no. Ejercicio 04 Ocupando la notaci\u00f3n reduce , crear una funci\u00f3n que tome una lista de d\u00edgitos y devuelva al n\u00famero al que corresponden. Por ejemplo [1,2,3] corresponde a el numero ciento veintitr\u00e9s ( \\(123\\) ).","title":"Programaci\u00f3n Funcional"},{"location":"funcional/#programacion-funcional","text":"","title":"Programaci\u00f3n Funcional"},{"location":"funcional/#paradigmas-de-programacion","text":"Python es un lenguaje de programaci\u00f3n interpretado cuya filosof\u00eda hace hincapi\u00e9 en la legibilidad de su c\u00f3digo. Se trata de un lenguaje de programaci\u00f3n multiparadigma, ya que soporta orientaci\u00f3n a objetos, programaci\u00f3n imperativa y, en menor medida, programaci\u00f3n funcional. Quiere decir que acepta diversas formar de trabajar con el lenguaje. B\u00e1sicamente existen 3 paradigmas predominantes, o dicho de otra manera, 3 formatos globales de organizar un c\u00f3digo. Programaci\u00f3n imperativa (estructurada), el c\u00f3digo ser\u00e1 ejecutado desde el principio del fichero al final sin seguir ning\u00fan tipo de desviaci\u00f3n. Su mayor ventaja radica en su simplicidad y poco peso. Su peligrosidad es el c\u00f3digo espagueti, archivos con centenares o miles de l\u00edneas donde solo unos pocos seres humanos son capaces de modificar y salir victoriosos. Programaci\u00f3n orientada a objetos (OOP o Object Oriented Programming), donde se encapsulan las variables y funciones en peque\u00f1os m\u00f3dulos capaces de clonarse y modificarse. Su punto fuerte es la capacidad de re-utilizaci\u00f3n y aislamiento para evitar problemas con otras funcionalidades. La parte negativa recae en la complejidad de crear buenos objetos y la depuraci\u00f3n. Programaci\u00f3n funcional (FP o Functional programming), donde el c\u00f3digo se reparte en sencillas funciones capaces de ser invocadas con variables u otras funciones. Su facilidad de uso por atomicidad logra un mantenimiento s\u00f3lido y compatible con casi cualquier lenguaje. Adem\u00e1s su inmutabilidad de variables evita gran parte de los problemas que si sufre la programaci\u00f3n orientada a objetos. Para seguir profundizando, leer el libro Clean Architecture - Robert C. Martin .","title":"Paradigmas de programaci\u00f3n"},{"location":"funcional/#principios-de-la-programacion-funcional","text":"Uso de funciones : Como su nombre indica, todo se construye por medio de funciones. Funciones de primera clase : Las funciones son tratadas como una variable m\u00e1s. Incluso pueden ser devueltas. Funciones puras : Totalmente predictivo, los mismos datos de entrada producir\u00e1n los mismos datos de salida. Puedes sustituir el par\u00e1metro de entrada de sin que ello altere el flujo del programa. Recursividad : Las funciones se pueden llamar a si mismas simplificando tareas como recorrer \u00e1rboles de datos o la gesti\u00f3n de bucles controlados. Inmutabilidad : No hay variables, solo constantes. Evaluaci\u00f3n perezosa (no estricta): En la programaci\u00f3n funcional podemos trabajar con expresiones que no han sido evaluadas, o dicho de otra manera, podemos disponer de variables con operaciones cuyo resultado a\u00fan no se conoce.","title":"Principios de la programaci\u00f3n funcional"},{"location":"funcional/#funciones","text":"Las funciones en Python es que estas pueden ser asignadas a variables, lo cual nos abre la puerta a que funciones puedan ser usadas como argumento de otras funciones y que funciones retornen funciones. # funcion suma de dos numeros def suma ( val1 = 0 , val2 = 0 ): return val1 + val2 resultado = suma ( 10 , 20 ) print ( resultado ) 30","title":"Funciones"},{"location":"funcional/#funciones-anonimas-o-lambdas","text":"Habr\u00e1 ocasiones en las cuales necesitemos crear funciones de manera r\u00e1pida, en tiempo de ejecuci\u00f3n. Funciones las cuales realizan una tarea en concreto, regularmente peque\u00f1a. En estos casos haremos uso de funciones lambda . Una funci\u00f3n lambda es una funci\u00f3n an\u00f3nima, una funci\u00f3n que no posee un nombre. En Python la estructura de una funci\u00f3n lambda es la siguiente. lambda argumentos : cuerpo de la funci\u00f3n # un argumento funcion = lambda a : 1 + a print ( funcion ( 3 )) 4 # varios argumentos suma = lambda val1 = 0 , val2 = 0 : val1 + val2 print ( suma ( 10 , 20 )) 30","title":"Funciones an\u00f3nimas o lambdas"},{"location":"funcional/#funcion-map","text":"La funci\u00f3n map permite aplicar una funci\u00f3n a una secuencia de elementos como un iterable (Listas, tuplas, etc...). Es una forma r\u00e1pida, limpia y, lo que es m\u00e1s importante, legible de realizar la operaci\u00f3n. La estructura de la funci\u00f3n es la siguiente. map(funci\u00f3n a aplicar, objeto iterable) #Obtener el cuadrado de todos los elementos en la lista. def cuadrado ( elemento = 0 ): return elemento * elemento lista = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] resultado = list ( map ( cuadrado , lista ) ) print ( resultado ) [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]","title":"Funci\u00f3n map"},{"location":"funcional/#funcion-filter","text":"La funci\u00f3n filter , es quiz\u00e1s, una de las funciones m\u00e1s utilizadas al momento de trabajar con colecciones. C\u00f3mo su nombre lo indica, esta funci\u00f3n nos permite realizar un filtro sobre los elementos de la colecci\u00f3n. La estructura de la funci\u00f3n es la siguiente. filter(funci\u00f3n a aplicar, objeto iterable) #Obtener la cantidad de elementos mayores a 5 en la tupla. def mayor_a_cinco ( elemento ): return elemento > 5 tupla = ( 5 , 2 , 6 , 7 , 8 , 10 , 77 , 55 , 2 , 1 , 30 , 4 , 2 , 3 ) resultado = tuple ( filter ( mayor_a_cinco , tupla )) print ( resultado ) (6, 7, 8, 10, 77, 55, 30)","title":"Funci\u00f3n filter"},{"location":"funcional/#funcion-reduce","text":"Usaremos la funci\u00f3n reduce cuando poseamos una colecci\u00f3n de elementos y necesitemos generar un \u00fanico resultado. reduce nos permitir\u00e1 reducir los elementos de la colecci\u00f3n. Podemos ver a esta funci\u00f3n como un acumulador. La estructura de la funci\u00f3n es la siguiente. reduce(funci\u00f3n a aplicar, objeto iterable) #Obtener la suma de todos los elementos en la lista lista = [ 1 , 2 , 3 , 4 ] acumulador = 0 ; for elemento in lista : acumulador += elemento print ( acumulador ) 10 Como observamos, para resolver el problema tuvimos que declarar una variable (acumulador). Variable que comienza con el valor de 0. Al recorrer la lista, el valor de nuestra variable incrementa. Su nuevo valor es el valor actual m\u00e1s el valor del elemento en la lista. Hasta aqu\u00ed no creo que exista alguna duda. Ahora veamos el mismo ejemplo utilizando la funci\u00f3n reduce . from functools import reduce lista = [ 1 , 2 , 3 , 4 ] def funcion_acumulador ( acumulador = 0 , elemento = 0 ): return acumulador + elemento resultado = reduce ( funcion_acumulador , lista ) print ( resultado ) 10 Por cada elemento de la colecci\u00f3n se ejecuta la funci\u00f3n, funcion_acumulador . La funci\u00f3n retorna la suma de los par\u00e1metros, este valor es almacenado en nuestro acumulador. Al finalizar la iteraci\u00f3n de todos los elementos, reduce retornar\u00e1 el valor del acumulador.","title":"Funci\u00f3n reduce"},{"location":"funcional/#ejercicios","text":"","title":"Ejercicios"},{"location":"funcional/#ejercicio-01","text":"Ocupando la notaci\u00f3n lambda , crear las funciones operacionales b\u00e1sicas, es decir, suma resta multiplicaici\u00f3n divisi\u00f3n resto potencia","title":"Ejercicio 01"},{"location":"funcional/#ejercicio-02","text":"Ocupando la notaci\u00f3n map , crear una funci\u00f3n que tome una lista de d\u00edgitos y analice si el n\u00famero objetivo es primo o no.","title":"Ejercicio 02"},{"location":"funcional/#ejercicio-03","text":"Ocupando la notaci\u00f3n filter , crear una funci\u00f3n que tome una lista de d\u00edgitos y analice si el n\u00famero objetivo es un cuadrado perfecto o no.","title":"Ejercicio 03"},{"location":"funcional/#ejercicio-04","text":"Ocupando la notaci\u00f3n reduce , crear una funci\u00f3n que tome una lista de d\u00edgitos y devuelva al n\u00famero al que corresponden. Por ejemplo [1,2,3] corresponde a el numero ciento veintitr\u00e9s ( \\(123\\) ).","title":"Ejercicio 04"},{"location":"funciones/","text":"Funciones y m\u00f3dulos Funciones en python En programaci\u00f3n, una funci\u00f3n es una secci\u00f3n de un programa que calcula un valor de manera independiente al resto del programa. Una funci\u00f3n tiene tres componentes importantes: los par\u00e1metros , que son los valores que recibe la funci\u00f3n como entrada; el c\u00f3digo de la funci\u00f3n , que son las operaciones que hace la funci\u00f3n; y el resultado (o valor de retorno), que es el valor final que entrega la funci\u00f3n. En esencia, una funci\u00f3n es un mini programa. Sus tres componentes son an\u00e1logos a la entrada, el proceso y la salida de un programa. Definici\u00f3n de funciones Las funciones en Python son creadas mediante la sentencia def : def nombre ( parametro_1 , ... , parametro_n ): \"\"\" Descripcion de la funcion (opcional) \"\"\" # c\u00f3digo de la funci\u00f3n resultado = operacion ( parametro_1 , ... , parametro_n ) return resultado # output de la funcion Los par\u00e1metros son variables en las que quedan almacenados los valores de entrada. La funci\u00f3n contiene c\u00f3digo igual al de cualquier programa. La diferencia es que, al terminar, debe entregar su resultado usando la sentencia return . Veamos algunos ejemplos: # ejemplo: funcion suma def suma ( x , y ): \"\"\" Sumar dos numeros \"\"\" resultado = x + y return resultado La funci\u00f3n creada se llama suma y cumple el objetivo de sumar dos n\u00fameros. Para instancia la funci\u00f3n, se ejecuta la siguiente sentencia: n1 = 2 n2 = 3 valor_suma = suma ( n1 , n2 ) print ( f \"El valor de la suma de { n1 } y { n2 } es { valor_suma } \" ) El valor de la suma de 2 y 3 es 5 Por otro lado, dado que no se especifica el tipo de datos, podemos sumar dos strings n1 = \"Hola \" n2 = \"Mundo\" valor_suma = suma ( n1 , n2 ) print ( f \"El valor de la suma de { n1 } y { n2 } es { valor_suma } \" ) El valor de la suma de Hola y Mundo es Hola Mundo Por lo que se debe tener cuidado tanto con el nombre de la funci\u00f3n (se espera que pueda resumir la funcion en una o dos palabras) y el tipo de argumentos que queremos que reciba. A continuaci\u00f3n, se crear\u00e1 la funci\u00f3n factorial , la cual entregar\u00e1 el factorial de un n\u00famero entero no negativo. def factorial ( n ): \"\"\" factorial de un numero entero no negativo \"\"\" f = 1 for i in range ( 1 , n + 1 ): f *= i return f En este ejemplo, el resultado que entrega una llamada a la funci\u00f3n es el valor que tiene la variable f al llegar a la \u00faltima l\u00ednea de la funci\u00f3n. Una vez creada, la funci\u00f3n puede ser usada como cualquier otra, todas las veces que sea necesario: factorial ( 0 ) 1 factorial ( 2 ) + factorial ( 5 ) 482630400 Las variables que son creadas dentro de la funci\u00f3n (incluyendo los par\u00e1metros y el resultado) se llaman variables locales , y s\u00f3lo son visibles dentro de la funci\u00f3n, no desde el resto del programa. Por otra parte, las variables creadas fuera de alguna funci\u00f3n se llaman variables globales , y son visibles desde cualquier parte del programa. Sin embargo, su valor no puede ser modificado, ya que una asignaci\u00f3n crear\u00eda una variable local del mismo nombre. # ejemplo variable global valor = 10 # variable global def funcion_01 ( x ): return valor * x # ejemplo variable local def funcion_02 ( x , valor ): return valor * x Nota : Dependiendo del uso que le d\u00e9 a su c\u00f3digo es que ocupar\u00e1 variables globales o no, sin embargo, es preferible definir su funci\u00f3n solo con variables locales , puesto que esto deja expl\u00edcita la dependencia de dicha variable dentro de su funci\u00f3n objetivo. Por otro lado, existen funciones que no necesariamente reciben argumentos. def imprimir_pantalla (): return \"Mensaje random\" imprimir_pantalla () 'Mensaje random' Tambi\u00e9n, existen funciones que no retornan valores : def imprimir_nombre ( nombre ): print ( nombre ) imprimir_nombre ( \"nombre_01\" ) nombre_01 Formas de escribir una funci\u00f3n Recursion Una funci\u00f3n que se llama a s\u00ed misma se conoce como funci\u00f3n recursiva y este proceso se llama recursividad . Cada funci\u00f3n recursiva debe tener una condici\u00f3n base que detenga la recursividad o, de lo contrario, la funci\u00f3n se llama a s\u00ed misma infinitamente. # funcion factorial (recursivo) def factorial ( x ): \"\"\" Funcion factorial de manera recursiva \"\"\" if x == 1 : return 1 else : return ( x * factorial ( x - 1 )) Analicemos recursivamente el factorial del n\u00famero \\(3\\) . num = 3 print ( f \"El factorial de { num } es { factorial ( num ) } \" ) El factorial de 3 es 6 Lambda En Python, puede definir funciones sin nombre. Estas funciones se denominan lambda o funci\u00f3n an\u00f3nima. Para crear una funci\u00f3n lambda , se utiliza la palabra clave lambda . # de manera normal def cuadrado_normal ( x ): \"\"\" Funcion que eleva al cuadrado un numero \"\"\" return x ** 2 # instanciar funcion print ( cuadrado_normal ( 5 )) 25 # funcion lambda cuadrado = lambda x : x ** 2 print ( cuadrado ( 5 )) Ocupando args & kwargs Lo primero de todo es que en realidad no tienes porque usar los nombres args o kwargs , ya que se trata de una mera convenci\u00f3n entre programadores. Definamos estos conceptos: *args : es una lista de argumentos, como argumentos posicionales. **kwargs : es un diccionario cuyas claves se convierten en par\u00e1metros y sus valores en los argumentos de los par\u00e1metros. # args def read_list_args ( * args ): for count , arg in enumerate ( args ): print ( f ' { count } - { arg } ' ) # instanciar funcion read_list_args ( 'Ricardo' , 23 , 'Ramon' , [ 1 , 2 , 3 ], 'jarroba.com' ) 0 - Ricardo 1 - 23 2 - Ramon 3 - [1, 2, 3] 4 - jarroba.com # kwargs def read_dict_args ( ** kwargs ): for key , value in kwargs . items (): print ( f ' { key } - { value } ' ) # instanciar funcion read_dict_args ( Team = 'FC Barcelona' , player = 'Iniesta' , demarcation = 'Right winger' , number = 8 ) Esto es una forma pr\u00e1ctica de trabajar, sin embargo, siempre (o en la mayor\u00eda de los casos), es mejor ser expl\u00edcito con las variables. Decoradores Python tiene una caracter\u00edstica interesante llamada decoradores para agregar funcionalidad a un c\u00f3digo existente. Esto tambi\u00e9n se llama metaprogramaci\u00f3n ya que una parte del programa intenta modificar otra parte del programa en tiempo de compilaci\u00f3n. def debug ( f ): def nueva_funcion ( a , b ): print ( \"La funcion Sumar es llamada!!!\" ) return f ( a , b ) return nueva_funcion @debug # decorador def Sumar ( a , b ): return a + b print ( Sumar ( 7 , 5 )) M\u00f3dulos Si sales del int\u00e9rprete de Python y vuelves a entrar, las definiciones que hab\u00edas hecho (funciones y variables) se pierden. Por lo tanto, si quieres escribir un programa m\u00e1s o menos largo, es mejor que utilices un editor de texto para preparar la entrada para el int\u00e9rprete y ejecutarlo con ese archivo como entrada. Esto se conoce como crear un script . A medida que tu programa crezca, quiz\u00e1s quieras separarlo en varios archivos para que el mantenimiento sea m\u00e1s sencillo. Quiz\u00e1s tambi\u00e9n quieras usar una funci\u00f3n \u00fatil que has escrito en distintos programas sin copiar su definici\u00f3n en cada programa. Un m\u00f3dulo (o biblioteca o librer\u00eda) es una colecci\u00f3n de definiciones de variables, funciones y tipos (entre otras cosas) que pueden ser importadas para ser usadas desde cualquier programa. Veamos un ejemplo, lo primero es crear y guardar nuestro m\u00f3dulo modulo_01.py . %% writefile modulo_01 . py def sumar ( a , b ): return a + b Overwriting modulo_01.py Para usar este m\u00f3dulo, usamos la palabra clave import . # importar modulo import modulo_01 # acceder a las funciones del modulo modulo_01 . sumar ( 4 , 5.5 ) 9.5 Python viene con una biblioteca de m\u00f3dulos est\u00e1ndar , descrita en un documento separado, la Referencia de la Biblioteca de Python . Algunos m\u00f3dulos se integran en el int\u00e9rprete; estos proveen acceso a operaciones que no son parte del n\u00facleo del lenguaje pero que sin embargo est\u00e1n integrados, tanto por eficiencia como para proveer acceso a primitivas del sistema operativo, como llamadas al sistema. import math resultado = math . log2 ( 5 ) # retorna logaritmo base 2 print ( resultado ) # Output: 2.321928094887362 2.321928094887362 Python tiene una tonelada de m\u00f3dulos est\u00e1ndar f\u00e1cilmente disponibles para su uso. En el siguiente link se deja la documentaci\u00f3n oficial de las librer\u00edas nativas de Python. Ejercicio Ejercicio 01 En los siglos XVII y XVIII, James Gregory y Gottfried Leibniz descubrieron una serie infinita que sirve para calcular \\(\\pi\\) : \\[\\displaystyle \\pi = 4 \\sum_{k=1}^{\\infty}\\dfrac{(-1)^{k+1}}{2k-1} = 4(1-\\dfrac{1}{3}+\\dfrac{1}{5}-\\dfrac{1}{7} + ...) \\] Desarolle un programa para estimar el valor de \\(\\pi\\) ocupando el m\u00e9todo de Leibniz, donde la entrada del programa debe ser un n\u00famero entero \\(n\\) que indique cu\u00e1ntos t\u00e9rminos de la suma se utilizar\u00e1. Ejemplo : calcular_pi(3) = 3.466666666666667, calcular_pi(1000) = 3.140592653839794 Ejercicio 02 Euler realiz\u00f3 varios aportes en relaci\u00f3n a \\(e\\) , pero no fue hasta 1748 cuando public\u00f3 su Introductio in analysin infinitorum que dio un tratamiento definitivo a las ideas sobre \\(e\\) . All\u00ed mostr\u00f3 que: En los siglos XVII y XVIII, James Gregory y Gottfried Leibniz descubrieron una serie infinita que sirve para calcular \u03c0: \\[\\displaystyle e = \\sum_{k=0}^{\\infty}\\dfrac{1}{k!} = 1+\\dfrac{1}{2!}+\\dfrac{1}{3!}+\\dfrac{1}{4!} + ... \\] Desarolle un programa para estimar el valor de \\(e\\) ocupando el m\u00e9todo de Euler, donde la entrada del programa debe ser un n\u00famero entero \\(n\\) que indique cu\u00e1ntos t\u00e9rminos de la suma se utilizar\u00e1. Ejemplo : calcular_e(3) =2.5, calcular_e(1000) = 2.7182818284590455 Ejercicio 03 Sea \\(\\sigma(n)\\) definido como la suma de los divisores propios de \\(n\\) (n\u00fameros menores que n que se dividen en \\(n\\) ). Los n\u00fameros amigos son enteros positivos \\(n_1\\) y \\(n_2\\) tales que la suma de los divisores propios de uno es igual al otro n\u00famero y viceversa, es decir, \\(\\sigma(n_1)=\\sigma(n_2)\\) y \\(\\sigma(n_2)=\\sigma(n_1)\\) . Por ejemplo, los n\u00fameros 220 y 284 son n\u00fameros amigos. * los divisores propios de 220 son 1, 2, 4, 5, 10, 11, 20, 22, 44, 55 y 110; por lo tanto \\(\\sigma(220) = 284\\) . * los divisores propios de 284 son 1, 2, 4, 71 y 142; entonces \\(\\sigma(284) = 220\\) . Implemente una funci\u00f3n llamada amigos cuyo input sean dos n\u00fameros naturales \\(n_1\\) y \\(n_2\\) , cuyo output sea verifique si los n\u00fameros son amigos o no. Ejemplo : amigos(220,284) = True, amigos(6,5) = False Ejercicio 04 La conjetura de Collatz , conocida tambi\u00e9n como conjetura \\(3n+1\\) o conjetura de Ulam (entre otros nombres), fue enunciada por el matem\u00e1tico Lothar Collatz en 1937, y a la fecha no se ha resuelto. Sea la siguiente operaci\u00f3n, aplicable a cualquier n\u00famero entero positivo: * Si el n\u00famero es par, se divide entre 2. * Si el n\u00famero es impar, se multiplica por 3 y se suma 1. La conjetura dice que siempre alcanzaremos el 1 (y por tanto el ciclo 4, 2, 1) para cualquier n\u00famero con el que comencemos. Implemente una funci\u00f3n llamada collatz cuyo input sea un n\u00famero natural positivo \\(N\\) y como output devulva la secuencia de n\u00fameros hasta llegar a 1. Ejemplo : collatz(9) = [9, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1] Ejercicio 05 La conjetura de Goldbach es uno de los problemas abiertos m\u00e1s antiguos en matem\u00e1ticas. Concretamente, G.H. Hardy, en 1921, en su famoso discurso pronunciado en la Sociedad Matem\u00e1tica de Copenhague, coment\u00f3 que probablemente la conjetura de Goldbach no es solo uno de los problemas no resueltos m\u00e1s dif\u00edciles de la teor\u00eda de n\u00fameros, sino de todas las matem\u00e1ticas. Su enunciado es el siguiente: Todo n\u00famero par mayor que 2 puede escribirse como suma de dos n\u00fameros primos - Christian Goldbach (1742) Implemente una funci\u00f3n llamada goldbach cuyo input sea un n\u00famero natural positivo \\(N\\) y como output devuelva la suma de dos primos ( \\(N1\\) y \\(N2\\) ) tal que: \\(N1+N2=N\\) . Ejemplo : goldbash(4) = (2,2), goldbash(6) = (3,3) , goldbash(8) = (3,5)","title":"Funciones"},{"location":"funciones/#funciones-y-modulos","text":"","title":"Funciones y m\u00f3dulos"},{"location":"funciones/#funciones-en-python","text":"En programaci\u00f3n, una funci\u00f3n es una secci\u00f3n de un programa que calcula un valor de manera independiente al resto del programa. Una funci\u00f3n tiene tres componentes importantes: los par\u00e1metros , que son los valores que recibe la funci\u00f3n como entrada; el c\u00f3digo de la funci\u00f3n , que son las operaciones que hace la funci\u00f3n; y el resultado (o valor de retorno), que es el valor final que entrega la funci\u00f3n. En esencia, una funci\u00f3n es un mini programa. Sus tres componentes son an\u00e1logos a la entrada, el proceso y la salida de un programa. Definici\u00f3n de funciones Las funciones en Python son creadas mediante la sentencia def : def nombre ( parametro_1 , ... , parametro_n ): \"\"\" Descripcion de la funcion (opcional) \"\"\" # c\u00f3digo de la funci\u00f3n resultado = operacion ( parametro_1 , ... , parametro_n ) return resultado # output de la funcion Los par\u00e1metros son variables en las que quedan almacenados los valores de entrada. La funci\u00f3n contiene c\u00f3digo igual al de cualquier programa. La diferencia es que, al terminar, debe entregar su resultado usando la sentencia return . Veamos algunos ejemplos: # ejemplo: funcion suma def suma ( x , y ): \"\"\" Sumar dos numeros \"\"\" resultado = x + y return resultado La funci\u00f3n creada se llama suma y cumple el objetivo de sumar dos n\u00fameros. Para instancia la funci\u00f3n, se ejecuta la siguiente sentencia: n1 = 2 n2 = 3 valor_suma = suma ( n1 , n2 ) print ( f \"El valor de la suma de { n1 } y { n2 } es { valor_suma } \" ) El valor de la suma de 2 y 3 es 5 Por otro lado, dado que no se especifica el tipo de datos, podemos sumar dos strings n1 = \"Hola \" n2 = \"Mundo\" valor_suma = suma ( n1 , n2 ) print ( f \"El valor de la suma de { n1 } y { n2 } es { valor_suma } \" ) El valor de la suma de Hola y Mundo es Hola Mundo Por lo que se debe tener cuidado tanto con el nombre de la funci\u00f3n (se espera que pueda resumir la funcion en una o dos palabras) y el tipo de argumentos que queremos que reciba. A continuaci\u00f3n, se crear\u00e1 la funci\u00f3n factorial , la cual entregar\u00e1 el factorial de un n\u00famero entero no negativo. def factorial ( n ): \"\"\" factorial de un numero entero no negativo \"\"\" f = 1 for i in range ( 1 , n + 1 ): f *= i return f En este ejemplo, el resultado que entrega una llamada a la funci\u00f3n es el valor que tiene la variable f al llegar a la \u00faltima l\u00ednea de la funci\u00f3n. Una vez creada, la funci\u00f3n puede ser usada como cualquier otra, todas las veces que sea necesario: factorial ( 0 ) 1 factorial ( 2 ) + factorial ( 5 ) 482630400 Las variables que son creadas dentro de la funci\u00f3n (incluyendo los par\u00e1metros y el resultado) se llaman variables locales , y s\u00f3lo son visibles dentro de la funci\u00f3n, no desde el resto del programa. Por otra parte, las variables creadas fuera de alguna funci\u00f3n se llaman variables globales , y son visibles desde cualquier parte del programa. Sin embargo, su valor no puede ser modificado, ya que una asignaci\u00f3n crear\u00eda una variable local del mismo nombre. # ejemplo variable global valor = 10 # variable global def funcion_01 ( x ): return valor * x # ejemplo variable local def funcion_02 ( x , valor ): return valor * x Nota : Dependiendo del uso que le d\u00e9 a su c\u00f3digo es que ocupar\u00e1 variables globales o no, sin embargo, es preferible definir su funci\u00f3n solo con variables locales , puesto que esto deja expl\u00edcita la dependencia de dicha variable dentro de su funci\u00f3n objetivo. Por otro lado, existen funciones que no necesariamente reciben argumentos. def imprimir_pantalla (): return \"Mensaje random\" imprimir_pantalla () 'Mensaje random' Tambi\u00e9n, existen funciones que no retornan valores : def imprimir_nombre ( nombre ): print ( nombre ) imprimir_nombre ( \"nombre_01\" ) nombre_01","title":"Funciones en python"},{"location":"funciones/#formas-de-escribir-una-funcion","text":"","title":"Formas de escribir una funci\u00f3n"},{"location":"funciones/#recursion","text":"Una funci\u00f3n que se llama a s\u00ed misma se conoce como funci\u00f3n recursiva y este proceso se llama recursividad . Cada funci\u00f3n recursiva debe tener una condici\u00f3n base que detenga la recursividad o, de lo contrario, la funci\u00f3n se llama a s\u00ed misma infinitamente. # funcion factorial (recursivo) def factorial ( x ): \"\"\" Funcion factorial de manera recursiva \"\"\" if x == 1 : return 1 else : return ( x * factorial ( x - 1 )) Analicemos recursivamente el factorial del n\u00famero \\(3\\) . num = 3 print ( f \"El factorial de { num } es { factorial ( num ) } \" ) El factorial de 3 es 6","title":"Recursion"},{"location":"funciones/#lambda","text":"En Python, puede definir funciones sin nombre. Estas funciones se denominan lambda o funci\u00f3n an\u00f3nima. Para crear una funci\u00f3n lambda , se utiliza la palabra clave lambda . # de manera normal def cuadrado_normal ( x ): \"\"\" Funcion que eleva al cuadrado un numero \"\"\" return x ** 2 # instanciar funcion print ( cuadrado_normal ( 5 )) 25 # funcion lambda cuadrado = lambda x : x ** 2 print ( cuadrado ( 5 ))","title":"Lambda"},{"location":"funciones/#ocupando-args-kwargs","text":"Lo primero de todo es que en realidad no tienes porque usar los nombres args o kwargs , ya que se trata de una mera convenci\u00f3n entre programadores. Definamos estos conceptos: *args : es una lista de argumentos, como argumentos posicionales. **kwargs : es un diccionario cuyas claves se convierten en par\u00e1metros y sus valores en los argumentos de los par\u00e1metros. # args def read_list_args ( * args ): for count , arg in enumerate ( args ): print ( f ' { count } - { arg } ' ) # instanciar funcion read_list_args ( 'Ricardo' , 23 , 'Ramon' , [ 1 , 2 , 3 ], 'jarroba.com' ) 0 - Ricardo 1 - 23 2 - Ramon 3 - [1, 2, 3] 4 - jarroba.com # kwargs def read_dict_args ( ** kwargs ): for key , value in kwargs . items (): print ( f ' { key } - { value } ' ) # instanciar funcion read_dict_args ( Team = 'FC Barcelona' , player = 'Iniesta' , demarcation = 'Right winger' , number = 8 ) Esto es una forma pr\u00e1ctica de trabajar, sin embargo, siempre (o en la mayor\u00eda de los casos), es mejor ser expl\u00edcito con las variables.","title":"Ocupando args  &amp; kwargs"},{"location":"funciones/#decoradores","text":"Python tiene una caracter\u00edstica interesante llamada decoradores para agregar funcionalidad a un c\u00f3digo existente. Esto tambi\u00e9n se llama metaprogramaci\u00f3n ya que una parte del programa intenta modificar otra parte del programa en tiempo de compilaci\u00f3n. def debug ( f ): def nueva_funcion ( a , b ): print ( \"La funcion Sumar es llamada!!!\" ) return f ( a , b ) return nueva_funcion @debug # decorador def Sumar ( a , b ): return a + b print ( Sumar ( 7 , 5 ))","title":"Decoradores"},{"location":"funciones/#modulos","text":"Si sales del int\u00e9rprete de Python y vuelves a entrar, las definiciones que hab\u00edas hecho (funciones y variables) se pierden. Por lo tanto, si quieres escribir un programa m\u00e1s o menos largo, es mejor que utilices un editor de texto para preparar la entrada para el int\u00e9rprete y ejecutarlo con ese archivo como entrada. Esto se conoce como crear un script . A medida que tu programa crezca, quiz\u00e1s quieras separarlo en varios archivos para que el mantenimiento sea m\u00e1s sencillo. Quiz\u00e1s tambi\u00e9n quieras usar una funci\u00f3n \u00fatil que has escrito en distintos programas sin copiar su definici\u00f3n en cada programa. Un m\u00f3dulo (o biblioteca o librer\u00eda) es una colecci\u00f3n de definiciones de variables, funciones y tipos (entre otras cosas) que pueden ser importadas para ser usadas desde cualquier programa. Veamos un ejemplo, lo primero es crear y guardar nuestro m\u00f3dulo modulo_01.py . %% writefile modulo_01 . py def sumar ( a , b ): return a + b Overwriting modulo_01.py Para usar este m\u00f3dulo, usamos la palabra clave import . # importar modulo import modulo_01 # acceder a las funciones del modulo modulo_01 . sumar ( 4 , 5.5 ) 9.5 Python viene con una biblioteca de m\u00f3dulos est\u00e1ndar , descrita en un documento separado, la Referencia de la Biblioteca de Python . Algunos m\u00f3dulos se integran en el int\u00e9rprete; estos proveen acceso a operaciones que no son parte del n\u00facleo del lenguaje pero que sin embargo est\u00e1n integrados, tanto por eficiencia como para proveer acceso a primitivas del sistema operativo, como llamadas al sistema. import math resultado = math . log2 ( 5 ) # retorna logaritmo base 2 print ( resultado ) # Output: 2.321928094887362 2.321928094887362 Python tiene una tonelada de m\u00f3dulos est\u00e1ndar f\u00e1cilmente disponibles para su uso. En el siguiente link se deja la documentaci\u00f3n oficial de las librer\u00edas nativas de Python.","title":"M\u00f3dulos"},{"location":"funciones/#ejercicio","text":"","title":"Ejercicio"},{"location":"funciones/#ejercicio-01","text":"En los siglos XVII y XVIII, James Gregory y Gottfried Leibniz descubrieron una serie infinita que sirve para calcular \\(\\pi\\) : \\[\\displaystyle \\pi = 4 \\sum_{k=1}^{\\infty}\\dfrac{(-1)^{k+1}}{2k-1} = 4(1-\\dfrac{1}{3}+\\dfrac{1}{5}-\\dfrac{1}{7} + ...) \\] Desarolle un programa para estimar el valor de \\(\\pi\\) ocupando el m\u00e9todo de Leibniz, donde la entrada del programa debe ser un n\u00famero entero \\(n\\) que indique cu\u00e1ntos t\u00e9rminos de la suma se utilizar\u00e1. Ejemplo : calcular_pi(3) = 3.466666666666667, calcular_pi(1000) = 3.140592653839794","title":"Ejercicio 01"},{"location":"funciones/#ejercicio-02","text":"Euler realiz\u00f3 varios aportes en relaci\u00f3n a \\(e\\) , pero no fue hasta 1748 cuando public\u00f3 su Introductio in analysin infinitorum que dio un tratamiento definitivo a las ideas sobre \\(e\\) . All\u00ed mostr\u00f3 que: En los siglos XVII y XVIII, James Gregory y Gottfried Leibniz descubrieron una serie infinita que sirve para calcular \u03c0: \\[\\displaystyle e = \\sum_{k=0}^{\\infty}\\dfrac{1}{k!} = 1+\\dfrac{1}{2!}+\\dfrac{1}{3!}+\\dfrac{1}{4!} + ... \\] Desarolle un programa para estimar el valor de \\(e\\) ocupando el m\u00e9todo de Euler, donde la entrada del programa debe ser un n\u00famero entero \\(n\\) que indique cu\u00e1ntos t\u00e9rminos de la suma se utilizar\u00e1. Ejemplo : calcular_e(3) =2.5, calcular_e(1000) = 2.7182818284590455","title":"Ejercicio 02"},{"location":"funciones/#ejercicio-03","text":"Sea \\(\\sigma(n)\\) definido como la suma de los divisores propios de \\(n\\) (n\u00fameros menores que n que se dividen en \\(n\\) ). Los n\u00fameros amigos son enteros positivos \\(n_1\\) y \\(n_2\\) tales que la suma de los divisores propios de uno es igual al otro n\u00famero y viceversa, es decir, \\(\\sigma(n_1)=\\sigma(n_2)\\) y \\(\\sigma(n_2)=\\sigma(n_1)\\) . Por ejemplo, los n\u00fameros 220 y 284 son n\u00fameros amigos. * los divisores propios de 220 son 1, 2, 4, 5, 10, 11, 20, 22, 44, 55 y 110; por lo tanto \\(\\sigma(220) = 284\\) . * los divisores propios de 284 son 1, 2, 4, 71 y 142; entonces \\(\\sigma(284) = 220\\) . Implemente una funci\u00f3n llamada amigos cuyo input sean dos n\u00fameros naturales \\(n_1\\) y \\(n_2\\) , cuyo output sea verifique si los n\u00fameros son amigos o no. Ejemplo : amigos(220,284) = True, amigos(6,5) = False","title":"Ejercicio 03"},{"location":"funciones/#ejercicio-04","text":"La conjetura de Collatz , conocida tambi\u00e9n como conjetura \\(3n+1\\) o conjetura de Ulam (entre otros nombres), fue enunciada por el matem\u00e1tico Lothar Collatz en 1937, y a la fecha no se ha resuelto. Sea la siguiente operaci\u00f3n, aplicable a cualquier n\u00famero entero positivo: * Si el n\u00famero es par, se divide entre 2. * Si el n\u00famero es impar, se multiplica por 3 y se suma 1. La conjetura dice que siempre alcanzaremos el 1 (y por tanto el ciclo 4, 2, 1) para cualquier n\u00famero con el que comencemos. Implemente una funci\u00f3n llamada collatz cuyo input sea un n\u00famero natural positivo \\(N\\) y como output devulva la secuencia de n\u00fameros hasta llegar a 1. Ejemplo : collatz(9) = [9, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]","title":"Ejercicio 04"},{"location":"funciones/#ejercicio-05","text":"La conjetura de Goldbach es uno de los problemas abiertos m\u00e1s antiguos en matem\u00e1ticas. Concretamente, G.H. Hardy, en 1921, en su famoso discurso pronunciado en la Sociedad Matem\u00e1tica de Copenhague, coment\u00f3 que probablemente la conjetura de Goldbach no es solo uno de los problemas no resueltos m\u00e1s dif\u00edciles de la teor\u00eda de n\u00fameros, sino de todas las matem\u00e1ticas. Su enunciado es el siguiente: Todo n\u00famero par mayor que 2 puede escribirse como suma de dos n\u00fameros primos - Christian Goldbach (1742) Implemente una funci\u00f3n llamada goldbach cuyo input sea un n\u00famero natural positivo \\(N\\) y como output devuelva la suma de dos primos ( \\(N1\\) y \\(N2\\) ) tal que: \\(N1+N2=N\\) . Ejemplo : goldbash(4) = (2,2), goldbash(6) = (3,3) , goldbash(8) = (3,5)","title":"Ejercicio 05"},{"location":"intro_progra/","text":"Programaci\u00f3n Se suele decir que una persona no entiende algo de verdad hasta que puede explic\u00e1rselo a otro. En realidad, no lo entiende de verdad hasta que puede explic\u00e1rselo a un computador`. \u2014 Donald Knuth . Si tuvieramos que resumir el prop\u00f3sito de la programaci\u00f3n en una frase, \u00e9sta deber\u00eda ser: que el computador haga el trabajo por nosotros. Los computadores son buenos para hacer tareas rutinarias. Idealmente, cualquier problema tedioso y repetitivo deber\u00eda ser resuelto por un computador, y los seres humanos s\u00f3lo deber\u00edamos encargarnos de los problemas realmente interesantes: los que requieren creatividad, pensamiento cr\u00edtico y subjetividad. La programaci\u00f3n es el proceso de transformar un m\u00e9todo para resolver problemas en uno que pueda ser entendido por el computador. Algoritmos La inform\u00e1tica se trata de computadores tanto como la astronom\u00eda se trata de telescopios. \u2014 Edsger Dijkstra . Al dise\u00f1ar un programa, el desaf\u00edo principal es crear y describir un procedimiento que est\u00e9 completamente bien definido, que no tenga ambig\u00fcedades, y que efectivamente resuelva el problema. As\u00ed es como la programaci\u00f3n no es tanto sobre computadores, sino sobre resolver problemas de manera estructurada. El objeto de estudio de la programaci\u00f3n no son los programas, sino los algoritmos. Un algoritmo es un procedimiento bien definido para resolver un problema. Todo el mundo conoce y utiliza algoritmos a diario, incluso sin darse cuenta: a) Una receta Una receta de cocina es un algoritmo; si bien podr\u00edamos cuestionar que algunos pasos son ambiguos (\u00bfcu\u00e1nto es \u00abuna pizca de sal\u00bb? \u00bfqu\u00e9 significa \u00abagregar a gusto\u00bb?), en general las instrucciones est\u00e1n lo suficientemente bien definidas para que uno las pueda seguir sin problemas. La entrada de una receta son los ingredientes y algunos datos como: \u00bfpara cu\u00e1ntas personas se cocinar\u00e1? El proceso es la serie de pasos para manipular los ingredientes. La salida es el plato terminado. En principio, si una receta est\u00e1 suficientemente bien explicada, podr\u00eda permitir preparar un plato a alguien que no sepa nada de cocina. b) M\u00e9todo de multiplicar El m\u00e9todo para multiplicar n\u00fameros a mano que aprendimos en el colegio es un algoritmo. Dado cualquier par de n\u00fameros enteros, si seguimos paso a paso el procedimiento siempre obtendremos el producto: La entrada del algoritmo de multiplicaci\u00f3n son los dos factores. El proceso es la secuencia de pasos en que los d\u00edgitos van siendo multiplicados las reservas van siendo sumadas, y los productos intermedios son finalmente sumados. La salida del algoritmo es el producto obtenido. Componentes de un algoritmo Conceptualmente, un algoritmo tiene tres componentes: entrada : son los datos sobre los que el algoritmo opera; proceso : son los pasos que hay que seguir, utilizando la entrada; salida : es el resultado que entrega el algoritmo. El proceso es una secuencia de sentencias, que debe ser realizada en orden. El proceso tambi\u00e9n puede tener ciclos (grupos de sentencias que son ejecutadas varias veces) y condicionales (grupos de sentencias que s\u00f3lo son ejecutadas bajo ciertas condiciones). C\u00f3mo describir un algoritmo Consideremos un ejemplo sencillo: un algoritmo para resolver ecuaciones cuadr\u00e1ticas. Una ecuaci\u00f3n cuadr\u00e1tica es una ecuaci\u00f3n de la forma \\(ax^2+bx+c=0\\) , donde \\(a, b\\) y \\(c\\) son datos dados, con \\(a\\neq0\\) , y \\(x\\) es la inc\u00f3gnita cuyo valor que se desea determinar. Por ejemplo, \\(2x^2\u22125x+2=0\\) es una ecuaci\u00f3n cuadr\u00e1tica con \\(a=2\\) , \\(b=\u22125\\) y \\(c=2\\) . Sus soluciones son \\(x_1=1/2\\) y \\(x_2=2\\) , como se puede comprobar f\u00e1cilmente al reemplazar estos valores en la ecuaci\u00f3n. El problema es c\u00f3mo obtener estos valores en primer lugar. El problema computacional de resolver una ecuaci\u00f3n cuadr\u00e1tica puede ser planteado as\u00ed: Dados \\(a, b\\) y \\(c\\) , entontrar los valores reales de \\(x\\) que satisfacen \\(ax^2+bx+c=0\\) . La entrada del algoritmo, pues, son los valores \\(a, b\\) y \\(c\\) , y la salida son las ra\u00edces reales \\(x\\) (que pueden ser cero, una o dos) de la ecuaci\u00f3n. En un programa computacional, los valores de \\(a, b\\) y \\(c\\) deber\u00edan ser ingresados usando el teclado, y las soluciones \\(x\\) deber\u00edan ser mostradas a continuaci\u00f3n en la pantalla. Al estudiar \u00e1lgebra aprendemos un algoritmo para resolver este problema. Es lo suficientemente detallado para que pueda usarlo cualquier persona, incluso sin saber qu\u00e9 es una ecuaci\u00f3n cuadr\u00e1tica, o para que lo pueda hacer un computador. A continuaci\u00f3n veremos algunas maneras de describir el procedimiento. Lenguaje natural Durante el proceso mental de dise\u00f1ar un algoritmo, es com\u00fan pensar y describir los pasos en la misma manera en que hablamos a diario. Por ejemplo: Teniendo los valores de \\(a, b\\) y \\(c\\) , calcular el discriminante \\(D=b^2\u22124ac\\) . Si es discriminante es negativo, entonces la ecuaci\u00f3n no tiene soluciones reales. Si es discriminante es igual a cero, entonces la ecuaci\u00f3n tiene una \u00fanica soluci\u00f3n real, que es \\(x=\u2212b/2a\\) . Si el discriminante es positivo, entonces la ecuaci\u00f3n tiene dos soluciones reales, que son \\(x_1=(\u2212b\u2212\\sqrt{D})/2a\\) y \\(x_2=(\u2212b+\\sqrt{D})/2a\\) . Esta manera de expresar un algoritmo no es ideal, ya que el lenguaje natural es: impreciso : puede tener ambig\u00fcedades; no universal : personas distintas describir\u00e1n el proceso de maneras distintas; y no estructurado : la descripci\u00f3n no est\u00e1 expresada en funci\u00f3n de componentes simples. A\u00fan as\u00ed, es posible identificar los pasos del algoritmo. Por ejemplo, hay que evaluar la expresi\u00f3n \\(b^2\u22124ac\\) , y ponerle el nombre \\(D\\) a su resultado. Esto se llama asignaci\u00f3n, y es un tipo de instrucci\u00f3n que aparece en casi todos los algoritmos. Despu\u00e9s de eso, el algoritmo puede usar el nombre \\(D\\) para referirse al valor calculado. Diagrama de flujo Un diagrama de flujo es una representaci\u00f3n gr\u00e1fica de un algoritmo. Los pasos son representados por varios tipos de bloques, y el flujo de ejecuci\u00f3n es indicado por flechas que conectan los bloques: El inicio y el final del algoritmo son representados con bloques circulares. El algoritmo siempre debe ser capaz llegar desde uno hasta el otro, sin importar por qu\u00e9 camino lo hace. Un algoritmo no puede \u00abquedarse pegado\u00bb en la mitad. La entrada y la salida de datos son representadas con romboides, que en la figura de arriba est\u00e1n pintados de verde. Los diamantes representan condiciones en las que el algoritmo sigue uno de dos caminos. que est\u00e1n etiquetados con s\u00ed o no, dependiendo si la condici\u00f3n es verdadera o falsa. Tambi\u00e9n puede haber ciclos, representados por flechas que regresan a bloques anteriores. En este ejemplo, no hay ciclos. Otras sentencias van dentro de rect\u00e1ngulos, que en la figura est\u00e1n pintados de azul. En este ejemplo, las sentencias son asignaciones, representadas en la forma nombre = valor . Los diagramas de flujo no son usados en la pr\u00e1ctica para programar, pero son \u00fatiles para ilustrar c\u00f3mo funcionan algoritmos sencillos. Pseudoc\u00f3digo El pseudoc\u00f3digo es una descripci\u00f3n estructurada de un algoritmo basada en ciertas convenciones notacionales. Si bien es muy parecido al c\u00f3digo que finalmente se escribir\u00e1 en el computador, el pseudoc\u00f3digo est\u00e1 pensado para ser le\u00eddo por humanos. Una manera de escribir el algoritmo para la ecuaci\u00f3n cuadr\u00e1tica en pseudoc\u00f3digo es la siguiente: leer a leer b leer c discriminante = b\u00b2 - 4ac si discriminante < 0: escribir 'La ecuaci\u00f3n no tiene soluciones reales' o si no, si discriminante = 0: x = -b / 2a escribir 'La soluci\u00f3n \u00fanica es', x o si no: x1 = (-b - \u221adiscriminante) / 2a x2 = (-b + \u221adiscriminante) / 2a escribir 'Las dos soluciones reales son:' escribir x1 escribir x2 Las l\u00edneas que comienzan con leer y escribir denotan, respectivamente, la entrada y la salida del programa. Los diferentes casos son representados usando sentencias si y o si no . Las asignaciones siguen la misma notaci\u00f3n que en el caso de los diagramas de flujo. La notaci\u00f3n de pseudoc\u00f3digo es bien liberal. Uno puede mezclar notaci\u00f3n de matem\u00e1ticas con frases en espa\u00f1ol, siempre que quede absolutamente claro para el lector qu\u00e9 representa cada una de las l\u00edneas del algoritmo. C\u00f3digo El producto final de la programaci\u00f3n siempre debe ser c\u00f3digo que pueda ser ejecutado en el computador. Esto requiere describir los algoritmos en un lenguaje de programaci\u00f3n. Los lenguajes de programaci\u00f3n definen un conjunto limitado de conceptos b\u00e1sicos, en funci\u00f3n de los cuales uno puede expresar cualquier algoritmo. En esta asignatura, usaremos el lenguaje de programaci\u00f3n Python para escribir nuestros programas. El c\u00f3digo en Python para resolver la ecuaci\u00f3n cuadr\u00e1tica es el siguiente: a = float(raw_input('Ingrese a: ')) b = float(raw_input('Ingrese b: ')) c = float(raw_input('Ingrese c: ')) discriminante = b ** 2 - 4 * a * c if discriminante < 0: print 'La ecuacion no tiene soluciones reales' elif discriminante == 0: x = -b / (2 * a) print 'La solucion unica es x =', x else: x1 = (-b - (discriminante ** 0.5)) / (2 * a) x2 = (-b + (discriminante ** 0.5)) / (2 * a) print 'Las dos soluciones reales son:' print 'x1 =', x1 print 'x2 =', x2 raw_input() A partir de ahora, usted aprender\u00e1 a entender, escribir y ejecutar c\u00f3digos como \u00e9ste.","title":"Programaci\u00f3n"},{"location":"intro_progra/#programacion","text":"Se suele decir que una persona no entiende algo de verdad hasta que puede explic\u00e1rselo a otro. En realidad, no lo entiende de verdad hasta que puede explic\u00e1rselo a un computador`. \u2014 Donald Knuth . Si tuvieramos que resumir el prop\u00f3sito de la programaci\u00f3n en una frase, \u00e9sta deber\u00eda ser: que el computador haga el trabajo por nosotros. Los computadores son buenos para hacer tareas rutinarias. Idealmente, cualquier problema tedioso y repetitivo deber\u00eda ser resuelto por un computador, y los seres humanos s\u00f3lo deber\u00edamos encargarnos de los problemas realmente interesantes: los que requieren creatividad, pensamiento cr\u00edtico y subjetividad. La programaci\u00f3n es el proceso de transformar un m\u00e9todo para resolver problemas en uno que pueda ser entendido por el computador.","title":"Programaci\u00f3n"},{"location":"intro_progra/#algoritmos","text":"La inform\u00e1tica se trata de computadores tanto como la astronom\u00eda se trata de telescopios. \u2014 Edsger Dijkstra . Al dise\u00f1ar un programa, el desaf\u00edo principal es crear y describir un procedimiento que est\u00e9 completamente bien definido, que no tenga ambig\u00fcedades, y que efectivamente resuelva el problema. As\u00ed es como la programaci\u00f3n no es tanto sobre computadores, sino sobre resolver problemas de manera estructurada. El objeto de estudio de la programaci\u00f3n no son los programas, sino los algoritmos. Un algoritmo es un procedimiento bien definido para resolver un problema. Todo el mundo conoce y utiliza algoritmos a diario, incluso sin darse cuenta: a) Una receta Una receta de cocina es un algoritmo; si bien podr\u00edamos cuestionar que algunos pasos son ambiguos (\u00bfcu\u00e1nto es \u00abuna pizca de sal\u00bb? \u00bfqu\u00e9 significa \u00abagregar a gusto\u00bb?), en general las instrucciones est\u00e1n lo suficientemente bien definidas para que uno las pueda seguir sin problemas. La entrada de una receta son los ingredientes y algunos datos como: \u00bfpara cu\u00e1ntas personas se cocinar\u00e1? El proceso es la serie de pasos para manipular los ingredientes. La salida es el plato terminado. En principio, si una receta est\u00e1 suficientemente bien explicada, podr\u00eda permitir preparar un plato a alguien que no sepa nada de cocina. b) M\u00e9todo de multiplicar El m\u00e9todo para multiplicar n\u00fameros a mano que aprendimos en el colegio es un algoritmo. Dado cualquier par de n\u00fameros enteros, si seguimos paso a paso el procedimiento siempre obtendremos el producto: La entrada del algoritmo de multiplicaci\u00f3n son los dos factores. El proceso es la secuencia de pasos en que los d\u00edgitos van siendo multiplicados las reservas van siendo sumadas, y los productos intermedios son finalmente sumados. La salida del algoritmo es el producto obtenido.","title":"Algoritmos"},{"location":"intro_progra/#componentes-de-un-algoritmo","text":"Conceptualmente, un algoritmo tiene tres componentes: entrada : son los datos sobre los que el algoritmo opera; proceso : son los pasos que hay que seguir, utilizando la entrada; salida : es el resultado que entrega el algoritmo. El proceso es una secuencia de sentencias, que debe ser realizada en orden. El proceso tambi\u00e9n puede tener ciclos (grupos de sentencias que son ejecutadas varias veces) y condicionales (grupos de sentencias que s\u00f3lo son ejecutadas bajo ciertas condiciones).","title":"Componentes de un algoritmo"},{"location":"intro_progra/#como-describir-un-algoritmo","text":"Consideremos un ejemplo sencillo: un algoritmo para resolver ecuaciones cuadr\u00e1ticas. Una ecuaci\u00f3n cuadr\u00e1tica es una ecuaci\u00f3n de la forma \\(ax^2+bx+c=0\\) , donde \\(a, b\\) y \\(c\\) son datos dados, con \\(a\\neq0\\) , y \\(x\\) es la inc\u00f3gnita cuyo valor que se desea determinar. Por ejemplo, \\(2x^2\u22125x+2=0\\) es una ecuaci\u00f3n cuadr\u00e1tica con \\(a=2\\) , \\(b=\u22125\\) y \\(c=2\\) . Sus soluciones son \\(x_1=1/2\\) y \\(x_2=2\\) , como se puede comprobar f\u00e1cilmente al reemplazar estos valores en la ecuaci\u00f3n. El problema es c\u00f3mo obtener estos valores en primer lugar. El problema computacional de resolver una ecuaci\u00f3n cuadr\u00e1tica puede ser planteado as\u00ed: Dados \\(a, b\\) y \\(c\\) , entontrar los valores reales de \\(x\\) que satisfacen \\(ax^2+bx+c=0\\) . La entrada del algoritmo, pues, son los valores \\(a, b\\) y \\(c\\) , y la salida son las ra\u00edces reales \\(x\\) (que pueden ser cero, una o dos) de la ecuaci\u00f3n. En un programa computacional, los valores de \\(a, b\\) y \\(c\\) deber\u00edan ser ingresados usando el teclado, y las soluciones \\(x\\) deber\u00edan ser mostradas a continuaci\u00f3n en la pantalla. Al estudiar \u00e1lgebra aprendemos un algoritmo para resolver este problema. Es lo suficientemente detallado para que pueda usarlo cualquier persona, incluso sin saber qu\u00e9 es una ecuaci\u00f3n cuadr\u00e1tica, o para que lo pueda hacer un computador. A continuaci\u00f3n veremos algunas maneras de describir el procedimiento. Lenguaje natural Durante el proceso mental de dise\u00f1ar un algoritmo, es com\u00fan pensar y describir los pasos en la misma manera en que hablamos a diario. Por ejemplo: Teniendo los valores de \\(a, b\\) y \\(c\\) , calcular el discriminante \\(D=b^2\u22124ac\\) . Si es discriminante es negativo, entonces la ecuaci\u00f3n no tiene soluciones reales. Si es discriminante es igual a cero, entonces la ecuaci\u00f3n tiene una \u00fanica soluci\u00f3n real, que es \\(x=\u2212b/2a\\) . Si el discriminante es positivo, entonces la ecuaci\u00f3n tiene dos soluciones reales, que son \\(x_1=(\u2212b\u2212\\sqrt{D})/2a\\) y \\(x_2=(\u2212b+\\sqrt{D})/2a\\) . Esta manera de expresar un algoritmo no es ideal, ya que el lenguaje natural es: impreciso : puede tener ambig\u00fcedades; no universal : personas distintas describir\u00e1n el proceso de maneras distintas; y no estructurado : la descripci\u00f3n no est\u00e1 expresada en funci\u00f3n de componentes simples. A\u00fan as\u00ed, es posible identificar los pasos del algoritmo. Por ejemplo, hay que evaluar la expresi\u00f3n \\(b^2\u22124ac\\) , y ponerle el nombre \\(D\\) a su resultado. Esto se llama asignaci\u00f3n, y es un tipo de instrucci\u00f3n que aparece en casi todos los algoritmos. Despu\u00e9s de eso, el algoritmo puede usar el nombre \\(D\\) para referirse al valor calculado. Diagrama de flujo Un diagrama de flujo es una representaci\u00f3n gr\u00e1fica de un algoritmo. Los pasos son representados por varios tipos de bloques, y el flujo de ejecuci\u00f3n es indicado por flechas que conectan los bloques: El inicio y el final del algoritmo son representados con bloques circulares. El algoritmo siempre debe ser capaz llegar desde uno hasta el otro, sin importar por qu\u00e9 camino lo hace. Un algoritmo no puede \u00abquedarse pegado\u00bb en la mitad. La entrada y la salida de datos son representadas con romboides, que en la figura de arriba est\u00e1n pintados de verde. Los diamantes representan condiciones en las que el algoritmo sigue uno de dos caminos. que est\u00e1n etiquetados con s\u00ed o no, dependiendo si la condici\u00f3n es verdadera o falsa. Tambi\u00e9n puede haber ciclos, representados por flechas que regresan a bloques anteriores. En este ejemplo, no hay ciclos. Otras sentencias van dentro de rect\u00e1ngulos, que en la figura est\u00e1n pintados de azul. En este ejemplo, las sentencias son asignaciones, representadas en la forma nombre = valor . Los diagramas de flujo no son usados en la pr\u00e1ctica para programar, pero son \u00fatiles para ilustrar c\u00f3mo funcionan algoritmos sencillos. Pseudoc\u00f3digo El pseudoc\u00f3digo es una descripci\u00f3n estructurada de un algoritmo basada en ciertas convenciones notacionales. Si bien es muy parecido al c\u00f3digo que finalmente se escribir\u00e1 en el computador, el pseudoc\u00f3digo est\u00e1 pensado para ser le\u00eddo por humanos. Una manera de escribir el algoritmo para la ecuaci\u00f3n cuadr\u00e1tica en pseudoc\u00f3digo es la siguiente: leer a leer b leer c discriminante = b\u00b2 - 4ac si discriminante < 0: escribir 'La ecuaci\u00f3n no tiene soluciones reales' o si no, si discriminante = 0: x = -b / 2a escribir 'La soluci\u00f3n \u00fanica es', x o si no: x1 = (-b - \u221adiscriminante) / 2a x2 = (-b + \u221adiscriminante) / 2a escribir 'Las dos soluciones reales son:' escribir x1 escribir x2 Las l\u00edneas que comienzan con leer y escribir denotan, respectivamente, la entrada y la salida del programa. Los diferentes casos son representados usando sentencias si y o si no . Las asignaciones siguen la misma notaci\u00f3n que en el caso de los diagramas de flujo. La notaci\u00f3n de pseudoc\u00f3digo es bien liberal. Uno puede mezclar notaci\u00f3n de matem\u00e1ticas con frases en espa\u00f1ol, siempre que quede absolutamente claro para el lector qu\u00e9 representa cada una de las l\u00edneas del algoritmo. C\u00f3digo El producto final de la programaci\u00f3n siempre debe ser c\u00f3digo que pueda ser ejecutado en el computador. Esto requiere describir los algoritmos en un lenguaje de programaci\u00f3n. Los lenguajes de programaci\u00f3n definen un conjunto limitado de conceptos b\u00e1sicos, en funci\u00f3n de los cuales uno puede expresar cualquier algoritmo. En esta asignatura, usaremos el lenguaje de programaci\u00f3n Python para escribir nuestros programas. El c\u00f3digo en Python para resolver la ecuaci\u00f3n cuadr\u00e1tica es el siguiente: a = float(raw_input('Ingrese a: ')) b = float(raw_input('Ingrese b: ')) c = float(raw_input('Ingrese c: ')) discriminante = b ** 2 - 4 * a * c if discriminante < 0: print 'La ecuacion no tiene soluciones reales' elif discriminante == 0: x = -b / (2 * a) print 'La solucion unica es x =', x else: x1 = (-b - (discriminante ** 0.5)) / (2 * a) x2 = (-b + (discriminante ** 0.5)) / (2 * a) print 'Las dos soluciones reales son:' print 'x1 =', x1 print 'x2 =', x2 raw_input() A partir de ahora, usted aprender\u00e1 a entender, escribir y ejecutar c\u00f3digos como \u00e9ste.","title":"C\u00f3mo describir un algoritmo"},{"location":"introduccion/","text":"Motivaci\u00f3n Python es un lenguaje de programaci\u00f3n interpretado, cuya filosof\u00eda hace hincapi\u00e9 en una sintaxis muy limpia y un c\u00f3digo legible. Aqu\u00ed les presento una lista de razones para aprender Python. C\u00f3digo abierto Multiparadigma y Multiplataforma Versatilidad a la hora de programar Sintaxis amigable Popularidad Desde 2012, Python ha crecido constantemente en popularidad, y es probable que la tendencia contin\u00fae, si no aumenta, en el futuro. Seg\u00fan Stack Overflow Developer Survey 2018 . La demanda y el soporte para Python tambi\u00e9n est\u00e1n en aumento, y si se cree en las proyecciones, Python superar\u00e1 a Java en los pr\u00f3ximos a\u00f1os y reclamar\u00e1 el primer puesto. \u00bfEs buena la popularidad de Python? En general, lo que es popular no siempre es lo mejor, en el caso de los lenguajes de programaci\u00f3n, la popularidad vale la pena. Gracias a la popularidad de Python, es probable que encuentre una soluci\u00f3n preparada para cualquier problema que pueda estar experimentando. La comunidad de entusiastas de Python es fuerte y est\u00e1n trabajando incansablemente para mejorar el lenguaje todos los d\u00edas. Python tambi\u00e9n tiene una serie de patrocinadores corporativos, presionando para popularizar a\u00fan m\u00e1s el lenguaje. Entre ellos se encuentran gigantes tecnol\u00f3gicos como Google , que est\u00e1 utilizando Python. Librer\u00edas y frameworks Una gran ventaja de Python es la amplia selecci\u00f3n de librer\u00edas y frameworks que ofrece. Hay librer\u00edas para distintos t\u00f3picos: Manipulaci\u00f3n de datos Visualizaci\u00f3n de datos Aprendizaje autom\u00e1tico Ciencia de los datos Procesamiento natural del lenguaje Big Data Lo mismo es cierto para los frameworks , que ayudan a despegar su proyecto y le ahorran tiempo y esfuerzo. Hay una variedad de marcos para elegir, dependiendo de sus necesidades, por ejemplo, para el desarrollo web tenemos: Django Flask FastApi Performance Una de las mayores cr\u00edticas de Python es el tiempo de ejecuci\u00f3n, relativamente lento en comparaci\u00f3n con otros lenguajes. Sin embargo, hay una soluci\u00f3n alternativa a este desaf\u00edo espec\u00edfico. Cuando el rendimiento tiene prioridad, Python le brinda la capacidad de integrar otros lenguajes de mayor rendimiento en su c\u00f3digo. Cython es un buen ejemplo de tal soluci\u00f3n. Optimiza su velocidad sin obligarlo a reescribir todo su c\u00f3digo base desde cero. El recurso m\u00e1s caro no es el tiempo de CPU, sino el tiempo de tus desarrolladores. Por lo tanto, reducir el tiempo de comercializaci\u00f3n siempre debe tener prioridad sobre la ejecuci\u00f3n r\u00e1pida del tiempo de ejecuci\u00f3n. Adem\u00e1s, Python tiene una sintaxis clara y no requiere tantas l\u00edneas de c\u00f3digo como Java o C para obtener resultados comparables. \u00bfCu\u00e1les son los beneficios de la alta legibilidad de Python? La simplicidad de Python es particularmente \u00fatil para leer el c\u00f3digo, el suyo o el de otra persona. Debido a que el c\u00f3digo Python tiene menos l\u00edneas e imita el ingl\u00e9s, revisarlo lleva mucho menos tiempo. Este es un gran beneficio. Reducir el tiempo que necesita dedicar a la revisi\u00f3n de c\u00f3digo es invaluable, ya que la productividad de sus desarrolladores debe ser su m\u00e1xima prioridad. Referencia Introducci\u00f3n al lenguaje Python Introducci\u00f3n \u2014 Tutorial de Python 3.6.3 documentation","title":"Motivaci\u00f3n"},{"location":"introduccion/#motivacion","text":"Python es un lenguaje de programaci\u00f3n interpretado, cuya filosof\u00eda hace hincapi\u00e9 en una sintaxis muy limpia y un c\u00f3digo legible. Aqu\u00ed les presento una lista de razones para aprender Python. C\u00f3digo abierto Multiparadigma y Multiplataforma Versatilidad a la hora de programar Sintaxis amigable","title":"Motivaci\u00f3n"},{"location":"introduccion/#popularidad","text":"Desde 2012, Python ha crecido constantemente en popularidad, y es probable que la tendencia contin\u00fae, si no aumenta, en el futuro. Seg\u00fan Stack Overflow Developer Survey 2018 . La demanda y el soporte para Python tambi\u00e9n est\u00e1n en aumento, y si se cree en las proyecciones, Python superar\u00e1 a Java en los pr\u00f3ximos a\u00f1os y reclamar\u00e1 el primer puesto. \u00bfEs buena la popularidad de Python? En general, lo que es popular no siempre es lo mejor, en el caso de los lenguajes de programaci\u00f3n, la popularidad vale la pena. Gracias a la popularidad de Python, es probable que encuentre una soluci\u00f3n preparada para cualquier problema que pueda estar experimentando. La comunidad de entusiastas de Python es fuerte y est\u00e1n trabajando incansablemente para mejorar el lenguaje todos los d\u00edas. Python tambi\u00e9n tiene una serie de patrocinadores corporativos, presionando para popularizar a\u00fan m\u00e1s el lenguaje. Entre ellos se encuentran gigantes tecnol\u00f3gicos como Google , que est\u00e1 utilizando Python.","title":"Popularidad"},{"location":"introduccion/#librerias-y-frameworks","text":"Una gran ventaja de Python es la amplia selecci\u00f3n de librer\u00edas y frameworks que ofrece. Hay librer\u00edas para distintos t\u00f3picos: Manipulaci\u00f3n de datos Visualizaci\u00f3n de datos Aprendizaje autom\u00e1tico Ciencia de los datos Procesamiento natural del lenguaje Big Data Lo mismo es cierto para los frameworks , que ayudan a despegar su proyecto y le ahorran tiempo y esfuerzo. Hay una variedad de marcos para elegir, dependiendo de sus necesidades, por ejemplo, para el desarrollo web tenemos: Django Flask FastApi","title":"Librer\u00edas y frameworks"},{"location":"introduccion/#performance","text":"Una de las mayores cr\u00edticas de Python es el tiempo de ejecuci\u00f3n, relativamente lento en comparaci\u00f3n con otros lenguajes. Sin embargo, hay una soluci\u00f3n alternativa a este desaf\u00edo espec\u00edfico. Cuando el rendimiento tiene prioridad, Python le brinda la capacidad de integrar otros lenguajes de mayor rendimiento en su c\u00f3digo. Cython es un buen ejemplo de tal soluci\u00f3n. Optimiza su velocidad sin obligarlo a reescribir todo su c\u00f3digo base desde cero. El recurso m\u00e1s caro no es el tiempo de CPU, sino el tiempo de tus desarrolladores. Por lo tanto, reducir el tiempo de comercializaci\u00f3n siempre debe tener prioridad sobre la ejecuci\u00f3n r\u00e1pida del tiempo de ejecuci\u00f3n. Adem\u00e1s, Python tiene una sintaxis clara y no requiere tantas l\u00edneas de c\u00f3digo como Java o C para obtener resultados comparables. \u00bfCu\u00e1les son los beneficios de la alta legibilidad de Python? La simplicidad de Python es particularmente \u00fatil para leer el c\u00f3digo, el suyo o el de otra persona. Debido a que el c\u00f3digo Python tiene menos l\u00edneas e imita el ingl\u00e9s, revisarlo lleva mucho menos tiempo. Este es un gran beneficio. Reducir el tiempo que necesita dedicar a la revisi\u00f3n de c\u00f3digo es invaluable, ya que la productividad de sus desarrolladores debe ser su m\u00e1xima prioridad.","title":"Performance"},{"location":"introduccion/#referencia","text":"Introducci\u00f3n al lenguaje Python Introducci\u00f3n \u2014 Tutorial de Python 3.6.3 documentation","title":"Referencia"}]}