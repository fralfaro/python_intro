{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bienvenidos al curso!","text":""},{"location":"#secciones","title":"Secciones","text":"<p>Cap\u00edtulos</p><p>Conceptos b\u00e1sicos en Python</p> <p>Soluci\u00f3n</p><p>Soluci\u00f3n de los ejercicios propuestos</p>"},{"location":"__init__/","title":"init","text":"In\u00a0[\u00a0]: Copied! <pre>__version__ = \"0.1.0\"\n</pre> __version__ = \"0.1.0\""},{"location":"basico/","title":"Nomenclatura","text":"In\u00a0[1]: Copied! <pre># imprimir \"Hola Mundo!\"\nprint(\"Hola Mundo!\");\n</pre> # imprimir \"Hola Mundo!\" print(\"Hola Mundo!\"); <pre>Hola Mundo!\n</pre> In\u00a0[2]: Copied! <pre># asignar e imprimir variables (numericas)\na = 5\nprint(\"a =\", 5)\n</pre> # asignar e imprimir variables (numericas) a = 5 print(\"a =\", 5) <pre>a = 5\n</pre> In\u00a0[3]: Copied! <pre># asignar e imprimir variables (texto)\na = \"cinco\"\nprint(\"a =\", a)\n</pre> # asignar e imprimir variables (texto) a = \"cinco\" print(\"a =\", a) <pre>a = cinco\n</pre> In\u00a0[4]: Copied! <pre># Ejemplo\n\nx = 5\ny = 4\nsuma = x+y\n\nprint(\"La suma de\", x, \"con\", y, \"es igual a\", suma)\n</pre> # Ejemplo  x = 5 y = 4 suma = x+y  print(\"La suma de\", x, \"con\", y, \"es igual a\", suma) <pre>La suma de 5 con 4 es igual a 9\n</pre> <p>Existen varias formas de imprimir variables y strings, sin embargo, la que m\u00e1s se destaca es la forma Literal String Interpolation (o tambi\u00e9n conocido como f-string). La formula es la siguiente:</p> <pre>print(f\"mensaje_01 {variable_01} mensaje_02 {variable_02} ...\")\n</pre> In\u00a0[5]: Copied! <pre># ejemplo f-string\nprint(f\"La suma de {x} con {y} es igual a igual a {suma}\")\n</pre> # ejemplo f-string print(f\"La suma de {x} con {y} es igual a igual a {suma}\") <pre>La suma de 5 con 4 es igual a igual a 9\n</pre> <p>Observaci\u00f3n: Se tratara de trabajar siempre con la forma f-string para ser consistente.</p> <pre>inputString = input('Escriba una oracion:')\nprint(f'Su oracion es: {inputString}')\n</pre> In\u00a0[6]: Copied! <pre># entero \na = 5\nprint(type(a))\n</pre> # entero  a = 5 print(type(a)) <pre>&lt;class 'int'&gt;\n</pre> In\u00a0[7]: Copied! <pre># flotante \nb = 1.5\nprint(type(b))\n</pre> # flotante  b = 1.5 print(type(b)) <pre>&lt;class 'float'&gt;\n</pre> In\u00a0[8]: Copied! <pre># complejo \nc = 5 + 3j\nprint(type(c))\n</pre> # complejo  c = 5 + 3j print(type(c)) <pre>&lt;class 'complex'&gt;\n</pre> In\u00a0[9]: Copied! <pre>a = True\nprint(type(a))\n</pre> a = True print(type(a)) <pre>&lt;class 'bool'&gt;\n</pre> In\u00a0[10]: Copied! <pre>b = False\nprint(type(b))\n</pre> b = False print(type(b)) <pre>&lt;class 'bool'&gt;\n</pre> In\u00a0[11]: Copied! <pre># comillas simples\na = 'hola mundo'\nprint(type(a))\n</pre> # comillas simples a = 'hola mundo' print(type(a)) <pre>&lt;class 'str'&gt;\n</pre> In\u00a0[12]: Copied! <pre># comillas complejas\nb = \"hola mundo\"\nprint(type(b))\n</pre> # comillas complejas b = \"hola mundo\" print(type(b)) <pre>&lt;class 'str'&gt;\n</pre> In\u00a0[13]: Copied! <pre>a = None\nprint(type(a))\n</pre> a = None print(type(a)) <pre>&lt;class 'NoneType'&gt;\n</pre> In\u00a0[14]: Copied! <pre># correcto (numerico  + numerico)\n\nnum_int = 123  # integer type\nnum_flo = 1.23 # float type\n\nnum_new = num_int + num_flo\n\nprint(f\"Valor de num_new: {num_new}\")\nprint(f\"tipo de datos de  num_new: {type(num_new)}\")\n</pre> # correcto (numerico  + numerico)  num_int = 123  # integer type num_flo = 1.23 # float type  num_new = num_int + num_flo  print(f\"Valor de num_new: {num_new}\") print(f\"tipo de datos de  num_new: {type(num_new)}\") <pre>Valor de num_new: 124.23\ntipo de datos de  num_new: &lt;class 'float'&gt;\n</pre> In\u00a0[15]: Copied! <pre># incorrecto (string  + numerico)\nnum_int = 123     # int type\nnum_str = \"456\"   # str type\n\nprint(num_int+num_str)\n</pre> # incorrecto (string  + numerico) num_int = 123     # int type num_str = \"456\"   # str type  print(num_int+num_str) <pre>\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nInput In [15], in &lt;cell line: 5&gt;()\n      2 num_int = 123     # int type\n      3 num_str = \"456\"   # str type\n----&gt; 5 print(num_int+num_str)\n\nTypeError: unsupported operand type(s) for +: 'int' and 'str'</pre> <p>b) Expl\u00edcito</p> In\u00a0[16]: Copied! <pre>num_int = 123  # int type\nnum_str = \"456\" # str type\n\n# cambiar string a numerico\nnum_str = int(num_str) \n\nprint(num_int+num_str)\n</pre> num_int = 123  # int type num_str = \"456\" # str type  # cambiar string a numerico num_str = int(num_str)   print(num_int+num_str) <pre>579\n</pre> <p>Observaci\u00f3n: el proceso de transformar <code>string</code> a <code>numeric</code> es correcto cuando lo que est\u00e1 escrito en el <code>string</code> es un n\u00famero, en caso contrario, nos dar\u00e1 error.</p> In\u00a0[17]: Copied! <pre># operaciones basicas \n\nx = 14\ny = 4\n\n# suma\nprint(f'x + y = {x+y}') # Output: x + y = 18\n\n# resta\nprint(f'x - y = {x-y}') # Output: x - y = 10\n\n# multiplicacion\nprint(f'x * y = {x*y}') # Output: x * y = 56\n\n# division\nprint(f'x / y = {x/y}') # Output: x / y = 3.5\n\n# cuociente o division entera\nprint(f'x // y = {x//y}') # Output: x // y = 3\n</pre> # operaciones basicas   x = 14 y = 4  # suma print(f'x + y = {x+y}') # Output: x + y = 18  # resta print(f'x - y = {x-y}') # Output: x - y = 10  # multiplicacion print(f'x * y = {x*y}') # Output: x * y = 56  # division print(f'x / y = {x/y}') # Output: x / y = 3.5  # cuociente o division entera print(f'x // y = {x//y}') # Output: x // y = 3 <pre>x + y = 18\nx - y = 10\nx * y = 56\nx / y = 3.5\nx // y = 3\n</pre> In\u00a0[18]: Copied! <pre># operacion potencia\nx = 4\ny=3\nz=0.5\n\nprint(f'potencia entera:           x ** y = {x**y}' ) \nprint(f'potencia fraccionaria:     x ** z = {x**z}')\n</pre> # operacion potencia x = 4 y=3 z=0.5  print(f'potencia entera:           x ** y = {x**y}' )  print(f'potencia fraccionaria:     x ** z = {x**z}')  <pre>potencia entera:           x ** y = 64\npotencia fraccionaria:     x ** z = 2.0\n</pre> <p>M\u00f3dulo</p> <p>Cuando dividimos dos enteros, tenemos una ecuaci\u00f3n que se ve como lo siguiente: $$\\dfrac{A}{B} = Q \\text{ residuo } R,$$ donde:</p> <ul> <li>$A$ es el dividendo</li> <li>$B$ es el divisor</li> <li>$Q$ es el cociente</li> <li>$R$ es el residuo</li> </ul> <p>A veces, solo estamos interesados en cu\u00e1nto es el residuo cuando dividimos $A$ entre $B$. Para estos casos hay un operador llamado el operador m\u00f3dulo (abreviado como mod).</p> <p>Al usar los mismos $A$, $B$, $Q$ y $R$ que arriba, tendr\u00edamos: $A \\text{ mod } B = R$ (notaci\u00f3n). Por ejemplo:</p> <p>$$\\dfrac{13}{4} = 3 \\text{ residuo } 1 \\textrm{, es equivalente a: } 13 \\textrm{ mod } 4 = 1 $$</p> In\u00a0[19]: Copied! <pre># modulo\nx = 13\ny = 4\nprint(f'x % y = {x%y}')\n</pre> # modulo x = 13 y = 4 print(f'x % y = {x%y}') <pre>x % y = 1\n</pre> <p>Redondear</p> <p>La funci\u00f3n incorporada <code>round()</code> toma como argumento un n\u00famero de coma flotante y retorna un n\u00famero entero seg\u00fan las reglas del redondeo.</p> In\u00a0[20]: Copied! <pre>x = 3.94987545322\n</pre> x = 3.94987545322 In\u00a0[21]: Copied! <pre># cero decimales\nprint(round(x))\n</pre> # cero decimales print(round(x)) <pre>4\n</pre> In\u00a0[22]: Copied! <pre># un decimal\nprint(round(x,1))\n</pre> # un decimal print(round(x,1)) <pre>3.9\n</pre> In\u00a0[23]: Copied! <pre># dos decimales\nprint(round(x,2))\n</pre> # dos decimales print(round(x,2)) <pre>3.95\n</pre> In\u00a0[24]: Copied! <pre># operadores de asignacion\n\nx = 5\n</pre> # operadores de asignacion  x = 5 In\u00a0[25]: Copied! <pre># x += 5 ----&gt; x = x + 5\nx +=5\nprint(x) # Output: 10\n</pre> # x += 5 ----&gt; x = x + 5 x +=5 print(x) # Output: 10 <pre>10\n</pre> In\u00a0[26]: Copied! <pre># x /= 5 ----&gt; x = x / 5\nx /= 5\nprint(x) # Output: 2.0\n</pre> # x /= 5 ----&gt; x = x / 5 x /= 5 print(x) # Output: 2.0 <pre>2.0\n</pre> In\u00a0[29]: Copied! <pre># operadores relacionales (numericos)\n\nx = 14\ny = 4\n</pre> # operadores relacionales (numericos)  x = 14 y = 4 In\u00a0[30]: Copied! <pre># igual a\nprint(f'x = y  {x==y}')\n</pre> # igual a print(f'x = y  {x==y}')  <pre>x = y  False\n</pre> In\u00a0[31]: Copied! <pre># distinto\nprint(f'x != y {x!=y}')\n</pre> # distinto print(f'x != y {x!=y}') <pre>x != y True\n</pre> In\u00a0[32]: Copied! <pre># mayor que\nprint(f'x &gt; y  {x&gt;y}')\n</pre> # mayor que print(f'x &gt; y  {x&gt;y}') <pre>x &gt; y  True\n</pre> In\u00a0[33]: Copied! <pre># mayor o igual que\nprint(f'x &gt;= y {x&gt;=y}')\n</pre> # mayor o igual que print(f'x &gt;= y {x&gt;=y}')  <pre>x &gt;= y True\n</pre> In\u00a0[34]: Copied! <pre># menor o igual que\nprint(f'x &lt;= y {x&lt;=y}')\n</pre> # menor o igual que print(f'x &lt;= y {x&lt;=y}')  <pre>x &lt;= y False\n</pre> <p>Operadores relacionales ( string )</p> In\u00a0[35]: Copied! <pre># operadores relacionales ( string )\ntexto = \"Python\"\notro_texto = \"programa\"\n</pre> # operadores relacionales ( string ) texto = \"Python\" otro_texto = \"programa\" In\u00a0[36]: Copied! <pre># igualdad \nprint(texto == otro_texto)\n</pre> # igualdad  print(texto == otro_texto) <pre>False\n</pre> In\u00a0[37]: Copied! <pre># desigualdad \nprint(texto != otro_texto)\n</pre> # desigualdad  print(texto != otro_texto) <pre>True\n</pre> In\u00a0[38]: Copied! <pre># un string esta en un texto\nprint(\"thon\" in texto)\n</pre> # un string esta en un texto print(\"thon\" in texto) <pre>True\n</pre> In\u00a0[39]: Copied! <pre># un string NO esta en un texto\nprint(\"thon\" not in texto)\n</pre> # un string NO esta en un texto print(\"thon\" not in texto) <pre>False\n</pre> In\u00a0[40]: Copied! <pre># ejemplos 'and'\nvalor = True and False\nprint(valor)\n</pre> # ejemplos 'and' valor = True and False print(valor) <pre>False\n</pre> In\u00a0[41]: Copied! <pre># ejemplos 'or'\nvalor = True or False\nprint(valor)\n</pre> # ejemplos 'or' valor = True or False print(valor) <pre>True\n</pre> In\u00a0[42]: Copied! <pre># ejemplos 'not'\nvalor = not True\nprint(valor)\n</pre> # ejemplos 'not' valor = not True print(valor) <pre>False\n</pre> In\u00a0[54]: Copied! <pre># suma\ntexto_01 = \"hola \"\ntexto_02 = \"mundo\"\nprint(texto_01+texto_02)\n</pre> # suma texto_01 = \"hola \" texto_02 = \"mundo\" print(texto_01+texto_02) <pre>hola mundo\n</pre> In\u00a0[55]: Copied! <pre># multiplicacion\ntexto = \"hola mundo \"\nprint(4*texto)\n</pre> # multiplicacion texto = \"hola mundo \" print(4*texto) <pre>hola mundo hola mundo hola mundo hola mundo \n</pre> In\u00a0[43]: Copied! <pre># lower\ntexto = \"HOLA MUNDO\"\nprint(texto.lower())\n</pre> # lower texto = \"HOLA MUNDO\" print(texto.lower()) <pre>hola mundo\n</pre> In\u00a0[44]: Copied! <pre># upper\ntexto = \"hola mundo\"\nprint(texto.upper())\n</pre> # upper texto = \"hola mundo\" print(texto.upper()) <pre>HOLA MUNDO\n</pre> In\u00a0[45]: Copied! <pre># strip\ntexto = \" hola mundo \"\nprint(texto.strip())\n</pre> # strip texto = \" hola mundo \" print(texto.strip()) <pre>hola mundo\n</pre> In\u00a0[46]: Copied! <pre># replace\ntexto = \" hola mundo \"\ncambiar = \"universo\"\nprint(texto.replace(\"mundo\",\"universo\"))\n</pre> # replace texto = \" hola mundo \" cambiar = \"universo\" print(texto.replace(\"mundo\",\"universo\")) <pre> hola universo \n</pre> <p>Indexaciones</p> <p>Cada uno de los caracteres de un string (incluidos los espacios) tiene asignado un \u00edndice. Este indice nos permite seleccionar su car\u00e1cter asociado haciendo referencia a \u00e9l entre corchetes (<code>[]</code>) en el nombre de la variable que almacena la cadena.</p> <p> </p> In\u00a0[47]: Copied! <pre># seleccion primer elemento \ntexto = \"Python\"\nprint(texto[0])\n</pre> # seleccion primer elemento  texto = \"Python\" print(texto[0]) <pre>P\n</pre> In\u00a0[48]: Copied! <pre># seleccion ultimo elemento \nprint(texto[-1])\n</pre> # seleccion ultimo elemento  print(texto[-1]) <pre>n\n</pre> <p>Otra operaci\u00f3n que podemos realizar a una cadena es seleccionar solamente una parte de ella. Para ello se usa la notaci\u00f3n <code>[inicio:fin:paso]</code> tambi\u00e9n en el nombre de la variable que almacena la cadena, donde:</p> <ul> <li>Inicio: es el \u00edndice del primer car\u00e1cter de la porci\u00f3n de la cadena que queremos seleccionar.</li> <li>Fin: es el \u00edndice del \u00faltimo car\u00e1cter no incluido de la porci\u00f3n de la cadena que queremos seleccionar.</li> <li>Paso: indica cada cuantos caracteres seleccionamos entre las posiciones de inicio y fin.</li> </ul> In\u00a0[49]: Copied! <pre>texto = \"Programa en Python\"\n</pre> texto = \"Programa en Python\" In\u00a0[50]: Copied! <pre># seleccionar los elementos del primero al noveno en pasos de uno\nprint(texto[0:8:1])\n</pre> # seleccionar los elementos del primero al noveno en pasos de uno print(texto[0:8:1]) <pre>Programa\n</pre> In\u00a0[51]: Copied! <pre># seleccionar los elementos del primero al noveno en pasos de uno\nprint(texto[0:8:1])\n</pre> # seleccionar los elementos del primero al noveno en pasos de uno print(texto[0:8:1]) <pre>Programa\n</pre> In\u00a0[52]: Copied! <pre># seleccionar los elementos del treceavo en adelante\nprint(texto[12:])\n</pre> # seleccionar los elementos del treceavo en adelante print(texto[12:]) <pre>Python\n</pre> <p>Observaci\u00f3n: Para imprimir el largo de un texto, puede usar el comando <code>len</code>.</p> In\u00a0[53]: Copied! <pre>texto = \"Programa en Python\"\nlargo = len(texto)\n\nprint(f\"El texto tiene {largo} letras\")\n</pre> texto = \"Programa en Python\" largo = len(texto)  print(f\"El texto tiene {largo} letras\") <pre>El texto tiene 18 letras\n</pre> <p>Ejercicio 01</p> <p>Escriba un programa que pida al usuario que escriba su nombre, y lo salude llam\u00e1ndolo por su nombre.</p> <pre><code>terminal\nIngrese su nombre: Perico\nHola, Perico\n</code></pre> In\u00a0[\u00a0]: Copied! <pre># respuesta\n</pre> # respuesta <p>Ejercicio 02</p> <p>Escriba un programa que reciba como entrada el radio de un c\u00edrculo y entregue como salida su per\u00edmetro y su \u00e1rea:</p> <pre><code>terminal\nIngrese el radio: 5\nPerimetro: 31.4\n\u00c1rea: 78.5\n</code></pre> In\u00a0[\u00a0]: Copied! <pre># respuesta\n</pre> # respuesta <p>Ejercicio 03</p> <p>Escriba un programa que calcule el promedio de 4 notas ingresadas por el usuario:</p> <pre><code>terminal\nPrimera nota: 55\nSegunda nota: 71\nTercera nota: 46\nCuarta nota: 87\nEl promedio es: 64.75\n</code></pre> In\u00a0[\u00a0]: Copied! <pre># respuesta\n</pre> # respuesta <p>Ejercicio 04</p> <p>Escriba un programa que convierta de cent\u00edmetros a pulgadas. Una pulgada es igual a 2.54 cent\u00edmetros.</p> <pre><code>terminal\nIngrese longitud: 45\n45 cm = 17.7165 in\n</code></pre> In\u00a0[\u00a0]: Copied! <pre># respuesta\n</pre> # respuesta <p>Ejercicio 05</p> <p>Escriba un programa que reciba como entrada las longitudes de los dos catetos $a$ y $b$ de un tri\u00e1ngulo rect\u00e1ngulo, y que entregue como salida el largo de la hipotenusa $c$ del triangulo, dado por el teorema de Pit\u00e1goras: $c^2=a^2+b^2$.</p> <pre><code>terminal\nIngrese cateto a: 7\nIngrese cateto b: 5\nLa hipotenusa es 8.6023252670426267\n</code></pre> In\u00a0[\u00a0]: Copied! <pre># respuesta\n</pre> # respuesta <p>Ejercicio 06</p> <p>Escriba un programa que pregunte al usuario la hora actual $t$ del reloj y un n\u00famero entero de horas $h$, que indique qu\u00e9 hora marcar\u00e1 el reloj dentro de $h$ horas:</p> <pre><code>terminal\nHora actual: 3\nCantidad de horas: 5\nEn 5 horas, el reloj marcara las 8\n</code></pre> <pre><code>terminal\nHora actual: 21\nCantidad de horas: 8\nEn 5 horas, el reloj marcara las 5\n</code></pre> In\u00a0[\u00a0]: Copied! <pre># respuesta\n</pre> # respuesta <p>Ejercicio 07</p> <p>Un alumno desea saber que nota necesita en el tercer certamen para aprobar un ramo.</p> <p>El promedio del ramo se calcula con la siguiente formula.</p> <p>$$N_C=(C_1+C_2+C_3)/3 \\\\ N_F=N_C\u22c50.7+N_L\u22c50.3$$</p> <p>Donde $N_C$ es el promedio de cert\u00e1menes, $N_L$ el promedio de laboratorio y $N_F$ la nota final.</p> <p>Escriba un programa que pregunte al usuario las notas de los dos primeros certamen y la nota de laboratorio, y muestre la nota que necesita el alumno para aprobar el ramo con nota final 60.</p> <pre><code>terminal\nIngrese nota certamen 1: 45\nIngrese nota certamen 2: 55\nIngrese nota laboratorio: 65\nNecesita nota 74 en el certamen 3\n</code></pre> In\u00a0[\u00a0]: Copied! <pre># respuesta\n</pre> # respuesta <p>Ejercicio 08</p> <p>Realice un programa que calcule el \u00e1rea de un tri\u00e1ngulo a partir de las longitudes de sus lados.</p> <p>Para calcularlo puede utilizar la f\u00f3rmula de Her\u00f3n:</p> <p>$$     A = \\sqrt{s\\,(s-a)(s-b)(s-c)}, $$ donde $a$, $b$ y $c$ son las longitudes de cada lado y $s=\\dfrac{a+b+c}{2}$ es el semiper\u00edmetro.</p> <pre><code>terminal\nIngrese longitud de lado 1: 3\nIngrese longitud de lado 2: 4\nIngrese longitud de lado 3: 5\nEl \u00e1rea del tri\u00e1ngulo es 6.0\n</code></pre> In\u00a0[1]: Copied! <pre># respuesta\n</pre> # respuesta"},{"location":"basico/#nomenclatura","title":"Nomenclatura\u00b6","text":""},{"location":"basico/#sintaxis","title":"Sintaxis\u00b6","text":""},{"location":"basico/#hola-mundo","title":"Hola mundo!\u00b6","text":"<p>Escribamos nuestro primer programa de Python, \"\u00a1Hola, mundo!\". Es un programa simple que imprime Hello World! en el dispositivo de salida est\u00e1ndar (pantalla). Para eso se ocupa el comando <code>print()</code>.</p>"},{"location":"basico/#variables","title":"Variables\u00b6","text":"<p>Una variable es una ubicaci\u00f3n con nombre utilizada para almacenar datos en la memoria. Una asignaci\u00f3n es una sentencia que asocia un nombre al resultado de una expresi\u00f3n.</p>"},{"location":"basico/#imprimir-mensajes-y-variables","title":"Imprimir mensajes y variables\u00b6","text":"<p>La formula para imprimir mensajes y variables es:</p> <pre>print(\"mensaje_01\",variable_01,\"mensaje_02\",variable_02,...)\n</pre>"},{"location":"basico/#inputs-por-el-usuario","title":"Inputs por el usuario\u00b6","text":"<p>En Python, puede usar la funci\u00f3n <code>input()</code> para tomar la entrada del usuario. Por ejemplo:</p>"},{"location":"basico/#tipos-de-datos","title":"Tipos de datos\u00b6","text":""},{"location":"basico/#enteros-flotantes-y-numeros-complejos","title":"Enteros, flotantes y n\u00fameros complejos\u00b6","text":"<p>Python admite enteros, n\u00fameros de coma flotante y n\u00fameros complejos. Se definen como <code>int</code>, <code>float</code> y <code>complex</code> en Python.</p>"},{"location":"basico/#valores-logicos","title":"Valores l\u00f3gicos\u00b6","text":"<p>Los valores l\u00f3gicos <code>True</code> y <code>False</code> (verdadero y falso) son de tipo <code>bool</code>, que representa valores l\u00f3gicos.</p> <p>El nombre bool viene del matem\u00e1tico George Boole, quien cre\u00f3 un sistema algebraico para la l\u00f3gica binaria. Por lo mismo, a <code>True</code> y <code>False</code> tambi\u00e9n se les llama valores booleanos. El nombre no es muy intuitivo, pero es el que se usa en inform\u00e1tica, as\u00ed que hay que conocerlo.</p>"},{"location":"basico/#texto","title":"Texto\u00b6","text":"<p>A los valores que representan texto se les llama <code>strings</code>, y tienen el tipo <code>str</code>.</p> <p>Los strings literales pueden ser representados con texto entre comillas simples o comillas dobles:</p>"},{"location":"basico/#nulo","title":"Nulo\u00b6","text":"<p>Existe un valor llamado <code>None</code> (en ingl\u00e9s, \u00abninguno\u00bb) que es utilizado para representar casos en que ning\u00fan valor es v\u00e1lido, o para indicar que una variable todav\u00eda no tiene un valor que tenga sentido.</p> <p>El valor None tiene su propio tipo, llamado <code>NoneType</code>, que es diferente al de todos los dem\u00e1s valores.</p>"},{"location":"basico/#conversion-de-tipo","title":"Conversi\u00f3n de tipo\u00b6","text":"<p>El proceso de convertir el valor de un tipo de datos (entero, cadena, flotante, etc.) en otro se llama conversi\u00f3n de tipo. Python tiene dos tipos de conversi\u00f3n de tipos.</p> <p>a) Impl\u00edcita</p>"},{"location":"basico/#operaciones","title":"Operaciones\u00b6","text":""},{"location":"basico/#operadores-aritmeticos","title":"Operadores aritm\u00e9ticos\u00b6","text":"<p>Los operadores son s\u00edmbolos especiales que realizan operaciones en operandos (variables y valores). Hablemos de operadores aritm\u00e9ticos y de asignaci\u00f3n en esta parte.</p>"},{"location":"basico/#otros-operadores-aritmeticos","title":"Otros operadores ar\u00edtmeticos\u00b6","text":"<p>Potencia</p> <p>La funci\u00f3n potencia de un n\u00famero entero corresponde a multiplicar $n$ veces el mismo n\u00famero. Por ejemplo</p> <p>$$4^3 = 4*4*4 = 64$$</p> <p>Cuando el exponente es fracionario, hablamos de ra\u00edces. Por ejemplo:</p> <p>$$4^{1/2} = \\sqrt{4} = 2$$</p>"},{"location":"basico/#operadores-de-asignacion","title":"Operadores de asignaci\u00f3n\u00b6","text":"<p>Los operadores de asignaci\u00f3n se utilizan para asignar valores a las variables. Probemos algunos operadores de asignaci\u00f3n m\u00e1s comunes.</p>"},{"location":"basico/#operadores-relacionales","title":"Operadores relacionales\u00b6","text":"<p>Los operadores relacionales sirven para comparar valores. Sus operandos son cualquier cosa que pueda ser comparada, y sus resultados siempre son valores l\u00f3gicos.</p> <p>Operadores relacionales (num\u00e9ricos)</p>"},{"location":"basico/#operaciones-binarias","title":"Operaciones Binarias\u00b6","text":"<p>Una tabla de verdad, o tabla de valores de verdades, es una tabla que muestra el valor de verdad de una proposici\u00f3n compuesta, para cada combinaci\u00f3n de verdad que se pueda asignar.</p> <p>| p \t| q \t| p \u2227 q \t| p v q \t| \u00acp \t| \u00acq \t| |:-:\t|:-:\t|:-----:\t|:-----:\t|:--:\t|:--:\t| | T \t| T \t|   T   \t|   T   \t|  F \t|  F \t| | T \t| F \t|   F   \t|   T   \t|  F \t|  T \t| | F \t| T \t|   F   \t|   T   \t|  T \t|  F \t| | F \t| F \t|   F   \t|   F   \t|  T \t|  T \t|</p> <p>En Python, hay tres operaciones l\u00f3gicas:</p> <ul> <li>la conjunci\u00f3n l\u00f3gica <code>and</code> (en espa\u00f1ol: y)</li> <li>la disyunci\u00f3n l\u00f3gica <code>or</code> (en espa\u00f1ol: o)</li> <li>la negaci\u00f3n l\u00f3gica <code>not</code> (en espa\u00f1ol: no)</li> </ul> <p>| p     \t| q     \t| p and q \t| p or q \t| not p \t| not q \t| |-------\t|-------\t|---------\t|--------\t|-------\t|-------\t| | True  \t| True  \t| True    \t| True   \t| False \t| True  \t| | True  \t| False \t| False   \t| True   \t| False \t| True  \t| | False \t| True  \t| False   \t| True   \t| True  \t| False \t| | False \t| False \t| False   \t| False  \t| True  \t| False \t|</p>"},{"location":"basico/#operadores-de-string","title":"Operadores de String\u00b6","text":"<p>Los operadores de string sirven para poder operar variables tipo <code>str</code>.</p>"},{"location":"basico/#mas-operadores-de-string","title":"M\u00e1s operadores de String\u00b6","text":"<p>Existe algunas m\u00e9todos aplicable a los <code>strings</code>:</p>"},{"location":"basico/#ejercicios","title":"Ejercicios\u00b6","text":""},{"location":"buenas_practicas/","title":"Buenas pr\u00e1cticas","text":"<p>Adem\u00e1s de una correcta y ordenada estructura general que deben tener los programa, es conveniente mantener ciertas buenas pr\u00e1cticas de codificaci\u00f3n y el estilo de codificaci\u00f3n recomendado. Estas normas no son obligatorias, como lo es la propia sintaxis del lenguaje, pero conviene seguir las recomendaciones de los desarrolladores de Python para facilitar la lectura del programa y ayudar a encontrar posibles errores.</p> <p>A continuaci\u00f3n, se presentan algunas buenas pr\u00e1cticas relacionadas con es estilo de codificaci\u00f3n:</p> In\u00a0[1]: Copied! <pre>a = 10.  \nb = 3.5 \nprint(\"El volumen es %.1f\" % (a*b))\n</pre> a = 10.   b = 3.5  print(\"El volumen es %.1f\" % (a*b)) <pre>El volumen es 35.0\n</pre> <p>pero, \u00bfqu\u00e9 significan <code>a</code> y  <code>b</code>? lo sabemos por el comentario (bien hecho), pero si m\u00e1s adelante nos encontramos con esas variables, tendremos que recordar cual es cual. Es mejor usar nombres con significado:</p> In\u00a0[1]: Copied! <pre>altura = 10.\nbase = 3.5\nprint(\"El volumen es %.1f\" % (altura*base))\n</pre> altura = 10. base = 3.5 print(\"El volumen es %.1f\" % (altura*base)) <pre>El volumen es 35.0\n</pre> <p>Las l\u00edneas de codigo no deben ser muy largas, como mucho 72 caracteres. Si se tiene una l\u00ednea larga, se puede cortar con una barra invertida (<code>\\</code>) y continuar en la siguiente l\u00ednea:</p> In\u00a0[4]: Copied! <pre>print(\"Esta es una frase muy larga, se puede cortar con una \\\n       y seguir en la l\u00ednea inferior.\")\n</pre> print(\"Esta es una frase muy larga, se puede cortar con una \\        y seguir en la l\u00ednea inferior.\") <pre>Esta es una frase muy larga, se puede cortar con una        y seguir en la l\u00ednea inferior.\n</pre> In\u00a0[5]: Copied! <pre># esto es un comentario\nprint('Hola')\n</pre> # esto es un comentario print('Hola') <pre>Hola\n</pre> <p>Tambi\u00e9n podemos tener comentarios multil\u00edneas:</p> In\u00a0[6]: Copied! <pre># Este es un comentario largo\n# y se extiende\n# a varias l\u00edneas\n</pre> # Este es un comentario largo # y se extiende # a varias l\u00edneas <p>Dentro de par\u00e9ntesis, corchetes o llaves, no dejar espacios inmediatamente dentro de ellos:</p> In\u00a0[7]: Copied! <pre># no:  \nlista_01 = [1, 2, 3,4, 5, 6,7, 8, 9,]\n</pre> # no:   lista_01 = [1, 2, 3,4, 5, 6,7, 8, 9,] In\u00a0[8]: Copied! <pre># si \nlista_01 = [\n    1, 2, 3,\n    4, 5, 6,\n    7, 8, 9, \n]\n</pre> # si  lista_01 = [     1, 2, 3,     4, 5, 6,     7, 8, 9,  ] <p>Aunque en Python se pueden hacer varias declaraciones en una l\u00ednea, se recomienda hacer s\u00f3lo una en cada l\u00ednea:</p> In\u00a0[9]: Copied! <pre># no\na = 10; b = 20\n</pre> # no a = 10; b = 20 In\u00a0[10]: Copied! <pre># si\na = 10\nb = 20\n</pre> # si a = 10 b = 20     <p>Cuando se trabaja con lista, conjuntos y/o tuplas se recomienda poner en cada l\u00ednea sus argumentos.</p> In\u00a0[11]: Copied! <pre># no\nlista = [(1, 'hola'),(2, 'mundo'),]\n</pre> # no lista = [(1, 'hola'),(2, 'mundo'),]   In\u00a0[12]: Copied! <pre># si\nlista = [\n    (1, 'hola'),\n    (2, 'mundo'),\n]\n</pre> # si lista = [     (1, 'hola'),     (2, 'mundo'), ] <p>Lo anterior se puede extender para funciones con muchos argumentos</p> In\u00a0[13]: Copied! <pre># no\ndef funcion_01(x1,x2,x3,x4):\n    print(x1,x2,x3,x4)\n    \ndef funcion_02(\n    x1,x2,x3,x4):\n    print(x1,x2,x3,x4)\n</pre> # no def funcion_01(x1,x2,x3,x4):     print(x1,x2,x3,x4)      def funcion_02(     x1,x2,x3,x4):     print(x1,x2,x3,x4) In\u00a0[14]: Copied! <pre># si\ndef funcion_01(x1,x2,\n               x3,x4):\n    \n    print(x1,x2,x3,x4)\n    \ndef funcion_02(\n        x1,x2,\n        x3,x4):\n    \n    print(x1,x2,x3,x4)\n</pre> # si def funcion_01(x1,x2,                x3,x4):          print(x1,x2,x3,x4)      def funcion_02(         x1,x2,         x3,x4):          print(x1,x2,x3,x4) In\u00a0[15]: Copied! <pre># Seleccionar los n\u00fameros positivos\nnumeros = [-3, 2, 1, -8, -2, 7]\npositivos = []\nfor i in numeros:\n    if i &gt; 0:\n        positivos.append(i)\n        \nprint(f\"positivos: {positivos}\")\n</pre> # Seleccionar los n\u00fameros positivos numeros = [-3, 2, 1, -8, -2, 7] positivos = [] for i in numeros:     if i &gt; 0:         positivos.append(i)          print(f\"positivos: {positivos}\") <pre>positivos: [2, 1, 7]\n</pre> <p>Aunque t\u00e9cnicamente es correcto, es m\u00e1s eficiente hacer List Comprehension:</p> In\u00a0[16]: Copied! <pre># comprension de lista\nnumeros = [-3, 2, 1, -8, -2, 7]\npositivos = [i for i in numeros if i &gt; 0] # List Comprehension\nprint(f\"positivos: {positivos}\")\n</pre> # comprension de lista numeros = [-3, 2, 1, -8, -2, 7] positivos = [i for i in numeros if i &gt; 0] # List Comprehension print(f\"positivos: {positivos}\") <pre>positivos: [2, 1, 7]\n</pre> In\u00a0[17]: Copied! <pre># importar librerias\nimport sys\n</pre> # importar librerias import sys In\u00a0[18]: Copied! <pre># no\ntry:\n    r = 1/0\nexcept:\n    print(\"Oops! ocurrio un\",sys.exc_info()[0])\n</pre> # no try:     r = 1/0 except:     print(\"Oops! ocurrio un\",sys.exc_info()[0]) <pre>Oops! ocurrio un &lt;class 'ZeroDivisionError'&gt;\n</pre> In\u00a0[19]: Copied! <pre># si\ntry:\n    r = 1/0\nexcept ZeroDivisionError:\n    print(\"Oops! ocurrio un\",sys.exc_info()[0])\n</pre> # si try:     r = 1/0 except ZeroDivisionError:     print(\"Oops! ocurrio un\",sys.exc_info()[0]) <pre>Oops! ocurrio un &lt;class 'ZeroDivisionError'&gt;\n</pre> In\u00a0[20]: Copied! <pre># no\nvalor = 5\n\ndef funcion_01(variable):\n    return 2*variable + valor\n</pre> # no valor = 5  def funcion_01(variable):     return 2*variable + valor In\u00a0[21]: Copied! <pre>funcion_01(2)\n</pre> funcion_01(2) Out[21]: <pre>9</pre> In\u00a0[22]: Copied! <pre># si\ndef funcion_01(variable,valor):\n    return 2*variable + valor\n</pre> # si def funcion_01(variable,valor):     return 2*variable + valor In\u00a0[23]: Copied! <pre>funcion_01(2,5)\n</pre> funcion_01(2,5) Out[23]: <pre>9</pre> In\u00a0[24]: Copied! <pre># escritura din\u00e1mica\ndef suma(x,y):\n    return x+y\n</pre> # escritura din\u00e1mica def suma(x,y):     return x+y In\u00a0[25]: Copied! <pre>print(suma(1,2))\n</pre> print(suma(1,2)) <pre>3\n</pre> In\u00a0[26]: Copied! <pre># escritura estatica\ndef suma(x:float,\n         y:float)-&gt;float:\n    return x+y\n</pre> # escritura estatica def suma(x:float,          y:float)-&gt;float:     return x+y In\u00a0[27]: Copied! <pre>print(suma(1,2))\n</pre> print(suma(1,2)) <pre>3\n</pre> <p>Para la escritura est\u00e1tica, si bien se especifica el tipo de atributo (tanto de los inputs o outputs), la funci\u00f3n puede recibir otros tipos de atributos.</p> In\u00a0[28]: Copied! <pre>print(suma(\"hola\",\" mundo\"))\n</pre> print(suma(\"hola\",\" mundo\")) <pre>hola mundo\n</pre> <p>Para validar los tipos de datos son los correctos, se deben ocupar librer\u00edas especializadas en la validaci\u00f3n de datos (por ejemplo <code>pydantic</code>).</p> In\u00a0[29]: Copied! <pre>def potencia(x, y):\n    \"\"\"\n    Calcula la potencia arbitraria de un numero\n    \"\"\"\n    return x**y\n</pre> def potencia(x, y):     \"\"\"     Calcula la potencia arbitraria de un numero     \"\"\"     return x**y In\u00a0[30]: Copied! <pre># Acceso a la documentaci\u00f3n\npotencia.__doc__\n</pre> # Acceso a la documentaci\u00f3n potencia.__doc__ Out[30]: <pre>'\\n    Calcula la potencia arbitraria de un numero\\n    '</pre> In\u00a0[31]: Copied! <pre># Acceso a la documentaci\u00f3n\nhelp(potencia)\n</pre> # Acceso a la documentaci\u00f3n help(potencia) <pre>Help on function potencia in module __main__:\n\npotencia(x, y)\n    Calcula la potencia arbitraria de un numero\n\n</pre> <p>Lo correcto es detallar lo mejor posible en el Docstring qu\u00e9 hace y c\u00f3mo se usa la funci\u00f3n o clase y los par\u00e1metros que necesita. Se recomienda usar el estilo de documentaci\u00f3n del software de documentaci\u00f3n sphinx, que emplea reStructuredText como lenguaje de marcado.</p> <p>Veamos un ejemplo de una funci\u00f3n bien documentada:</p> In\u00a0[32]: Copied! <pre>def potencia(x, y):\n    \"\"\"\n    Calcula la potencia arbitraria de un numero\n\n    :param x: base\n    :param y: exponente\n    :return:  potencia de un numero\n    :ejemplos:\n    \n    &gt;&gt;&gt; potencia(2, 1)\n    2\n    &gt;&gt;&gt; potencia(3, 2)\n    9\n    \"\"\"\n\n    return x**y\n</pre> def potencia(x, y):     \"\"\"     Calcula la potencia arbitraria de un numero      :param x: base     :param y: exponente     :return:  potencia de un numero     :ejemplos:          &gt;&gt;&gt; potencia(2, 1)     2     &gt;&gt;&gt; potencia(3, 2)     9     \"\"\"      return x**y In\u00a0[33]: Copied! <pre># Acceso a la documentaci\u00f3n\npotencia.__doc__\n</pre> # Acceso a la documentaci\u00f3n potencia.__doc__ Out[33]: <pre>'\\n    Calcula la potencia arbitraria de un numero\\n\\n    :param x: base\\n    :param y: exponente\\n    :return:  potencia de un numero\\n    :ejemplos:\\n    \\n    &gt;&gt;&gt; potencia(2, 1)\\n    2\\n    &gt;&gt;&gt; potencia(3, 2)\\n    9\\n    '</pre> In\u00a0[34]: Copied! <pre># Acceso a la documentaci\u00f3n\nhelp(potencia)\n</pre> # Acceso a la documentaci\u00f3n help(potencia) <pre>Help on function potencia in module __main__:\n\npotencia(x, y)\n    Calcula la potencia arbitraria de un numero\n    \n    :param x: base\n    :param y: exponente\n    :return:  potencia de un numero\n    :ejemplos:\n    \n    &gt;&gt;&gt; potencia(2, 1)\n    2\n    &gt;&gt;&gt; potencia(3, 2)\n    9\n\n</pre> <p>Tipos de Docstring</p> <p>Existen varias formas de documentar tus funciones, las principales encontradas en la literatura son:</p> <ul> <li>Google docstrings:Google\u2019s recommended form of documentation.</li> <li>reStructured Text:Official Python documentation standard; Not beginner friendly but feature rich.</li> <li>NumPy/SciPy docstrings:NumPy\u2019s combination of reStructured and Google Docstrings.</li> <li>EpytextA Python adaptation of Epydoc; Great for Java developer.\"</li> </ul> <p></p> <p>Tambi\u00e9n, podemos ver el mensaje original del zen de python, ejecutando la siguiente linea de comando.</p> In\u00a0[35]: Copied! <pre>import this\n</pre> import this <pre>The Zen of Python, by Tim Peters\n\nBeautiful is better than ugly.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\nFlat is better than nested.\nSparse is better than dense.\nReadability counts.\nSpecial cases aren't special enough to break the rules.\nAlthough practicality beats purity.\nErrors should never pass silently.\nUnless explicitly silenced.\nIn the face of ambiguity, refuse the temptation to guess.\nThere should be one-- and preferably only one --obvious way to do it.\nAlthough that way may not be obvious at first unless you're Dutch.\nNow is better than never.\nAlthough never is often better than *right* now.\nIf the implementation is hard to explain, it's a bad idea.\nIf the implementation is easy to explain, it may be a good idea.\nNamespaces are one honking great idea -- let's do more of those!\n</pre>"},{"location":"buenas_practicas/#buenas-practicas","title":"Buenas pr\u00e1cticas\u00b6","text":""},{"location":"buenas_practicas/#estilo-de-codificacion","title":"Estilo de codificaci\u00f3n\u00b6","text":""},{"location":"buenas_practicas/#variables","title":"Variables\u00b6","text":"<p>Cuando sea posible, define variables con nombres que tengan alg\u00fan sentido o que puedas identificar f\u00e1cilmente, no importa que sean m\u00e1s largas. Por ejemplo, en un programa podr\u00edamos escribir:</p>"},{"location":"buenas_practicas/#lineas-de-codigos","title":"Lineas de c\u00f3digos\u00b6","text":""},{"location":"buenas_practicas/#comentarios","title":"Comentarios\u00b6","text":"<p>Los comentarios son muy importantes al escribir un programa. Describen lo que est\u00e1 sucediendo dentro de un programa, para que una persona que mira el c\u00f3digo fuente no tenga dificultades para descifrarlo.</p>"},{"location":"buenas_practicas/#identacion","title":"Identaci\u00f3n\u00b6","text":""},{"location":"buenas_practicas/#manipulacion-de-listas","title":"Manipulaci\u00f3n de listas\u00b6","text":"<p>Aunque combinar iterables con elementos de control de flujo para manipular listas es muy sencillo con Python, hay m\u00e9todos espec\u00edficos m\u00e1s eficientes para hacer lo mismo. Pensemos el fitrado de datos de una lista:</p>"},{"location":"buenas_practicas/#especificar-tipo-de-error","title":"Especificar tipo de error\u00b6","text":"<p>Cuando se ocupa <code>try/except</code>, es necesario especificar el tipo de error que se est\u00e1 cometiendo.</p>"},{"location":"buenas_practicas/#explicitar-dependencias-de-una-funcion","title":"Explicitar dependencias de una funci\u00f3n\u00b6","text":"<p>Siempre es mejor definir las variables dentro de una funci\u00f3n y no dejar variables globales.</p>"},{"location":"buenas_practicas/#escritura-dinamica-y-estatica","title":"Escritura din\u00e1mica y est\u00e1tica\u00b6","text":"<p>Con Python 3 se puede especificar el tipo de par\u00e1metro y el tipo de retorno de una funci\u00f3n. Se definen dos conceptos claves:</p> <ul> <li>Escritura  din\u00e1mica: no se especifican los atributos de los inputs ni de los ouputs</li> <li>Escritura  est\u00e1tica: se especifican los atributos de los inputs y los ouputs</li> </ul>"},{"location":"buenas_practicas/#documentacion-de-codigo","title":"Documentaci\u00f3n de c\u00f3digo\u00b6","text":"<p>Casi tan importante como la escritura de c\u00f3digo, es su correcta documentaci\u00f3n, una parte fundamental de cualquier programa que a menudo se infravalora o simplemente se ignora. Aparte de los comentarios entre el c\u00f3digo explicando c\u00f3mo funciona, el elemento b\u00e1sico de documentaci\u00f3n de Python es el Docstring o cadena de documentaci\u00f3n, que ya hemos visto. Simplemente es una cadena de texto con triple comillas que se coloca justo despu\u00e9s de la definici\u00f3n de funci\u00f3n o clase que sirve de documentaci\u00f3n a ese elemento.</p>"},{"location":"buenas_practicas/#zen-de-python","title":"Zen de python\u00b6","text":"<p>El Zen de Python es un conjunto de principios y directrices que gu\u00edan la escritura de c\u00f3digo en el lenguaje de programaci\u00f3n Python. Estas recomendaciones son presentadas de manera humor\u00edstica y filos\u00f3fica en el documento <code>PEP 20</code> (Python Enhancement Proposal 20), que se puede obtener al ejecutar <code>import this</code> en un int\u00e9rprete de Python. Aqu\u00ed tienes algunas de las principales recomendaciones del Zen de Python:</p> <ol> <li><p>Legibilidad cuenta: El c\u00f3digo debe ser legible por los seres humanos y debe ser claro, conciso y f\u00e1cil de entender.</p> </li> <li><p>Expl\u00edcito es mejor que impl\u00edcito: Es preferible que el c\u00f3digo sea expl\u00edcito en lugar de depender de comportamientos impl\u00edcitos que pueden ser confusos.</p> </li> <li><p>Simple es mejor que complejo: Debes tratar de escribir c\u00f3digo sencillo en lugar de complejo. La simplicidad facilita la depuraci\u00f3n y el mantenimiento.</p> </li> <li><p>Plano es mejor que anidado: Evita anidar demasiados bloques de c\u00f3digo. Niveles excesivos de anidaci\u00f3n pueden hacer que el c\u00f3digo sea dif\u00edcil de seguir.</p> </li> <li><p>La legibilidad cuenta: Se repite la idea de que la legibilidad del c\u00f3digo es crucial. Si el c\u00f3digo es claro y legible, es m\u00e1s f\u00e1cil de mantener y depurar.</p> </li> <li><p>Los errores nunca deben pasar en silencio: Los errores o excepciones no deben ser ignorados. Deben manejarse de manera adecuada y, si es necesario, registrarse para su posterior an\u00e1lisis.</p> </li> <li><p>En la duda, sigue el Zen de Python: Cuando tengas dudas sobre c\u00f3mo escribir c\u00f3digo de Python, consulta el Zen de Python para obtener orientaci\u00f3n.</p> </li> <li><p>Hermoso es mejor que feo: Se fomenta la escritura de c\u00f3digo limpio y elegante en lugar de c\u00f3digo confuso o \"feo\".</p> </li> <li><p>Nunca te pases de listo: Evita escribir c\u00f3digo excesivamente complejo o trucos innecesarios. La claridad es m\u00e1s importante que la astucia.</p> </li> <li><p>La simplicidad vence a la complejidad: Enfrenta los problemas de manera sencilla y evita soluciones innecesariamente complicadas.</p> </li> </ol> <p>Estas son solo algunas de las recomendaciones del Zen de Python. Estas pautas ayudan a los programadores a escribir c\u00f3digo Python de manera consistente y a seguir buenas pr\u00e1cticas de programaci\u00f3n.</p>"},{"location":"buenas_practicas/#mas-consejos","title":"M\u00e1s consejos\u00b6","text":"<p>Los consejos que se presentan son de mucha utilidad si usted quiere llevar sus conociminetos de programaci\u00f3n al siguiente nivel, sin embargo, el contenido de cada uno amerita un curso por si solo. Se deja recomienda al lector seguir profundizando en estos temas.</p>"},{"location":"buenas_practicas/#entender-programacion-multiparadigma","title":"Entender programaci\u00f3n multiparadigma\u00b6","text":"<p>Python al ser multiparadigma, nos da una amplia gama de posibilidades de dise\u00f1ar nuestros c\u00f3digos. Dentro de estos se destacan:</p> <ul> <li>Programaci\u00f3n orientada a objetos (OOP)</li> <li>Programaci\u00f3n funcional</li> </ul> <p>Cu\u00e1ndo ocupar uno o la otra, va a depender de c\u00f3mo queremos abordar una determinada problem\u00e1tica, puesto que en la mayor\u00eda de los casos, se puede pasar de un paradigma a o otro (incluso mezclarlos de ser necesario).</p>"},{"location":"buenas_practicas/#principio-solid","title":"Principio S.O.L.I.D\u00b6","text":"<p>En ingenier\u00eda de software, SOLID (Single responsibility, Open-closed, Liskov substitution, Interface segregation and Dependency inversion) es un acr\u00f3nimo mnem\u00f3nico introducido por Robert C. Martin a comienzos de la d\u00e9cada del 2000 que representa cinco principios b\u00e1sicos de la programaci\u00f3n orientada a objetos y el dise\u00f1o. Cuando estos principios se aplican en conjunto es m\u00e1s probable que un desarrollador cree un sistema que sea f\u00e1cil de mantener y ampliar con el tiempo.</p> <p>En el siguiente link se deja una gu\u00eda para poder entender estos conceptos en python.</p>"},{"location":"buenas_practicas/#patrones-de-diseno","title":"Patrones de dise\u00f1o\u00b6","text":"<p>Los patrones de dise\u00f1o son la base para la b\u00fasqueda de soluciones a problemas comunes en el desarrollo de software y otros \u00e1mbitos referentes al dise\u00f1o de interacci\u00f3n o interfaces.</p> <p>Un patr\u00f3n de dise\u00f1o es una soluci\u00f3n a un problema de dise\u00f1o.</p> <p>Se destacan tres tipos de patrones de dise\u00f1os:</p> <ul> <li>Comportamiento</li> <li>Creacionales</li> <li>Estructurales</li> </ul> <p>En el siguiente link se deja una gu\u00eda para poder entender estos conceptos en python.</p>"},{"location":"buenas_practicas/#lecturas-recomendadas","title":"Lecturas recomendadas\u00b6","text":"<ul> <li><p>Clean Code: A Handbook of Agile Software - Robert C. Martin (2009): Habla sobre las buenas pr\u00e1cticas que debe seguir todo buen programador al momento de escribir su c\u00f3digo. Si bien el lenguaje de programaci\u00f3n emepleado es <code>Java</code>, la l\u00f3gica se extiende a cualquier lenguaje de programaci\u00f3n.</p> </li> <li><p>The Clean Coder: A Code Of Conduct For Professional Programmers Robert C. Martin (2011): Habla sobre las conductas que debe seguir todo programador. Adem\u00e1s de hablar aspectos t\u00e9cnicos como estimaci\u00f3n, dise\u00f1o de c\u00f3digo, refactorizaci\u00f3n y testeos, tambi\u00e9n nos habla sobre la actitud que un programador debe tener en distintas situaciones laborales.</p> </li> </ul>"},{"location":"buenas_practicas/#referencias","title":"Referencias\u00b6","text":"<ol> <li>clean-code-python</li> <li>Documenting Python Code: A Complete Guide</li> </ol>"},{"location":"error/","title":"Excepciones","text":"<p>Existen muchos tipos de errores que pueden estar presentes en un programa. No todos los errores pueden ser detectados por el computador. Veamos el siguiente ejemplo:</p> In\u00a0[1]: Copied! <pre># error semantico\nn = 4\ndoble = 3 * n\nprint(f'El doble de n es {doble}')\n</pre> # error semantico n = 4 doble = 3 * n print(f'El doble de n es {doble}') <pre>El doble de n es 12\n</pre> <p>El computador no se dar\u00e1 cuenta del error, pues todas las instrucciones del programa son correctas. El programa simplemente entregar\u00e1 siempre la respuesta equivocada.</p> <p>Existen otros errores que s\u00ed pueden ser detectados: las excepciones. Las excepciones son errores que se producen durante la ejecuci\u00f3n de un programa, como por ejemplo un error de sintaxis, un archivo que no se puede abrir o un valor que no se puede dividir por cero.</p> <ul> <li><p>Si no se manejan las excepciones, se imprime un mensaje de error y nuestro programa se detiene repentinamente e inesperadamente.</p> </li> <li><p>Existen varios tipos de  excepciones, sin embargo, en esta secci\u00f3n se presentan algunas de ellas.</p> </li> </ul> In\u00a0[2]: Copied! <pre># SyntaxError\n2 * (3 + 4))\n</pre> # SyntaxError 2 * (3 + 4)) <pre>\n  Input In [2]\n    2 * (3 + 4))\n               ^\nSyntaxError: unmatched ')'\n</pre> In\u00a0[3]: Copied! <pre># NameError\nx = 20\nx+y\n</pre> # NameError x = 20 x+y <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nInput In [3], in &lt;cell line: 3&gt;()\n      1 # NameError\n      2 x = 20\n----&gt; 3 x+y\n\nNameError: name 'y' is not defined</pre> In\u00a0[4]: Copied! <pre># type error\n'seis' * 'ocho'\n</pre> # type error 'seis' * 'ocho' <pre>\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nInput In [4], in &lt;cell line: 2&gt;()\n      1 # type error\n----&gt; 2 'seis' * 'ocho'\n\nTypeError: can't multiply sequence by non-int of type 'str'</pre> In\u00a0[5]: Copied! <pre># ValueError\nint('perro')\n</pre> # ValueError int('perro') <pre>\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nInput In [5], in &lt;cell line: 2&gt;()\n      1 # ValueError\n----&gt; 2 int('perro')\n\nValueError: invalid literal for int() with base 10: 'perro'</pre> In\u00a0[6]: Copied! <pre># ZeroDivisionError\n1/0\n</pre> # ZeroDivisionError 1/0 <pre>\n---------------------------------------------------------------------------\nZeroDivisionError                         Traceback (most recent call last)\nInput In [6], in &lt;cell line: 2&gt;()\n      1 # ZeroDivisionError\n----&gt; 2 1/0\n\nZeroDivisionError: division by zero</pre> In\u00a0[7]: Copied! <pre># OverflowError\n20.0 ** 20.0 ** 20.0\n</pre> # OverflowError 20.0 ** 20.0 ** 20.0 <pre>\n---------------------------------------------------------------------------\nOverflowError                             Traceback (most recent call last)\nInput In [7], in &lt;cell line: 2&gt;()\n      1 # OverflowError\n----&gt; 2 20.0 ** 20.0 ** 20.0\n\nOverflowError: (34, 'Result too large')</pre> In\u00a0[12]: Copied! <pre>def funcion(num):\n    if num &lt; 0:\n        raise ValueError(\"El valor no puede ser negativo\")\n    else:\n        return num\n</pre> def funcion(num):     if num &lt; 0:         raise ValueError(\"El valor no puede ser negativo\")     else:         return num <p>En este ejemplo, si el valor de <code>num</code> es negativo, se genera una excepci\u00f3n de tipo <code>ValueError</code> con el mensaje \"El valor no puede ser negativo\". De lo contrario, la funci\u00f3n devuelve el valor de <code>num</code>.</p> In\u00a0[13]: Copied! <pre>funcion(1)\n</pre> funcion(1) Out[13]: <pre>1</pre> In\u00a0[14]: Copied! <pre>funcion(-1)\n</pre> funcion(-1) <pre>\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nInput In [14], in &lt;cell line: 1&gt;()\n----&gt; 1 funcion(-1)\n\nInput In [12], in funcion(num)\n      1 def funcion(num):\n      2     if num &lt; 0:\n----&gt; 3         raise ValueError(\"El valor no puede ser negativo\")\n      4     else:\n      5         return num\n\nValueError: El valor no puede ser negativo</pre> <p>Conclusi\u00f3n</p> <p>Existen dos maneras para lanzar una excepci\u00f3n:</p> <ul> <li>Hacer una operaci\u00f3n que no puede ser realizada (como dividir por cero). En este caso Python se encarga de lanzar autom\u00e1ticamente la excepci\u00f3n.</li> <li>Lanzar nosotros una excepci\u00f3n manualmente, usando <code>raise</code>.</li> </ul> <p>Nota: El comando <code>raise</code> es \u00fatil cuando se desea interrumpir el flujo normal de un programa y provocar una excepci\u00f3n en un punto espec\u00edfico. Sin embargo, se debe utilizar con precauci\u00f3n, ya que puede dificultar la depuraci\u00f3n del programa si se utiliza en exceso o de manera incorrecta.</p> In\u00a0[10]: Copied! <pre>try:\n    x = 1 / 0\nexcept:\n    print(\"No se puede dividir entre cero\")\n</pre> try:     x = 1 / 0 except:     print(\"No se puede dividir entre cero\") <pre>No se puede dividir entre cero\n</pre> <p>En este ejemplo, se intenta dividir el n\u00famero <code>1</code> entre <code>0</code>. Como no se puede realizar la divisi\u00f3n, se produce una excepci\u00f3n de tipo <code>ZeroDivisionError</code>.</p> <p>Por otro lado, tambi\u00e9n se puede especificar en el <code>except</code> el tipo de error.</p> In\u00a0[11]: Copied! <pre>try:\n    x = 1 / 0\nexcept ZeroDivisionError:\n    print(\"No se puede dividir entre cero\")\n</pre> try:     x = 1 / 0 except ZeroDivisionError:     print(\"No se puede dividir entre cero\") <pre>No se puede dividir entre cero\n</pre> <p>Uso de else</p> <p>Al ya explicado <code>try</code> y <code>except</code> le podemos a\u00f1adir un bloque m\u00e1s, el <code>else</code>. Dicho bloque se ejecutar\u00e1 si no ha ocurrido ninguna excepci\u00f3n. F\u00edjate en la diferencia entre los siguientes c\u00f3digos.</p> In\u00a0[8]: Copied! <pre>try:\n    # Forzamos una excepci\u00f3n al dividir entre 0\n    x = 2/0\nexcept:\n    print(\"Entra en except, ha ocurrido una excepci\u00f3n\")\nelse:\n    print(\"Entra en else, no ha ocurrido ninguna excepci\u00f3n\")\n</pre> try:     # Forzamos una excepci\u00f3n al dividir entre 0     x = 2/0 except:     print(\"Entra en except, ha ocurrido una excepci\u00f3n\") else:     print(\"Entra en else, no ha ocurrido ninguna excepci\u00f3n\")  <pre>Entra en except, ha ocurrido una excepci\u00f3n\n</pre> <p>Sin embargo en el siguiente c\u00f3digo la divisi\u00f3n se puede realizar sin problema, por lo que el bloque <code>except</code> no se ejecuta pero el <code>else</code> si es ejecutado.</p> In\u00a0[9]: Copied! <pre>try:\n    # La divisi\u00f3n puede realizarse sin problema\n    x = 2/2\nexcept:\n    print(\"Entra en except, ha ocurrido una excepci\u00f3n\")\nelse:\n    print(\"Entra en else, no ha ocurrido ninguna excepci\u00f3n\")\n</pre> try:     # La divisi\u00f3n puede realizarse sin problema     x = 2/2 except:     print(\"Entra en except, ha ocurrido una excepci\u00f3n\") else:     print(\"Entra en else, no ha ocurrido ninguna excepci\u00f3n\") <pre>Entra en else, no ha ocurrido ninguna excepci\u00f3n\n</pre> In\u00a0[18]: Copied! <pre># Funcion suma de variables enteras\ndef suma(a, b):\n    assert(type(a) == int), \"el primer valor ingresado no es entero\"\n    assert(type(b) == int), \"el segundo valor ingresado no es entero\"\n    return a+b\n</pre> # Funcion suma de variables enteras def suma(a, b):     assert(type(a) == int), \"el primer valor ingresado no es entero\"     assert(type(b) == int), \"el segundo valor ingresado no es entero\"     return a+b In\u00a0[19]: Copied! <pre># Ok, los argumentos son int\nsuma(3, 5)\n</pre> # Ok, los argumentos son int suma(3, 5) Out[19]: <pre>8</pre> In\u00a0[20]: Copied! <pre># Error, ya que las variables no son int\nsuma(3.0, 5)\n</pre> # Error, ya que las variables no son int suma(3.0, 5) <pre>\n---------------------------------------------------------------------------\nAssertionError                            Traceback (most recent call last)\nInput In [20], in &lt;cell line: 2&gt;()\n      1 # Error, ya que las variables no son int\n----&gt; 2 suma(3.0, 5.0)\n\nInput In [18], in suma(a, b)\n      2 def suma(a, b):\n----&gt; 3     assert(type(a) == int), \"el primer valor ingresado no es entero\"\n      4     assert(type(b) == int), \"el segundo valor ingresado no es entero\"\n      5     return a+b\n\nAssertionError: el primer valor ingresado no es entero</pre> In\u00a0[21]: Copied! <pre># Error, ya que las variables no son int\nsuma(3, 5.0)\n</pre> # Error, ya que las variables no son int suma(3, 5.0) <pre>\n---------------------------------------------------------------------------\nAssertionError                            Traceback (most recent call last)\nInput In [21], in &lt;cell line: 2&gt;()\n      1 # Error, ya que las variables no son int\n----&gt; 2 suma(3, 5.0)\n\nInput In [18], in suma(a, b)\n      2 def suma(a, b):\n      3     assert(type(a) == int), \"el primer valor ingresado no es entero\"\n----&gt; 4     assert(type(b) == int), \"el segundo valor ingresado no es entero\"\n      5     return a+b\n\nAssertionError: el segundo valor ingresado no es entero</pre> In\u00a0[22]: Copied! <pre># definir funcion\ndef suma(x,y):\n    return x+y\n</pre> # definir funcion def suma(x,y):     return x+y In\u00a0[23]: Copied! <pre># ejemplo correcto\nassert suma(1,1)==2, \"ejemplo invalido\"\n</pre> # ejemplo correcto assert suma(1,1)==2, \"ejemplo invalido\" In\u00a0[24]: Copied! <pre># ejemplo incorrecto\nassert suma(1,1)==3, \"ejemplo invalido\"\n</pre> # ejemplo incorrecto assert suma(1,1)==3, \"ejemplo invalido\" <pre>\n---------------------------------------------------------------------------\nAssertionError                            Traceback (most recent call last)\nInput In [24], in &lt;cell line: 2&gt;()\n      1 # ejemplo incorrecto\n----&gt; 2 assert suma(1,1)==3, \"ejemplo invalido\"\n\nAssertionError: ejemplo invalido</pre> In\u00a0[24]: Copied! <pre>import warnings\n  \nprint('Python')\n  \n# mostrar un mensaje warning \nwarnings.warn('Atencion, esto es un warning!')\n  \nprint('Python!')\n</pre> import warnings    print('Python')    # mostrar un mensaje warning  warnings.warn('Atencion, esto es un warning!')    print('Python!') <pre>Python\nPython!\n</pre> <pre>C:\\Users\\franc\\AppData\\Local\\Temp\\ipykernel_3104\\3783018248.py:6: UserWarning: Atencion, esto es un warning!\n  warnings.warn('Atencion, esto es un warning!')\n</pre> <p>En este ejemplo, la funci\u00f3n <code>warn()</code> se utiliza para mostrar el mensajede advertencia: \"Atencion, esto es un warning!\".</p> <p>DeprecationWarning</p> <p>Es un tipo de advertencia que se utiliza para indicar que una caracter\u00edstica o funci\u00f3n del lenguaje o biblioteca que se est\u00e1 utilizando est\u00e1 obsoleta y se eliminar\u00e1 en futuras versiones. Esta advertencia se emite para permitir que los desarrolladores sepan que deben dejar de utilizar la funci\u00f3n o caracter\u00edstica en cuesti\u00f3n para evitar errores y fallos en futuras versiones de Python.</p> <p>El objetivo principal es ayudar a los desarrolladores a actualizar su c\u00f3digo para usar las nuevas funciones y caracter\u00edsticas que reemplazan las obsoletas. Si no se actualiza el c\u00f3digo, es posible que no funcione correctamente en futuras versiones de Python.</p> <p>Veamos un ejemplo:</p> In\u00a0[5]: Copied! <pre>import warnings\n\ndef multiplicar_por_dos(numero):\n    warnings.warn(\"Esta funci\u00f3n est\u00e1 obsoleta, use multiplicar_por_n en su lugar\", DeprecationWarning)\n    return numero * 2\n\ndef multiplicar_por_n(numero, n):\n    return numero * n\n\nresultado = multiplicar_por_dos(5)\nprint(\"El resultado es:\", resultado)\n\nresultado = multiplicar_por_n(5, 3)\nprint(\"El resultado es:\", resultado)\n</pre> import warnings  def multiplicar_por_dos(numero):     warnings.warn(\"Esta funci\u00f3n est\u00e1 obsoleta, use multiplicar_por_n en su lugar\", DeprecationWarning)     return numero * 2  def multiplicar_por_n(numero, n):     return numero * n  resultado = multiplicar_por_dos(5) print(\"El resultado es:\", resultado)  resultado = multiplicar_por_n(5, 3) print(\"El resultado es:\", resultado) <pre>El resultado es: 10\nEl resultado es: 15\n</pre> <pre>C:\\Users\\franc\\AppData\\Local\\Temp\\ipykernel_3104\\372299459.py:4: DeprecationWarning: Esta funci\u00f3n est\u00e1 obsoleta, use multiplicar_por_n en su lugar\n  warnings.warn(\"Esta funci\u00f3n est\u00e1 obsoleta, use multiplicar_por_n en su lugar\", DeprecationWarning)\n</pre> <p>En este ejemplo, la funci\u00f3n <code>multiplicar_por_dos</code> se ha quedado obsoleta y se emitir\u00e1 una advertencia de tipo <code>DeprecationWarning</code> cuando se llame. La advertencia indicar\u00e1 que la funci\u00f3n est\u00e1 obsoleta y que los desarrolladores deber\u00edan usar la funci\u00f3n <code>multiplicar_por_n</code> en su lugar.</p> <p>FutureWarning</p> <p>Es un tipo de advertencia que se utiliza para indicar que una caracter\u00edstica o comportamiento del lenguaje o biblioteca puede cambiar en futuras versiones de Python. A diferencia de <code>DeprecationWarning</code>, <code>FutureWarning</code> no indica que una caracter\u00edstica est\u00e1 obsoleta y se eliminar\u00e1 en futuras versiones, sino que simplemente indica que la forma en que se comporta actualmente podr\u00eda cambiar en el futuro.</p> <p>Veamos un ejemplo:</p> In\u00a0[11]: Copied! <pre>import warnings\n\ndef sumar(a, b):\n    warnings.warn(\"La funci\u00f3n sumar puede cambiar en futuras versiones\", FutureWarning)\n    return a + b\n\nresultado = sumar(2, 3)\nprint(\"El resultado es:\", resultado)\n</pre> import warnings  def sumar(a, b):     warnings.warn(\"La funci\u00f3n sumar puede cambiar en futuras versiones\", FutureWarning)     return a + b  resultado = sumar(2, 3) print(\"El resultado es:\", resultado) <pre>El resultado es: 5\n</pre> <pre>C:\\Users\\franc\\AppData\\Local\\Temp\\ipykernel_3104\\680115990.py:4: FutureWarning: La funci\u00f3n sumar puede cambiar en futuras versiones\n  warnings.warn(\"La funci\u00f3n sumar puede cambiar en futuras versiones\", FutureWarning)\n</pre> <p>En este ejemplo, la funci\u00f3n <code>sumar</code> puede cambiar en futuras versiones, y se emite una advertencia de tipo <code>FutureWarning</code> al llamarla. La advertencia indica que la funci\u00f3n podr\u00eda cambiar en el futuro, lo que significa que el resultado podr\u00eda ser diferente en una versi\u00f3n posterior de Python.</p> <p>RuntimeWarning</p> <p>Es un tipo de advertencia que se utiliza para indicar que se ha producido un comportamiento inesperado durante la ejecuci\u00f3n del programa. A diferencia de las excepciones, que son errores que interrumpen la ejecuci\u00f3n del programa, las advertencias <code>RuntimeWarning</code> no interrumpen la ejecuci\u00f3n, sino que simplemente indican que se ha producido un comportamiento inesperado.</p> <p>Veamos un ejemplo:</p> In\u00a0[22]: Copied! <pre>import numpy as np\nresult = 1/(1+np.exp(1140))\nprint(result)\n</pre> import numpy as np result = 1/(1+np.exp(1140)) print(result) <pre>0.0\n</pre> <pre>C:\\Users\\franc\\AppData\\Local\\Temp\\ipykernel_3104\\3819922338.py:2: RuntimeWarning: overflow encountered in exp\n  result = 1/(1+np.exp(1140))\n</pre> <p>En este ejemplo, <code>NumPy</code> realiza el c\u00e1lculo (el resultado es <code>0,0</code>) pero a\u00fan imprime <code>RuntimeWarning</code>. Esta advertencia se imprime porque el valor <code>np.exp(1140)</code> representa $e^{1140}$, que es un n\u00famero muy grande.</p> <p>UserWarning</p> <p>Es un tipo de advertencia que se utiliza para indicar que se ha detectado una situaci\u00f3n que puede no ser un error grave, pero que podr\u00eda ser importante para el usuario final del programa.</p> <p>A diferencia de otras advertencias, como <code>DeprecationWarning</code> o <code>RuntimeWarning</code>, que se refieren a problemas t\u00e9cnicos en el c\u00f3digo, <code>UserWarning</code> se utiliza para indicar al usuario que se ha producido una situaci\u00f3n que puede requerir su atenci\u00f3n o acci\u00f3n.</p> <p>Veamos un ejemplo:</p> In\u00a0[14]: Copied! <pre>import warnings\n\ndef promedio_notas(notas):\n    if not notas:\n        warnings.warn(\"La lista de notas est\u00e1 vac\u00eda\", UserWarning)\n        return None\n    else:\n        return sum(notas) / len(notas)\n\nnotas_estudiante = [7, 8, 6]\npromedio = promedio_notas(notas_estudiante)\nprint(\"El promedio de notas es:\", promedio)\n\nnotas_estudiante_vacias = []\npromedio = promedio_notas(notas_estudiante_vacias)\nprint(\"El promedio de notas es:\", promedio)\n</pre> import warnings  def promedio_notas(notas):     if not notas:         warnings.warn(\"La lista de notas est\u00e1 vac\u00eda\", UserWarning)         return None     else:         return sum(notas) / len(notas)  notas_estudiante = [7, 8, 6] promedio = promedio_notas(notas_estudiante) print(\"El promedio de notas es:\", promedio)  notas_estudiante_vacias = [] promedio = promedio_notas(notas_estudiante_vacias) print(\"El promedio de notas es:\", promedio)  <pre>El promedio de notas es: 7.0\nEl promedio de notas es: None\n</pre> <pre>C:\\Users\\franc\\AppData\\Local\\Temp\\ipykernel_3104\\3670255427.py:5: UserWarning: La lista de notas est\u00e1 vac\u00eda\n  warnings.warn(\"La lista de notas est\u00e1 vac\u00eda\", UserWarning)\n</pre> <p>En este ejemplo, la funci\u00f3n <code>promedio_notas</code> calcula el promedio de un conjunto de notas. Si la lista de notas est\u00e1 vac\u00eda, en lugar de devolver un error, se emite una advertencia utilizando el m\u00f3dulo warnings de Python con el mensaje \"La lista de notas est\u00e1 vac\u00eda\" y el tipo de advertencia <code>UserWarning</code>. Luego, la funci\u00f3n devuelve <code>None</code>.</p>"},{"location":"error/#excepciones","title":"Excepciones\u00b6","text":""},{"location":"error/#introduccion","title":"Introducci\u00f3n\u00b6","text":""},{"location":"error/#tipos-de-errores","title":"Tipos de Errores\u00b6","text":""},{"location":"error/#error-de-sintaxis","title":"Error de sintaxis\u00b6","text":"<p>Un error de sintaxis ocurre cuando el programa no cumple las reglas del lenguaje. Cuando ocurre este error, significa que el programa est\u00e1 mal escrito. El nombre del error es <code>SyntaxError</code>.</p>"},{"location":"error/#error-de-nombre","title":"Error de nombre\u00b6","text":"<p>Un error de nombre ocurre al usar una variable que no ha sido creada con anterioridad. El nombre de la excepci\u00f3n es <code>NameError</code>.</p>"},{"location":"error/#error-de-tipo","title":"Error de tipo\u00b6","text":"<p>En general, todas las operaciones en un programa pueden ser aplicadas sobre valores de tipos bien espec\u00edficos. Un error de tipo ocurre al aplicar una operaci\u00f3n sobre operandos de tipo incorrecto.</p> <p>El nombre de la excepci\u00f3n es <code>TypeError</code>.</p>"},{"location":"error/#error-de-valor","title":"Error de valor\u00b6","text":"<p>El error de valor ocurre cuando los operandos son del tipo correcto, pero la operaci\u00f3n no tiene sentido para ese valor. El nombre de la excepci\u00f3n es <code>ValueError</code>.</p>"},{"location":"error/#error-de-division-por-cero","title":"Error de divisi\u00f3n por cero\u00b6","text":"<p>El error de division por cero ocurre al intentar dividir por cero. El nombre de la excepci\u00f3n es <code>ZeroDivisionError</code>:</p>"},{"location":"error/#error-de-desborde","title":"Error de desborde\u00b6","text":"<p>El error de desborde ocurre cuando el resultado de una operaci\u00f3n es tan grande que el computador no puede representarlo internamente.</p> <p>El nombre de la excepci\u00f3n es <code>OverflowError</code>.</p>"},{"location":"error/#raise","title":"Raise\u00b6","text":"<p>En Python, el comando <code>raise</code> se emplea para generar excepciones de forma deliberada en un programa. En otras palabras, permite al programador desencadenar una excepci\u00f3n en un momento espec\u00edfico del programa en lugar de esperar a que ocurra de manera autom\u00e1tica.</p> <p>La sintaxis del comando <code>raise</code> es la siguiente:</p> <pre>raise ExceptionType(\"Mensaje de error\")\n</pre> <p>En esta sintaxis, <code>ExceptionType</code> se refiere al tipo de excepci\u00f3n que se desea desencadenar, y <code>\"Mensaje de error\"</code> es un mensaje opcional que proporciona informaci\u00f3n adicional sobre la excepci\u00f3n.</p> <p>Por ejemplo, supongamos que deseas generar una excepci\u00f3n de tipo <code>ValueError</code> cuando te encuentres con un valor num\u00e9rico negativo. Puedes lograrlo de la siguiente manera:</p>"},{"location":"error/#menajando-excepciones-tryexcept","title":"Menajando excepciones: Try/Except\u00b6","text":"<p>En Python, las excepciones se pueden manejar usando la declaraci\u00f3n <code>try</code>. Cuando se detectan excepciones, depende de usted qu\u00e9 operador realizar.</p>"},{"location":"error/#aserciones-en-python","title":"Aserciones en python\u00b6","text":"<p>Las aserciones  son expresiones booleanas que comprueban si las condiciones devuelven verdaderas o no. Si es cierto, el programa no hace nada y pasa a la siguiente l\u00ednea de c\u00f3digo. Sin embargo, si es falso, el programa se detiene y arroja un error.</p> <p>Las aserciones son importantes al momento de realizar tests unitarios o asegurar que un resultado siempre sea el mismo.</p> <p></p>"},{"location":"error/#assert-en-funciones","title":"assert en funciones\u00b6","text":"<p>Puede resultar \u00fatil usar <code>assert(</code>) cuando queremos realizar alguna comprobaci\u00f3n, como podr\u00eda ser dentro de una funci\u00f3n. En el siguiente ejemplo tenemos una funci\u00f3n <code>suma()</code> que s\u00f3lo suma las variables si son n\u00fameros enteros.</p>"},{"location":"error/#assert-en-testing","title":"assert en testing\u00b6","text":"<p>La funci\u00f3n <code>assert()</code> puede ser tambi\u00e9n muy \u00fatil para escribir tests unitarios o units tests. Veamos un ejemplo.</p>"},{"location":"error/#warnings","title":"Warnings\u00b6","text":"<p>En Python, un warnings es un mensaje que se muestra en la consola o en el registro de errores durante la ejecuci\u00f3n del c\u00f3digo para alertar al programador sobre un posible problema o una situaci\u00f3n inusual que podr\u00eda resultar en un error o un comportamiento no deseado en el programa.</p> <p>A diferencia de los errores (que interrumpen la ejecuci\u00f3n del programa), los warnings son mensajes informativos que no impiden la ejecuci\u00f3n del c\u00f3digo, pero deben ser revisados y atendidos por el programador para garantizar la calidad del software.</p> <p>Por ejemplo, Python puede mostrar una advertencia si est\u00e1s utilizando una funci\u00f3n que se ha quedado obsoleta o que ser\u00e1 eliminada en futuras versiones de Python, o si est\u00e1s realizando una operaci\u00f3n que puede tener efectos secundarios no deseados.</p> <p>Es importante prestar atenci\u00f3n a las advertencias y abordarlas en consecuencia para asegurarse de que el c\u00f3digo funcione de manera correcta y eficiente.</p> <p>Veamos un ejemplo:</p>"},{"location":"error/#tipos-de-warnings","title":"Tipos de Warnings\u00b6","text":""},{"location":"error/#referencias","title":"Referencias\u00b6","text":"<ul> <li>Manejo de excepciones y errores en Python</li> </ul>"},{"location":"estructura/","title":"Estructura de datos","text":"<p>Son una utilidad de Python dispuesta para almacenar y guardar cualquier tipo de Dato, tanto as\u00ed que pueden contenerse entre s\u00ed. Cada una posee un tipo de par\u00e9ntesis, o comillas en el caso de los strings, siendo f\u00e1cil diferenciarlos unos de otro.</p> <ul> <li><p>Strings <code>\u2018 \u2019</code> : Representan texto , siendo una cadena ordenada de caracteres y un tipo de dato, como los n\u00fameros y booleanos, pero con una complejidad mayor al ser tambi\u00e9n una estructura. Pueden estar entre comillas \u2018simples\u2019 o \u201cdobles\u201d.</p> </li> <li><p>Listas <code>[ ]</code> : Son una cadena ordenada de datos, los cuales, al igual que en los strings y tuplas, tienen la relaci\u00f3n dato-posici\u00f3n.</p> </li> <li><p>Tuplas <code>( )</code>: Son una cadena ordenada de datos, pero a diferencia de las listas, y al igual que los strings, es inmutable, es decir, no se puede modificar.</p> </li> <li><p>Diccionarios <code>{ : }</code> : Son un conjunto de pares de datos que se caracteriza por utilizar una relaci\u00f3n llave-dato. Debido a esto no necesitan orden, ya que al tener una llave se puede sacar su dato relacionado.</p> </li> </ul> <p>Las estructuras de datos de string ya fueron estudiados en secciones pasada. En esta secci\u00f3n nos centraremos en las estructuras de Listas, Tuplas y Diccionarios.</p> In\u00a0[1]: Copied! <pre># lista vacia (Usando corchetes)\nlista = []\nprint(lista)\n</pre> # lista vacia (Usando corchetes) lista = [] print(lista) <pre>[]\n</pre> In\u00a0[2]: Copied! <pre># lista vacia (Usando el constructor)\nlista = list()\nprint(lista)\n</pre> # lista vacia (Usando el constructor) lista = list() print(lista) <pre>[]\n</pre> In\u00a0[3]: Copied! <pre># lista de enteros\nlista = [1, 2, 3]\nprint(lista)\n</pre> # lista de enteros lista = [1, 2, 3] print(lista) <pre>[1, 2, 3]\n</pre> In\u00a0[4]: Copied! <pre># lista mixta\nlista = [1, \"hola\", 3.4]\nprint(lista)\n</pre> # lista mixta lista = [1, \"hola\", 3.4] print(lista) <pre>[1, 'hola', 3.4]\n</pre> In\u00a0[7]: Copied! <pre>colores = ['azul', 'rojo', 'verde', 'amarillo']\nprint(len(colores))\n</pre> colores = ['azul', 'rojo', 'verde', 'amarillo'] print(len(colores)) <pre>4\n</pre> <p>Acceder al \u00edndice</p> <p><code>l[i]</code> entrega el i-\u00e9simo valor de la lista. El valor $i$ se llama \u00edndice del valor. Al igual que para los strings, los \u00edndices parten de cero:</p> In\u00a0[1]: Copied! <pre>colores = ['azul', 'rojo', 'verde', 'amarillo']\nprint(f'primer elemento de la lista: {colores[0]}')\nprint(f'tercer elemento de la lista: {colores[2]}')\n</pre> colores = ['azul', 'rojo', 'verde', 'amarillo'] print(f'primer elemento de la lista: {colores[0]}') print(f'tercer elemento de la lista: {colores[2]}') <pre>primer elemento de la lista: azul\ntercer elemento de la lista: verde\n</pre> In\u00a0[12]: Copied! <pre># elemento fuera de la lista\nprint( colores[4])\n</pre> # elemento fuera de la lista print( colores[4]) <pre>\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\n&lt;ipython-input-12-f7eb673eabf2&gt; in &lt;module&gt;\n      1 # elemento fuera de la lista\n----&gt; 2 print( colores[4])\n\nIndexError: list index out of range</pre> <p>\u00cdndice negativo</p> <p>Si el \u00edndice es negativo, los elementos se cuentan desde el final hacia atr\u00e1s:</p> In\u00a0[14]: Copied! <pre>colores = ['azul', 'rojo', 'verde', 'amarillo']\nprint(colores[-1])\n</pre> colores = ['azul', 'rojo', 'verde', 'amarillo'] print(colores[-1]) <pre>amarillo\n</pre> <p>Agregar un elemento</p> <p><code>l.append(x)</code> agrega el elemento x al final de la lista:</p> In\u00a0[15]: Copied! <pre>primos = [2, 3, 5, 7, 11]\nprimos.append(13)\nprint(primos)\n</pre> primos = [2, 3, 5, 7, 11] primos.append(13) print(primos) <pre>[2, 3, 5, 7, 11, 13]\n</pre> <p>Concatenar dos listas</p> <p><code>l1</code> + <code>l2</code> concatena las listas <code>l1</code> y <code>l2</code>:</p> In\u00a0[16]: Copied! <pre>l1 = [1,2,3]\nl2 = [4,5,6]\n\nprint(l1+l2)\n</pre> l1 = [1,2,3] l2 = [4,5,6]  print(l1+l2) <pre>[1, 2, 3, 4, 5, 6]\n</pre> <p>Repetir lista</p> <p><code>l * n</code> repite $n$ veces la lista <code>l</code>:</p> In\u00a0[17]: Copied! <pre>lista = [1,2,3]\nprint(2*lista)\n</pre> lista = [1,2,3] print(2*lista) <pre>[1, 2, 3, 1, 2, 3]\n</pre> <p>Elemento en una lista</p> <p>Para saber si un elemento x est\u00e1 en la lista <code>l</code>, se usa <code>x in l</code>. La versi\u00f3n negativa de <code>in</code> es <code>not in</code>:</p> In\u00a0[2]: Copied! <pre>lista = [1,2,3,4,5,6,7,8,9]\n\nprint(12 in lista)\n</pre> lista = [1,2,3,4,5,6,7,8,9]  print(12 in lista) <pre>False\n</pre> In\u00a0[3]: Copied! <pre>print(12 not in lista)\n</pre> print(12 not in lista) <pre>True\n</pre> <p>Operador rebanado</p> <p><code>l[i:j]</code> es el operador de rebanado, que entrega una nueva lista que tiene desde el i-\u00e9simo hasta justo antes del j-\u00e9simo elemento de la lista l:</p> In\u00a0[22]: Copied! <pre>l = [1.5, 3.3, 8.4, 3.1, 2.9]\nprint(l[2:4])\n</pre> l = [1.5, 3.3, 8.4, 3.1, 2.9] print(l[2:4]) <pre>[8.4, 3.1]\n</pre> <p>Operador \u00edndice</p> <p><code>l.index(x)</code> entrega cu\u00e1l es el \u00edndice del valor x:</p> In\u00a0[26]: Copied! <pre>colores = ['azul', 'rojo', 'verde', 'amarillo']\nprint(colores.index('verde'))\n</pre> colores = ['azul', 'rojo', 'verde', 'amarillo'] print(colores.index('verde')) <pre>2\n</pre> <p>Operador remover</p> <p><code>l.remove(x)</code> elimina el elemento x de la lista:</p> In\u00a0[27]: Copied! <pre>l = [7, 0, 3, 9, 8, 2, 4]\nl.remove(2)\nprint(l)\n</pre> l = [7, 0, 3, 9, 8, 2, 4] l.remove(2) print(l) <pre>[7, 0, 3, 9, 8, 4]\n</pre> <p>Operador borrar</p> <p><code>del l[i]</code> elimina el i-\u00e9simo elemento de la lista:</p> In\u00a0[28]: Copied! <pre>l = [7, 0, 3, 9, 8, 2, 4]\ndel l[2]\nprint(l)\n</pre> l = [7, 0, 3, 9, 8, 2, 4] del l[2] print(l) <pre>[7, 0, 9, 8, 2, 4]\n</pre> <p>Operador reversa</p> <p><code>l.reverse()</code> invierte la lista:</p> In\u00a0[29]: Copied! <pre>l = [7, 0, 3, 9, 8, 2, 4]\nl.reverse()\nprint(l)\n</pre> l = [7, 0, 3, 9, 8, 2, 4] l.reverse() print(l) <pre>[4, 2, 8, 9, 3, 0, 7]\n</pre> <p>Operador ordenar</p> <p><code>l.sort()</code> ordena la lista:</p> In\u00a0[30]: Copied! <pre>l = [7, 0, 3, 9, 8, 2, 4]\nl.sort()\nprint(l)\n</pre> l = [7, 0, 3, 9, 8, 2, 4] l.sort() print(l) <pre>[0, 2, 3, 4, 7, 8, 9]\n</pre> In\u00a0[5]: Copied! <pre># Definimos una lista llamada 'valores' con algunos n\u00fameros\nvalores = [1, 2, 3, 4, 5]\n\n# Usamos un ciclo 'for' para recorrer cada elemento de la lista\nfor i in valores:\n    # En cada iteraci\u00f3n, 'i' toma el valor de un elemento de la lista\n    # y calculamos su cuadrado utilizando el operador '**'\n    cuadrado = i ** 2\n\n    # Luego, imprimimos el valor y su cuadrado en la consola\n    print(f\"El cuadrado de {i} es {cuadrado}\")\n</pre> # Definimos una lista llamada 'valores' con algunos n\u00fameros valores = [1, 2, 3, 4, 5]  # Usamos un ciclo 'for' para recorrer cada elemento de la lista for i in valores:     # En cada iteraci\u00f3n, 'i' toma el valor de un elemento de la lista     # y calculamos su cuadrado utilizando el operador '**'     cuadrado = i ** 2      # Luego, imprimimos el valor y su cuadrado en la consola     print(f\"El cuadrado de {i} es {cuadrado}\") <pre>El cuadrado de 1 es 1\nEl cuadrado de 2 es 4\nEl cuadrado de 3 es 9\nEl cuadrado de 4 es 16\nEl cuadrado de 5 es 25\n</pre> <ol> <li><p>Creamos una lista llamada <code>valores</code> que contiene los n\u00fameros <code>[1, 2, 3, 4, 5]</code>. Esta ser\u00e1 la lista que recorreremos.</p> </li> <li><p>Utilizamos un ciclo <code>for</code> para iterar a trav\u00e9s de cada elemento de la lista. En cada iteraci\u00f3n, la variable <code>i</code> toma el valor del siguiente elemento de la lista.</p> </li> <li><p>Dentro del ciclo <code>for</code>, calculamos el cuadrado de <code>i</code> usando el operador <code>**</code> y almacenamos el resultado en la variable <code>cuadrado</code>.</p> </li> <li><p>Finalmente, imprimimos en la consola un mensaje que muestra el n\u00famero original (<code>i</code>) y su cuadrado (<code>cuadrado</code>) utilizando una f-string.</p> </li> </ol> In\u00a0[10]: Copied! <pre># tupla vacia (Usando corchetes)\ntupla = ()\nprint(tupla)\n</pre> # tupla vacia (Usando corchetes) tupla = () print(tupla) <pre>()\n</pre> In\u00a0[11]: Copied! <pre># tupla vacia (Usando el constructor)\ntupla = tuple()\nprint(tupla)\n</pre> # tupla vacia (Usando el constructor) tupla = tuple() print(tupla) <pre>()\n</pre> In\u00a0[12]: Copied! <pre># tupla con elementos\nnumeros = (\"uno\", \"dos\", \"tres\", \"cuatro\")\nprint(numeros)\n</pre> # tupla con elementos numeros = (\"uno\", \"dos\", \"tres\", \"cuatro\") print(numeros) <pre>('uno', 'dos', 'tres', 'cuatro')\n</pre> In\u00a0[3]: Copied! <pre>persona = ('Javier', 'Perez')\nnombre, apellido = persona\nprint(nombre, apellido)\n</pre> persona = ('Javier', 'Perez') nombre, apellido = persona print(nombre, apellido) <pre>Javier Perez\n</pre> <p>Si se intenta desempaquetar una cantidad incorrecta de valores, ocurre un error de valor:</p> In\u00a0[4]: Copied! <pre>a, b, c = persona\n</pre> a, b, c = persona <pre>\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\n&lt;ipython-input-4-998bf8320296&gt; in &lt;module&gt;\n----&gt; 1 a, b, c = persona\n\nValueError: not enough values to unpack (expected 3, got 2)</pre> In\u00a0[5]: Copied! <pre>(1, 2) == (2 / 2, 1 + 1)\n</pre> (1, 2) == (2 / 2, 1 + 1) Out[5]: <pre>True</pre> In\u00a0[6]: Copied! <pre>(6, 1) == (6, 2)\n</pre> (6, 1) == (6, 2) Out[6]: <pre>False</pre> <p>Para determinar si una tupla es menor que otra, se utiliza lo que se denomina orden lexicogr\u00e1fico. Si los elementos en la primera posici\u00f3n de ambas tuplas son distintos, ellos determinan el ordenamiento de las tuplas:</p> In\u00a0[7]: Copied! <pre>(1, 4, 7) &lt; (2, 0, 0, 1)\n</pre> (1, 4, 7) &lt; (2, 0, 0, 1) Out[7]: <pre>True</pre> In\u00a0[8]: Copied! <pre>(1, 9, 10) &lt; (0, 5)\n</pre> (1, 9, 10) &lt; (0, 5) Out[8]: <pre>False</pre> In\u00a0[\u00a0]: Copied! <pre>numeros = (\"uno\", \"dos\", \"tres\", \"cuatro\")\n\nprint(numeros[1]) #Output: dos\nprint(numeros[3]) #Output: cuatro\nprint(numeros[-1]) # Output: cuatro\n</pre> numeros = (\"uno\", \"dos\", \"tres\", \"cuatro\")  print(numeros[1]) #Output: dos print(numeros[3]) #Output: cuatro print(numeros[-1]) # Output: cuatro In\u00a0[6]: Copied! <pre># Definimos una tupla con algunos n\u00fameros\ntupla_valores = (1, 2, 3, 4, 5)\n\n# Usamos un ciclo 'for' para recorrer cada elemento de la tupla\nfor valor in tupla_valores:\n    # En cada iteraci\u00f3n, 'valor' toma el valor de un elemento de la tupla\n    # y calculamos su cuadrado utilizando el operador '**'\n    cuadrado = valor ** 2\n\n    # Luego, imprimimos el valor y su cuadrado en la consola\n    print(f\"El cuadrado de {valor} es {cuadrado}\")\n</pre> # Definimos una tupla con algunos n\u00fameros tupla_valores = (1, 2, 3, 4, 5)  # Usamos un ciclo 'for' para recorrer cada elemento de la tupla for valor in tupla_valores:     # En cada iteraci\u00f3n, 'valor' toma el valor de un elemento de la tupla     # y calculamos su cuadrado utilizando el operador '**'     cuadrado = valor ** 2      # Luego, imprimimos el valor y su cuadrado en la consola     print(f\"El cuadrado de {valor} es {cuadrado}\") <pre>El cuadrado de 1 es 1\nEl cuadrado de 2 es 4\nEl cuadrado de 3 es 9\nEl cuadrado de 4 es 16\nEl cuadrado de 5 es 25\n</pre> <p>Convertir Entre Listas y Tuplas</p> <p>En Python, puedes convertir una tupla en una lista utilizando la funci\u00f3n <code>list()</code> y una lista en una tupla utilizando la funci\u00f3n <code>tuple()</code>. Esto es \u00fatil cuando necesitas cambiar el tipo de contenedor de datos. A continuaci\u00f3n, te proporciono ejemplos para ilustrar ambos casos:</p> <p>Convertir una Tupla en una Lista:</p> In\u00a0[8]: Copied! <pre># Definimos una tupla\nmi_tupla = (1, 2, 3, 4, 5)\n\n# Usamos la funci\u00f3n 'list()' para convertir la tupla en una lista\nmi_lista = list(mi_tupla)\n\n# Imprimimos la lista resultante\nprint(\"Tupla original:\", mi_tupla)\nprint(\"Lista resultante:\", mi_lista)\n</pre> # Definimos una tupla mi_tupla = (1, 2, 3, 4, 5)  # Usamos la funci\u00f3n 'list()' para convertir la tupla en una lista mi_lista = list(mi_tupla)  # Imprimimos la lista resultante print(\"Tupla original:\", mi_tupla) print(\"Lista resultante:\", mi_lista) <pre>Tupla original: (1, 2, 3, 4, 5)\nLista resultante: [1, 2, 3, 4, 5]\n</pre> <p>Convertir una Lista en una Tupla:</p> In\u00a0[9]: Copied! <pre># Definimos una lista\nmi_lista = [1, 2, 3, 4, 5]\n\n# Usamos la funci\u00f3n 'tuple()' para convertir la lista en una tupla\nmi_tupla = tuple(mi_lista)\n\n# Imprimimos la tupla resultante\nprint(\"Lista original:\", mi_lista)\nprint(\"Tupla resultante:\", mi_tupla)\n</pre> # Definimos una lista mi_lista = [1, 2, 3, 4, 5]  # Usamos la funci\u00f3n 'tuple()' para convertir la lista en una tupla mi_tupla = tuple(mi_lista)  # Imprimimos la tupla resultante print(\"Lista original:\", mi_lista) print(\"Tupla resultante:\", mi_tupla) <pre>Lista original: [1, 2, 3, 4, 5]\nTupla resultante: (1, 2, 3, 4, 5)\n</pre> In\u00a0[13]: Copied! <pre># conjunto vacio (Usando corchetes)\nconjunto = {}\nprint(conjunto)\n</pre> # conjunto vacio (Usando corchetes) conjunto = {} print(conjunto) <pre>{}\n</pre> In\u00a0[14]: Copied! <pre># conjunto vacio (Usando el constructor)\nconjunto = set()\nprint(conjunto)\n</pre> # conjunto vacio (Usando el constructor) conjunto = set() print(conjunto) <pre>set()\n</pre> In\u00a0[33]: Copied! <pre># usar un conjunto literal, entre llave \nconjunto = {1, 2, 3}\nprint(conjunto)\n</pre> # usar un conjunto literal, entre llave  conjunto = {1, 2, 3} print(conjunto) <pre>{1, 2, 3}\n</pre> In\u00a0[32]: Copied! <pre># set aplicada sobre un iterable\nconjunto = set([1, 2, 3])\nprint(conjunto)\n</pre> # set aplicada sobre un iterable conjunto = set([1, 2, 3]) print(conjunto) <pre>{1, 2, 3}\n</pre> <p>Los elementos de un conjunto deben ser inmutables. Por ejemplo, no es posible crear un conjunto de listas, pero s\u00ed un conjunto de tuplas:</p> In\u00a0[34]: Copied! <pre>conjunto = {[2, 4], [6, 1]}\n</pre> conjunto = {[2, 4], [6, 1]} <pre>\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n&lt;ipython-input-34-c1f516a9affc&gt; in &lt;module&gt;\n----&gt; 1 s = {[2, 4], [6, 1]}\n\nTypeError: unhashable type: 'list'</pre> <p>Como un conjunto no es ordenado, no tiene sentido intentar obtener un elemento usando un \u00edndice:</p> In\u00a0[35]: Copied! <pre>conjunto = {'a', 'b', 'c'}\nconjunto[0]\n</pre> conjunto = {'a', 'b', 'c'} conjunto[0] <pre>\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n&lt;ipython-input-35-501605a4a770&gt; in &lt;module&gt;\n      1 conjunto = {'a', 'b', 'c'}\n----&gt; 2 conjunto[0]\n\nTypeError: 'set' object is not subscriptable</pre> <p>Sin embargo, s\u00ed es posible iterar sobre un conjunto usando un ciclo for:</p> In\u00a0[36]: Copied! <pre>conjunto = {'a', 'b', 'c'}\nfor i in conjunto:\n    print(i)\n</pre> conjunto = {'a', 'b', 'c'} for i in conjunto:     print(i) <pre>a\nc\nb\n</pre> <p>Largo del conjunto <code>len(s)</code> entrega el n\u00famero de elementos del conjunto s:</p> In\u00a0[37]: Copied! <pre>len({'azul', 'verde', 'rojo'})\n</pre> len({'azul', 'verde', 'rojo'}) Out[37]: <pre>3</pre> <p>Elementos en el conjunto</p> <p><code>x in s</code> permite saber si el elemento x est\u00e1 en el conjunto s:</p> In\u00a0[38]: Copied! <pre>3 in {2, 3, 4}\n</pre> 3 in {2, 3, 4} Out[38]: <pre>True</pre> <p><code>x not in s</code> permite saber si x no est\u00e1 en s:</p> In\u00a0[39]: Copied! <pre>3 not in {2, 3, 4}\n</pre> 3 not in {2, 3, 4} Out[39]: <pre>False</pre> <p>Agregar elementos al conjunto</p> <p><code>s.add(x)</code> agrega el elemento x al conjunto s:</p> In\u00a0[40]: Copied! <pre>s = {6, 1, 5, 4, 3}\ns.add(-37)\ns\n</pre> s = {6, 1, 5, 4, 3} s.add(-37) s Out[40]: <pre>{-37, 1, 3, 4, 5, 6}</pre> <p>Remover elementos al conjunto</p> <p><code>s.remove(x)</code> elimina el elemento x del conjunto s:</p> In\u00a0[41]: Copied! <pre>s = {6, 1, 5, 4, 3}\ns.remove(1)\ns\n</pre> s = {6, 1, 5, 4, 3} s.remove(1) s Out[41]: <pre>{3, 4, 5, 6}</pre> <p>Si el elemento x no est\u00e1 en el conjunto, ocurre un error de llave:</p> In\u00a0[42]: Copied! <pre>s.remove(10)\n</pre> s.remove(10) <pre>\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\n&lt;ipython-input-42-23b5f1bb77c8&gt; in &lt;module&gt;\n----&gt; 1 s.remove(10)\n\nKeyError: 10</pre> <p>Operaciones sobre conjuntos</p> <p></p> <p><code>&amp;</code> y <code>|</code> son los operadores de intersecci\u00f3n y uni\u00f3n repectivamente:</p> In\u00a0[44]: Copied! <pre># crear dos conjuntos\na = {1, 2, 3, 4}\nb = {2, 4, 6, 8}\n</pre> # crear dos conjuntos a = {1, 2, 3, 4} b = {2, 4, 6, 8} In\u00a0[45]: Copied! <pre># interseccion\na &amp; b\n</pre> # interseccion a &amp; b Out[45]: <pre>{2, 4}</pre> In\u00a0[46]: Copied! <pre># union\na | b\n</pre> # union a | b Out[46]: <pre>{1, 2, 3, 4, 6, 8}</pre> <p><code>s - t</code> entrega la diferencia entre s y t; es decir, los elementos de s que no est\u00e1n en t:</p> In\u00a0[47]: Copied! <pre># diferencia\na - b\n</pre> # diferencia a - b Out[47]: <pre>{1, 3}</pre> <p><code>s ^ t</code> entrega la diferencia sim\u00e9trica entre s y t; es decir, los elementos que est\u00e1n en s o en t, pero no en ambos:</p> In\u00a0[49]: Copied! <pre># diferencia simetrica\na ^ b\n</pre> # diferencia simetrica a ^ b Out[49]: <pre>{1, 3, 6, 8}</pre> <p>El operador <code>&lt;</code> aplicado sobre conjuntos significa \u00abes subconjunto de\u00bb:</p> In\u00a0[50]: Copied! <pre>{1, 2} &lt; {1, 2, 3}\n</pre> {1, 2} &lt; {1, 2, 3} Out[50]: <pre>True</pre> In\u00a0[51]: Copied! <pre>{1, 4} &lt; {1, 2, 3}\n</pre> {1, 4} &lt; {1, 2, 3} Out[51]: <pre>False</pre> <p><code>s &lt;= t</code> tambi\u00e9n indica si s es subconjunto de t. La distinci\u00f3n ocurre cuando los conjuntos son iguales:</p> In\u00a0[52]: Copied! <pre>{1, 2, 3} &lt; {1, 2, 3}\n</pre> {1, 2, 3} &lt; {1, 2, 3} Out[52]: <pre>False</pre> In\u00a0[53]: Copied! <pre>{1, 2, 3} &lt;= {1, 2, 3}\n</pre> {1, 2, 3} &lt;= {1, 2, 3} Out[53]: <pre>True</pre> In\u00a0[15]: Copied! <pre># diccionario vacio (Usando corchetes)\ndct = {}\nprint(dct)\n</pre> # diccionario vacio (Usando corchetes) dct = {} print(dct) <pre>{}\n</pre> In\u00a0[16]: Copied! <pre># lista vacia (Usando el constructor)\ndct = dict()\nprint(dct)\n</pre> # lista vacia (Usando el constructor) dct = dict() print(dct) <pre>{}\n</pre> In\u00a0[\u00a0]: Copied! <pre># diccionario de enteros\ndct = {1: 'apple', 2: 'ball'}\n</pre> # diccionario de enteros dct = {1: 'apple', 2: 'ball'} In\u00a0[\u00a0]: Copied! <pre># diccionario dde llaves mixtas\ndct = {'name': 'John', 1: [2, 4, 3]}\n</pre> # diccionario dde llaves mixtas dct = {'name': 'John', 1: [2, 4, 3]} In\u00a0[14]: Copied! <pre>dct = {'nombre':'Jack', 'edad': 26, 'salario': 4534.2}\nprint(dct['edad']) # Output: 26\n</pre> dct = {'nombre':'Jack', 'edad': 26, 'salario': 4534.2} print(dct['edad']) # Output: 26 <pre>26\n</pre> <p>Si se asigna un valor a una llave que ya estaba en el diccionario, el valor anterior se sobreescribe. Recuerde que un diccionario no puede tener llaves repetidas:</p> In\u00a0[\u00a0]: Copied! <pre>dct = {'nombre':'Jack', 'edad': 26}\n</pre> dct = {'nombre':'Jack', 'edad': 26} In\u00a0[\u00a0]: Copied! <pre># cambiar edad\ndct['edad'] = 36 \nprint(dct) # Output: {'name': 'Jack', 'age': 36}\n</pre> # cambiar edad dct['edad'] = 36  print(dct) # Output: {'name': 'Jack', 'age': 36} <p>Tambi\u00e9n se pueden adherir llaves al diccionario</p> In\u00a0[\u00a0]: Copied! <pre># adherir llave salario\ndct['salario'] = 4342.4\nprint(dct) # Output: {'name': 'Jack', 'age': 36, 'salary': 4342.4}\n</pre> # adherir llave salario dct['salario'] = 4342.4 print(dct) # Output: {'name': 'Jack', 'age': 36, 'salary': 4342.4} <p>Por otro lado, si se quiere borrar una llave o el mismo diccionario, se ocupa el comando <code>del</code></p> In\u00a0[\u00a0]: Copied! <pre># borrar llave edad\ndel dct['edad']\nprint(dct) # Output: {'name': 'Jack', 'salary': 4342.4}\n</pre> # borrar llave edad del dct['edad'] print(dct) # Output: {'name': 'Jack', 'salary': 4342.4} In\u00a0[\u00a0]: Copied! <pre># borrar diccionario\ndel dct\n</pre> # borrar diccionario del dct In\u00a0[2]: Copied! <pre>dct = {1: 'apple', 2: 'ball'}\n\nfor k in dct:\n    print(k)\n</pre> dct = {1: 'apple', 2: 'ball'}  for k in dct:     print(k) <pre>1\n2\n</pre> <p>Para iterar sobre las llaves, se usa <code>values()</code>:</p> In\u00a0[3]: Copied! <pre>for v in dct.values():\n    print(v)\n</pre> for v in dct.values():     print(v) <pre>apple\nball\n</pre> <p>Para iterar sobre las llaves y los valores simult\u00e1neamente, se usa el m\u00e9todo <code>items()</code>:</p> In\u00a0[6]: Copied! <pre>for k,v in dct.items():\n    print(f\"llave: {k}, valor: {v}\")\n</pre> for k,v in dct.items():     print(f\"llave: {k}, valor: {v}\") <pre>llave: 1, valor: apple\nllave: 2, valor: ball\n</pre> In\u00a0[30]: Copied! <pre>dct = {[1, 2, 3]: 'hola'}\n</pre> dct = {[1, 2, 3]: 'hola'} <pre>\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n&lt;ipython-input-30-873bc4fce75e&gt; in &lt;module&gt;\n----&gt; 1 dct = {[1, 2, 3]: 'hola'}\n\nTypeError: unhashable type: 'list'</pre> <p>T\u00edpicamente, se usa n\u00fameros, tuplas y strings como llaves de los diccionarios.</p> In\u00a0[\u00a0]: Copied! <pre># respuesta\n</pre> # respuesta In\u00a0[\u00a0]: Copied! <pre># respuesta\n</pre> # respuesta In\u00a0[\u00a0]: Copied! <pre># respuesta\n</pre> # respuesta In\u00a0[\u00a0]: Copied! <pre># respuesta\n</pre> # respuesta"},{"location":"estructura/#estructura-de-datos","title":"Estructura de datos\u00b6","text":""},{"location":"estructura/#listas","title":"Listas\u00b6","text":"<p>Una lista es una colecci\u00f3n ordenada de valores. Una lista puede contener cualquier cosa.</p> <p>En Python, el tipo de datos que representa a las listas se llama <code>list</code>.</p>"},{"location":"estructura/#creando-listas-en-python","title":"Creando listas en python\u00b6","text":"<p>Existen varias formas de crear listas:</p>"},{"location":"estructura/#operaciones-sobre-listas","title":"Operaciones sobre listas\u00b6","text":"<p>Operador len</p> <p><code>len(lista)</code> entrega el largo de la lista; es decir, cu\u00e1ntos elementos tiene:</p>"},{"location":"estructura/#iterar-sobre-una-lista","title":"Iterar sobre una lista\u00b6","text":"<p>En Python, una lista es un tipo de objeto iterable, lo que significa que puedes recorrer sus elementos utilizando un ciclo <code>for</code>.</p> <p>A continuaci\u00f3n, te mostraremos un ejemplo de c\u00f3mo hacerlo paso a paso:</p>"},{"location":"estructura/#tuplas","title":"Tuplas\u00b6","text":"<p>Una tupla es una secuencia de valores agrupados. Una tupla sirve para agrupar, como si fueran un \u00fanico valor, varios valores que, por su naturaleza, deben ir juntos.</p> <p>El tipo de datos que representa a las tuplas se llama <code>tuple</code>. El tipo tuple es inmutable: una tupla no puede ser modificada una vez que ha sido creada.</p>"},{"location":"estructura/#desempaquetado-de-tuplas","title":"Desempaquetado de tuplas\u00b6","text":"<p>Los valores individuales de una tupla pueden ser recuperados asignando la tupla a las variables respectivas. Esto se llama desempaquetar la tupla (en ingl\u00e9s: unpack):</p>"},{"location":"estructura/#comparacion-de-tuplas","title":"Comparaci\u00f3n de tuplas\u00b6","text":"<p>Dos tuplas son iguales cuando tienen el mismo tama\u00f1o y cada uno de sus elementos correspondientes tienen el mismo valor:</p>"},{"location":"estructura/#acceder-a-valores-de-una-tupla","title":"Acceder a  valores de una tupla\u00b6","text":"<p>Al igual que las listas, se pueden acceder a distintos elemntos de las tuplas de la siguiente forma:</p>"},{"location":"estructura/#iteracion-sobre-tuplas","title":"Iteraci\u00f3n sobre tuplas\u00b6","text":"<p>Las tuplas en Python tambi\u00e9n son objetos iterables, lo que significa que puedes recorrer sus elementos usando un ciclo <code>for</code>.</p> <p>A continuaci\u00f3n, te mostraremos un ejemplo de c\u00f3mo hacerlo paso a paso:</p>"},{"location":"estructura/#conjuntos","title":"Conjuntos\u00b6","text":"<p>Un conjunto es una colecci\u00f3n desordenada de valores no repetidos.</p> <p>Los conjuntos de Python son an\u00e1logos a los conjuntos matem\u00e1ticos. El tipo de datos que representa a los conjuntos se llama <code>set</code>.</p>"},{"location":"estructura/#como-crear-conjuntos","title":"C\u00f3mo crear conjuntos\u00b6","text":"<p>Las dos maneras principales de crear un conjunto son:</p>"},{"location":"estructura/#operaciones-sobre-conjuntos","title":"Operaciones sobre conjuntos\u00b6","text":""},{"location":"estructura/#diccionarios","title":"Diccionarios\u00b6","text":"<p>Un diccionario es un tipo de datos que sirve para asociar pares de objetos.</p> <p>Un diccionario puede ser visto como una colecci\u00f3n de llaves, cada una de las cuales tiene asociada un valor. Las llaves no est\u00e1n ordenadas y no hay llaves repetidas. La \u00fanica manera de acceder a un valor es a trav\u00e9s de su llave.</p>"},{"location":"estructura/#como-crear-diccionarios","title":"C\u00f3mo crear diccionarios\u00b6","text":"<p>Los diccionarios literales se crean usando llaves ({ y }). La llave y el valor van separados por dos puntos:</p>"},{"location":"estructura/#como-usar-un-diccionario","title":"C\u00f3mo usar un diccionario\u00b6","text":"<p>El valor asociado a la llave $k$ en el diccionario $dct$ se puede obtener mediante $dct[k]$:</p>"},{"location":"estructura/#iterar-un-diccionario","title":"Iterar un diccionario\u00b6","text":"<p>Los diccionarios son iterables. Al iterar sobre un diccionario en un ciclo <code>for</code>, se obtiene las llaves:</p>"},{"location":"estructura/#restricciones-sobre-las-llaves","title":"Restricciones sobre las llaves\u00b6","text":"<p>No se puede usar cualquier objeto como llave de un diccionario. Las llaves deben ser de un tipo de datos inmutable. Por ejemplo, no se puede usar listas:</p>"},{"location":"estructura/#ejercicios","title":"Ejercicios\u00b6","text":""},{"location":"estructura/#listas","title":"Listas\u00b6","text":"<p>Ejercicio 01</p> <p>Considere las siguientes listas:</p> <pre>a = [5, 1, 4, 9, 0]\nb = range(3, 10) + range(20, 23)\nc = [[1, 2], [3, 4, 5], [6, 7]]\nd = ['perro', 'gato', 'jirafa', 'elefante']\ne = ['a', a, 2 * a]\n</pre> <p>Sin usar el computador, indique cu\u00e1l es el resultado y el tipo de las siguientes expresiones. A continuaci\u00f3n, verifique sus respuestas en el computador.</p> <pre>a[2]\nb[9]\nc[1][2]\ne[0] == e[1]\nlen(c)\nlen(c[0])\nlen(e)\nc[-1]\nc[-1][+1]\nc[2:] + d[2:]\na[3:10]\na[3:10:2]\nd.index('jirafa')\ne[c[0][1]].count(5)\nsorted(a)[2]\ncomplex(b[0], b[1])\n</pre>"},{"location":"estructura/#tuplas","title":"Tuplas\u00b6","text":"<p>Ejercicio 01</p> <p>Considere las siguientes asignaciones:</p> <pre>a = (2, 10, 1991)\nb = (25, 12, 1990)\nc = ('Donald', True, b)\nx, y = ((27, 3), 9)\nz, w = x\nv = (x, a)\n</pre> <p>Sin usar el computador, indique cu\u00e1l es el resultado y el tipo de las siguientes expresiones. A continuaci\u00f3n, verifique sus respuestas en el computador.</p> <pre>a &lt; b\ny + w\nx + a\nlen(v)\nv[1][1]\nc[0][0]\nz, y\na + b[1:5]\n(a + b)[1:5]\nstr(a[2]) + str(b[2])\nstr(a[2] + b[2])\nstr((a + b)[2])\nstr(a + b)[2]\n</pre>"},{"location":"estructura/#conjuntos","title":"Conjuntos\u00b6","text":"<p>Ejercicio 01</p> <p>Considere las siguientes asignaciones:</p> <pre>a = {5, 2, 3, 9, 4}\nb = {3, 1}\nc = {7, 5, 5, 1, 8, 6}\nd = [6, 2, 4, 5, 5, 3, 1, 3, 7, 8]\ne = {(2, 3), (3, 4), (4, 5)}\nf = [{2, 3}, {3, 4}, {4, 5}]\n</pre> <p>Sin usar el computador, indique cu\u00e1l es el resultado y el tipo de las siguientes expresiones. A continuaci\u00f3n, verifique sus respuestas en el computador.</p> <pre>len(c)\nlen(set(d))\na &amp; (b | c)\n(a &amp; b) | c\nc - a\nmax(e)\nf[0] &lt; a\nset(range(4)) &amp; a\n(set(range(4)) &amp; a) in f\nlen(set('perro'))\nlen({'perro'})\n</pre>"},{"location":"estructura/#diccionarios","title":"Diccionarios\u00b6","text":"<p>Ejercicio 01</p> <p>Considere las siguientes asignaciones:</p> <pre>a = {'a': 14, 'b': 23, 'c': 88}\nb = {12: True, 55: False, -2: False}\nc = dict()\nd = {1: [2, 3, 4], 5: [6, 7, 8, 9], 10: [11]}\ne = {2 + 3: 4, 5: 6 + 7, 8: 9, 10: 11 + 12}\n</pre> <p>Sin usar el computador, indique cu\u00e1l es el resultado y el tipo de las siguientes expresiones. A continuaci\u00f3n, verifique sus respuestas en el computador.</p> <pre>a['c']\na[23]\nb[-2] or b[55]\n23 in a\n'a' in a\n5 in d[5]\nsum(b)\nlen(c)\nlen(d)\nlen(d[1])\nlen(b.values())\nlen(e)\nsum(a.values())\nmax(list(e))\nd[1] + d[5] + d[10]\n</pre>"},{"location":"flujo/","title":"Control de Flujo","text":"<p>EL control de flujo o sentencias de control permiten modificar el flujo del programa introduciendo ciclos y condicionales.</p> <ul> <li><p>Un condicional es un conjunto de sentencias que pueden o no ejecutarse, dependiendo del resultado de una condici\u00f3n.</p> </li> <li><p>Un ciclo es un conjunto de sentencias que son ejecutadas varias veces, hasta que una condici\u00f3n de t\u00e9rmino es satisfecha.</p> </li> </ul> <p>Tanto los condicionales como los ciclos contienen a otras sentencias. Para indicar esta relaci\u00f3n se utiliza la indentaci\u00f3n: las sentencias contenidas no se escriben en la misma columna que la sentencia de control, sino un poco m\u00e1s a la derecha.</p> In\u00a0[1]: Copied! <pre># definir variables\nn = 5\nm = 10\n\n# inicializar flujo\nif m &lt; n:\n    t = m\n    m = n\n    n = t\n\n# sentencia despues del flujo\nprint(m, n)\n</pre> # definir variables n = 5 m = 10  # inicializar flujo if m &lt; n:     t = m     m = n     n = t  # sentencia despues del flujo print(m, n) <pre>10 5\n</pre> In\u00a0[2]: Copied! <pre>nota = 60\nprint(f\"Ingrese su nota: {nota}\")\n\nif nota &gt;= 55:\n    print(\"Felicitaciones!!!\")\n</pre> nota = 60 print(f\"Ingrese su nota: {nota}\")  if nota &gt;= 55:     print(\"Felicitaciones!!!\") <pre>Ingrese su nota: 60\nFelicitaciones!!!\n</pre> In\u00a0[3]: Copied! <pre>nota = 40\nprint(f\"Ingrese su nota: {nota}\")\n\nif nota &lt; 55:\n    print(\"Lamentablemente Ud. ha reprobado.\")\n</pre> nota = 40 print(f\"Ingrese su nota: {nota}\")  if nota &lt; 55:     print(\"Lamentablemente Ud. ha reprobado.\") <pre>Ingrese su nota: 40\nLamentablemente Ud. ha reprobado.\n</pre> <p>ejemplo 01</p> In\u00a0[4]: Copied! <pre>edad = 20\nprint(f\"Ingrese su edad: {edad}\")\n\nif edad &lt; 18:\n    print(\"Usted es menor de edad\")\nelse:\n    print(\"Usted es adulto\")\n</pre> edad = 20 print(f\"Ingrese su edad: {edad}\")  if edad &lt; 18:     print(\"Usted es menor de edad\") else:     print(\"Usted es adulto\") <pre>Ingrese su edad: 20\nUsted es adulto\n</pre> In\u00a0[5]: Copied! <pre>edad = 10\nprint(f\"Ingrese su edad: {edad}\")\n\nif edad &lt; 18:\n    print(\"Usted es menor de edad\")\nelse:\n    print(\"Usted es adulto\")\n</pre> edad = 10 print(f\"Ingrese su edad: {edad}\")  if edad &lt; 18:     print(\"Usted es menor de edad\") else:     print(\"Usted es adulto\") <pre>Ingrese su edad: 10\nUsted es menor de edad\n</pre> <p>ejemplo 02</p> In\u00a0[6]: Copied! <pre>n = 15\nprint(f\"Ingrese su numero: {n}\")\n\nif n % 2 == 0:\n    print(\"El numero es par\")\n    print(\"La mitad del numero es\", n / 2)\nelse:\n    print(\"El numero es impar\")\n    print(\"El sucesor del numero es\", n + 1)\nprint(\"Fin\")\n</pre> n = 15 print(f\"Ingrese su numero: {n}\")  if n % 2 == 0:     print(\"El numero es par\")     print(\"La mitad del numero es\", n / 2) else:     print(\"El numero es impar\")     print(\"El sucesor del numero es\", n + 1) print(\"Fin\") <pre>Ingrese su numero: 15\nEl numero es impar\nEl sucesor del numero es 16\nFin\n</pre> In\u00a0[7]: Copied! <pre>n = 20\nprint(f\"Ingrese su numero: {n}\")\n\nif n % 2 == 0:\n    print(\"El numero es par\")\n    print(\"La mitad del numero es\", n / 2)\nelse:\n    print(\"El numero es impar\")\n    print(\"El sucesor del numero es\", n + 1)\nprint(\"Fin\")\n</pre> n = 20 print(f\"Ingrese su numero: {n}\")  if n % 2 == 0:     print(\"El numero es par\")     print(\"La mitad del numero es\", n / 2) else:     print(\"El numero es impar\")     print(\"El sucesor del numero es\", n + 1) print(\"Fin\") <pre>Ingrese su numero: 20\nEl numero es par\nLa mitad del numero es 10.0\nFin\n</pre> <p>Existen tres formas de ocupar esta condicional.</p> <ul> <li><p>Estructura if: La estructura if se utiliza para tomar decisiones en funci\u00f3n de una condici\u00f3n. Si la condici\u00f3n es verdadera, el bloque de c\u00f3digo dentro del if se ejecutar\u00e1.</p> </li> <li><p>Estructura if-else: La estructura if-else se utiliza para tomar decisiones y ejecutar un bloque de c\u00f3digo si la condici\u00f3n es verdadera y otro bloque de c\u00f3digo si la condici\u00f3n es falsa.</p> </li> <li><p>Estructura if-elif-else: La estructura if-elif-else se utiliza para tomar decisiones y ejecutar diferentes bloques de c\u00f3digo seg\u00fan diferentes condiciones. Se eval\u00faan las condiciones en orden, y si alguna es verdadera, se ejecutar\u00e1 el bloque de c\u00f3digo correspondiente. Si ninguna de las condiciones es verdadera, se ejecutar\u00e1 el bloque de c\u00f3digo en la cl\u00e1usula else.</p> </li> </ul> <p>Es decir, puede no existir o pueden existir varios  <code>elif</code>. Por otro lado, el <code>else</code> es opcional dependiendo del caso.</p> <p>ejemplo 01</p> <p>Escriba un programa que califique el rendimiento del alumno en una asignatura seg\u00fan la nota obtenida.</p> In\u00a0[8]: Copied! <pre>nota = 90\nprint(f\"Ingrese su nota: {nota}\")\n\nif nota &gt;= 80:\n    print(\"Usted es un alumno destacado.\")\nelif nota &gt;= 65:\n    print(\"Usted ha aprobado.\")\nelif nota &gt;= 55:\n    print(\"Usted aprob\u00f3 con algunas dificultades.\")\nelif nota &gt;= 45:\n    print(\"Con un poco mas de empe\u00f1o hubiese aprobado.\")\nelse:\n    print(\"Nos vemos el pr\u00f3ximo semestre.\")\n</pre> nota = 90 print(f\"Ingrese su nota: {nota}\")  if nota &gt;= 80:     print(\"Usted es un alumno destacado.\") elif nota &gt;= 65:     print(\"Usted ha aprobado.\") elif nota &gt;= 55:     print(\"Usted aprob\u00f3 con algunas dificultades.\") elif nota &gt;= 45:     print(\"Con un poco mas de empe\u00f1o hubiese aprobado.\") else:     print(\"Nos vemos el pr\u00f3ximo semestre.\") <pre>Ingrese su nota: 90\nUsted es un alumno destacado.\n</pre> <p>ejemplo 02</p> <p>Considerar la siguiente tabla que muestra la tasa de impuesto a pagar por una persona seg\u00fan su sueldo.</p> Sueldo Tasa de impuesto menos de 1000 0% 1000 \u2264 sueldo &lt; 2000 5% 2000 \u2264 sueldo &lt; 4000 10% 4000 o m\u00e1s 12% <p>Un ejemplo de como se calcula el impuesto ser\u00eda el siguiente:</p> In\u00a0[9]: Copied! <pre>sueldo = 2000\nprint(f\"Ingrese su sueldo: {sueldo}\")\n\nif sueldo &lt; 1000:\n    print(\"caso 1\")\n    tasa = 0.00\nelif sueldo &lt; 2000: # 1000 &lt;= sueldo &lt; 2000?\n    print(\"caso 2\")\n    tasa = 0.05\nelif sueldo &lt; 4000: # 2000 &lt;= sueldo &lt; 4000\n    print(\"caso 3\")\n    tasa = 0.10\nelse:\n    print(\"caso falso\")\n    tasa = 0.12\nprint(\"Usted debe pagar\", int(tasa*sueldo), \"de impuesto.\")\n</pre> sueldo = 2000 print(f\"Ingrese su sueldo: {sueldo}\")  if sueldo &lt; 1000:     print(\"caso 1\")     tasa = 0.00 elif sueldo &lt; 2000: # 1000 &lt;= sueldo &lt; 2000?     print(\"caso 2\")     tasa = 0.05 elif sueldo &lt; 4000: # 2000 &lt;= sueldo &lt; 4000     print(\"caso 3\")     tasa = 0.10 else:     print(\"caso falso\")     tasa = 0.12 print(\"Usted debe pagar\", int(tasa*sueldo), \"de impuesto.\") <pre>Ingrese su sueldo: 2000\ncaso 3\nUsted debe pagar 200 de impuesto.\n</pre> <p>Otra forma de calcular el impuesto es la siguiente:</p> In\u00a0[10]: Copied! <pre>sueldo = 2000\nif sueldo &lt; 1000: #1000 &gt; sueldo:\n    print(\"caso 1\")\n    tasa = 0.00\nif sueldo &gt;= 1000 and sueldo &lt; 2000: #if 1000 &lt;= sueldo &lt; 2000:\n    print(\"caso 2\")\n    tasa = 0.05\nif 2000 &lt;= sueldo &lt; 4000:\n    print(\"caso 3\")\n    tasa = 0.10\nif 4000 &lt;= sueldo: #sueldo&gt;= 4000\n    print(\"caso falso\")\n    tasa = 0.12\nprint(\"Usted debe pagar\", int(tasa*sueldo), \"de impuesto.\")\n</pre> sueldo = 2000 if sueldo &lt; 1000: #1000 &gt; sueldo:     print(\"caso 1\")     tasa = 0.00 if sueldo &gt;= 1000 and sueldo &lt; 2000: #if 1000 &lt;= sueldo &lt; 2000:     print(\"caso 2\")     tasa = 0.05 if 2000 &lt;= sueldo &lt; 4000:     print(\"caso 3\")     tasa = 0.10 if 4000 &lt;= sueldo: #sueldo&gt;= 4000     print(\"caso falso\")     tasa = 0.12 print(\"Usted debe pagar\", int(tasa*sueldo), \"de impuesto.\") <pre>caso 3\nUsted debe pagar 200 de impuesto.\n</pre> <p>\u00bfEn qu\u00e9 se diferencian los dos programas anteriores?</p> <p>Soluci\u00f3n:</p> <ol> <li><p>Diferencia en la forma de expresar las condiciones: En el primer programa, se utilizan operadores de desigualdad (<code>&lt;</code>) para expresar las condiciones, mientras que en el segundo programa, se utilizan operadores de igualdad (<code>&gt;=</code>) y (<code>&lt;=</code>) para expresar las mismas condiciones.</p> </li> <li><p>Diferencia en el resultado impreso: En el primer programa, se imprime el caso correspondiente (por ejemplo, \"caso 1\", \"caso 2\", etc.) antes de calcular la tasa de impuesto, mientras que en el segundo programa, se calcula la tasa de impuesto sin imprimir el caso correspondiente.</p> </li> </ol> <p>Por ejemplo, el siguiente programa multiplica dos n\u00fameros enteros sin usar el operador <code>*</code>:</p> In\u00a0[11]: Copied! <pre>m = 4\nn = 7\np = 0\n\nwhile m &gt; 0:\n    m = m - 1\n    p = p + n\n    \nprint(f\"El producto de 'm' y 'n' es {p}\")\n</pre> m = 4 n = 7 p = 0  while m &gt; 0:     m = m - 1     p = p + n      print(f\"El producto de 'm' y 'n' es {p}\") <pre>El producto de 'm' y 'n' es 28\n</pre> <p>Para ver c\u00f3mo funciona este programa, hagamos un ruteo con la entrada $m = 4$ y $n = 7$:</p> p m n 4 7 0 3 7 2 14 1 21 0 28 <p>El proceso funciona de la siguiente manera:</p> <ol> <li>Se inician las variables <code>m</code> con el valor 4, <code>n</code> con el valor 7 y <code>p</code> con el valor 0.</li> <li>Se entra en un bucle <code>while</code> con la condici\u00f3n <code>m &gt; 0</code>, lo que significa que el bucle se ejecutar\u00e1 mientras <code>m</code> sea mayor que 0.</li> <li>En cada iteraci\u00f3n del bucle, el valor de <code>m</code> se reduce en 1 (usando <code>m = m - 1</code>) y el valor de <code>n</code> se suma al valor actual de <code>p</code> (usando <code>p = p + n</code>).</li> <li>El bucle contin\u00faa ejecut\u00e1ndose hasta que <code>m</code> sea igual a 0. Cuando <code>m</code> alcanza 0, la condici\u00f3n <code>m &gt; 0</code> se vuelve falsa, y el bucle se detiene.</li> <li>Despu\u00e9s de que el bucle se detiene, se imprime el resultado, que es el producto acumulado de <code>m</code> y <code>n</code> en la variable <code>p</code>.</li> </ol> <p>La raz\u00f3n por la que estamos seguros de que el ciclo terminar\u00e1 en alg\u00fan momento es que la condici\u00f3n del bucle <code>while</code> se verifica en cada iteraci\u00f3n, y <code>m</code> se reduce en 1 en cada iteraci\u00f3n. Dado que <code>m</code> se inicializa con el valor 4, y en cada iteraci\u00f3n se reduce en 1, eventualmente alcanzar\u00e1 el valor 0 despu\u00e9s de 4 iteraciones, lo que har\u00e1 que la condici\u00f3n <code>m &gt; 0</code> sea falsa y el ciclo se detendr\u00e1. Por lo tanto, podemos estar seguros de que el ciclo terminar\u00e1.</p> In\u00a0[8]: Copied! <pre># Solicita al usuario ingresar un n\u00famero entero\nnumero = 10\n\n# Inicializa la variable para la suma\nsuma = 0\n\n# Inicializa un contador\ni = 1\n\n# Utiliza un ciclo while para calcular la suma de los cuadrados\nwhile i &lt;= numero:\n    suma += i ** 2\n    i += 1\n\n# Muestra el resultado\nprint(f\"La suma de los cuadrados desde 1 hasta {numero} es {suma}\")\n</pre> # Solicita al usuario ingresar un n\u00famero entero numero = 10  # Inicializa la variable para la suma suma = 0  # Inicializa un contador i = 1  # Utiliza un ciclo while para calcular la suma de los cuadrados while i &lt;= numero:     suma += i ** 2     i += 1  # Muestra el resultado print(f\"La suma de los cuadrados desde 1 hasta {numero} es {suma}\") <pre>La suma de los cuadrados desde 1 hasta 10 es 385\n</pre> In\u00a0[9]: Copied! <pre># Solicita al usuario ingresar un n\u00famero entero\nn = 10\n\n# Inicializa el valor del factorial a 1\nfactorial = 1\n\n# Inicializa un contador\ni = 1\n\n# Utiliza un ciclo while para calcular el factorial\nwhile i &lt;= n:\n    factorial *= i\n    i += 1\n\n# Muestra el resultado\nprint(f\"{n}! = {factorial}\")\n</pre> # Solicita al usuario ingresar un n\u00famero entero n = 10  # Inicializa el valor del factorial a 1 factorial = 1  # Inicializa un contador i = 1  # Utiliza un ciclo while para calcular el factorial while i &lt;= n:     factorial *= i     i += 1  # Muestra el resultado print(f\"{n}! = {factorial}\") <pre>10! = 3628800\n</pre> In\u00a0[7]: Copied! <pre># Solicita al usuario ingresar un n\u00famero entero\nnumero = 35\n\n# Inicializa un contador de n\u00fameros divisibles por 3 o 5\ncontador = 0\n\n# Inicializa un valor para contar\ni = 1\n\n# Utiliza un ciclo while para contar n\u00fameros divisibles por 3 o 5\nwhile i &lt;= numero:\n    if i % 3 == 0 or i % 5 == 0:\n        contador += 1\n    i += 1\n\n# Muestra la cantidad de n\u00fameros divisibles por 3 o 5\nprint(f\"En el rango de 1 a {numero}, hay {contador} n\u00fameros divisibles por 3 o 5.\")\n</pre> # Solicita al usuario ingresar un n\u00famero entero numero = 35  # Inicializa un contador de n\u00fameros divisibles por 3 o 5 contador = 0  # Inicializa un valor para contar i = 1  # Utiliza un ciclo while para contar n\u00fameros divisibles por 3 o 5 while i &lt;= numero:     if i % 3 == 0 or i % 5 == 0:         contador += 1     i += 1  # Muestra la cantidad de n\u00fameros divisibles por 3 o 5 print(f\"En el rango de 1 a {numero}, hay {contador} n\u00fameros divisibles por 3 o 5.\") <pre>En el rango de 1 a 35, hay 16 n\u00fameros divisibles por 3 o 5.\n</pre> In\u00a0[12]: Copied! <pre># Imprimir los n\u00fameros del 0 al 20 y sus cubos\nfor i in range(21):\n    print(f\"N\u00famero: {i}, Cubo: {i**3}\")\n</pre> # Imprimir los n\u00fameros del 0 al 20 y sus cubos for i in range(21):     print(f\"N\u00famero: {i}, Cubo: {i**3}\") <pre>N\u00famero: 0, Cubo: 0\nN\u00famero: 1, Cubo: 1\nN\u00famero: 2, Cubo: 8\nN\u00famero: 3, Cubo: 27\nN\u00famero: 4, Cubo: 64\nN\u00famero: 5, Cubo: 125\nN\u00famero: 6, Cubo: 216\nN\u00famero: 7, Cubo: 343\nN\u00famero: 8, Cubo: 512\nN\u00famero: 9, Cubo: 729\nN\u00famero: 10, Cubo: 1000\nN\u00famero: 11, Cubo: 1331\nN\u00famero: 12, Cubo: 1728\nN\u00famero: 13, Cubo: 2197\nN\u00famero: 14, Cubo: 2744\nN\u00famero: 15, Cubo: 3375\nN\u00famero: 16, Cubo: 4096\nN\u00famero: 17, Cubo: 4913\nN\u00famero: 18, Cubo: 5832\nN\u00famero: 19, Cubo: 6859\nN\u00famero: 20, Cubo: 8000\n</pre> <p>Un rango es una sucesi\u00f3n de n\u00fameros enteros equiespaciados. Incluyendo la presentada m\u00e1s arriba, hay tres maneras de definir un rango:</p> <pre>range(final)\nrange(inicial, final)\nrange(inicial, final, incremento)\n</pre> <p>El valor inicial siempre es parte del rango. El valor final nunca es parte del rango. El incremento indica la diferencia entre dos valores consecutivos del rango.</p> <p>Si el valor inicial es omitido, se supone que es 0. Si el incremento es omitido, se supone que es 1.</p> <p>Con algunos ejemplos quedar\u00e1 m\u00e1s claro:</p> sentencia resultado <code>range(9)</code> 0, 1, 2, 3, 4, 5, 6, 7, 8 <code>range(3, 13)</code> 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 <code>range(3, 13, 2)</code> 3, 5, 7, 9, 11 <code>range(11, 4)</code> ning\u00fan valor <code>range(11, 4, -1)</code> 11, 10, 9, 8, 7, 6, 5 In\u00a0[2]: Copied! <pre># Imprimir los valores de los objetos range\n\nprint(list(range(9)))            \nprint(list(range(3, 13)))        \nprint(list(range(3, 13, 2)))     \nprint(list(range(11, 4)))        \nprint(list(range(11, 4, -1)))\n</pre> # Imprimir los valores de los objetos range  print(list(range(9)))             print(list(range(3, 13)))         print(list(range(3, 13, 2)))      print(list(range(11, 4)))         print(list(range(11, 4, -1)))   <pre>[0, 1, 2, 3, 4, 5, 6, 7, 8]\n[3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n[3, 5, 7, 9, 11]\n[]\n[11, 10, 9, 8, 7, 6, 5]\n</pre> <p>Usando un incremento negativo, es posible hacer ciclos que van hacia atr\u00e1s:</p> In\u00a0[13]: Copied! <pre># Cuenta regresiva para el A\u00f1o Nuevo\nfor i in range(10, 0, -1):\n    print(i)\n\nprint('\u00a1Feliz A\u00f1o Nuevo!')\n</pre> # Cuenta regresiva para el A\u00f1o Nuevo for i in range(10, 0, -1):     print(i)  print('\u00a1Feliz A\u00f1o Nuevo!') <pre>10\n9\n8\n7\n6\n5\n4\n3\n2\n1\n\u00a1Feliz A\u00f1o Nuevo!\n</pre> <p>Veamos el siguiente ejemplo:</p> In\u00a0[14]: Copied! <pre>for n in range(1, 21):\n    if n % 7 == 0:\n        break  # Se rompe el ciclo en esta iteraci\u00f3n\n    print(n)\n\nprint(\"--Fin--\")\n</pre> for n in range(1, 21):     if n % 7 == 0:         break  # Se rompe el ciclo en esta iteraci\u00f3n     print(n)  print(\"--Fin--\") <pre>1\n2\n3\n4\n5\n6\n--Fin--\n</pre> <p>Este c\u00f3digo es un bucle <code>for</code> en Python que itera a trav\u00e9s de los n\u00fameros del 1 al 20. El objetivo del bucle es imprimir los n\u00fameros en cada iteraci\u00f3n hasta que se encuentre un n\u00famero divisible por 7. Aqu\u00ed est\u00e1 lo que hace paso a paso:</p> <ol> <li><p>Inicia un bucle <code>for</code> que utiliza la variable <code>n</code> para recorrer los n\u00fameros del 1 al 20 (inclusive) con la funci\u00f3n <code>range(1, 21)</code>.</p> </li> <li><p>En cada iteraci\u00f3n del bucle, se verifica si el n\u00famero <code>n</code> es divisible por 7 utilizando la expresi\u00f3n <code>n % 7 == 0</code>. Esto se hace con el operador de m\u00f3dulo (<code>%</code>) para comprobar si el residuo de la divisi\u00f3n de <code>n</code> por 7 es igual a 0. Si esta condici\u00f3n es verdadera, significa que <code>n</code> es divisible por 7.</p> </li> <li><p>Si se encuentra un n\u00famero que es divisible por 7, se utiliza la instrucci\u00f3n <code>break</code> para salir inmediatamente del bucle <code>for</code>, lo que significa que el bucle se interrumpe en esa iteraci\u00f3n.</p> </li> <li><p>Si el bucle no se rompe con <code>break</code>, se imprime el n\u00famero <code>n</code> en esa iteraci\u00f3n.</p> </li> <li><p>Despu\u00e9s de que se complete el bucle <code>for</code>, se imprime \"--Fin--\" una vez para marcar el final del programa.</p> </li> </ol> <p>Veamos el siguiente ejemplo:</p> In\u00a0[15]: Copied! <pre>for n in range(1, 21):\n    if n % 7 == 0:\n        continue # continua el ciclo ignorando esta iteracion\n    print(n)\n\nprint(\"--Fin--\")\n</pre> for n in range(1, 21):     if n % 7 == 0:         continue # continua el ciclo ignorando esta iteracion     print(n)  print(\"--Fin--\") <pre>1\n2\n3\n4\n5\n6\n8\n9\n10\n11\n12\n13\n15\n16\n17\n18\n19\n20\n--Fin--\n</pre> <p>El c\u00f3digo que proporcionaste es un bucle <code>for</code> en Python que itera a trav\u00e9s de los n\u00fameros del 1 al 20 utilizando la funci\u00f3n <code>range(1, 21)</code>. El bucle imprime todos los n\u00fameros excepto aquellos que son divisibles por 7. A continuaci\u00f3n, se explica paso a paso lo que hace el c\u00f3digo:</p> <ol> <li><p>El bucle <code>for</code> se inicia y la variable <code>n</code> toma valores del 1 al 20 en cada iteraci\u00f3n.</p> </li> <li><p>En cada iteraci\u00f3n del bucle, se verifica si el n\u00famero <code>n</code> es divisible por 7 utilizando la expresi\u00f3n <code>n % 7 == 0</code>. El operador de m\u00f3dulo (<code>%</code>) se utiliza para calcular el residuo de la divisi\u00f3n de <code>n</code> por 7. Si el residuo es igual a 0, significa que <code>n</code> es divisible por 7.</p> </li> <li><p>Si la condici\u00f3n <code>n % 7 == 0</code> es verdadera, se ejecuta la instrucci\u00f3n <code>continue</code>, que salta el resto del c\u00f3digo en esa iteraci\u00f3n y pasa a la siguiente iteraci\u00f3n del bucle. Esto significa que cuando se encuentra un n\u00famero divisible por 7, no se imprime y el bucle contin\u00faa con el siguiente n\u00famero.</p> </li> <li><p>Si la condici\u00f3n <code>n % 7 == 0</code> no es verdadera (es decir, si <code>n</code> no es divisible por 7), se ejecuta la instrucci\u00f3n <code>print(n)</code>, que imprime el valor de <code>n</code> en la consola.</p> </li> <li><p>Despu\u00e9s de que se complete el bucle <code>for</code>, se imprime \"--Fin--\" una vez para marcar el final del programa.</p> </li> </ol> In\u00a0[5]: Copied! <pre># respuesta\n</pre> # respuesta <p>Ejercicio 02</p> <p>Escriba un programa que pida dos n\u00fameros enteros y que calcule la divisi\u00f3n, indicando si la divisi\u00f3n es exacta o no.</p> <pre><code>terminal\nDividendo: 14\nDivisor: 5\n\nLa divisi\u00f3n no es exacta.\nCociente: 2\nResto: 4\n</code></pre> <pre>Dividendo: 100\nDivisor: 10\n\nLa divisi\u00f3n es exacta.\nCociente: 10\nResto: 0\n</pre> In\u00a0[17]: Copied! <pre># respuesta\n</pre> # respuesta <p>Ejercicio 03</p> <p>Escriba un programa que pida al usuario dos palabras, y que indique cu\u00e1l de ellas es la m\u00e1s larga y por cu\u00e1ntas letras lo es.</p> <pre><code>terminal\nPalabra 1: edificio\nPalabra 2: tren\nLa palabra edificio tiene 4 letras mas que tren.\n</code></pre> <pre><code>terminal\nPalabra 1: sol\nPalabra 2: paralelepipedo\nLa palabra paralelepipedo tiene 11 letras mas que sol\n</code></pre> <pre><code>terminal\nPalabra 1: plancha\nPalabra 2: lapices\nLas dos palabras tienen el mismo largo\n</code></pre> In\u00a0[18]: Copied! <pre># respuesta\n</pre> # respuesta <p>Ejercicio 04</p> <p>Un a\u00f1o es bisiesto si es divisible por $4$, excepto si es divisible por $100$ y no por $400$. Escriba un programa que reciba un a\u00f1o como entrada e indique <code>True</code> si un a\u00f1o es bisiesto o <code>False</code> si no lo es.</p> <pre><code>terminal\nIngrese un anno: 1988\n1988 es bisiesto\n</code></pre> <pre><code>terminal\nIngrese un anno: 2011\n2011 no es bisiesto\n</code></pre> <pre><code>terminal\nIngrese un anno: 1700\n1700 no es bisiesto\n</code></pre> <pre><code>terminal\nIngrese un anno: 2400\n2400 es bisiesto\n</code></pre> In\u00a0[19]: Copied! <pre># respuesta\n</pre> # respuesta <p>Ejercicio 05</p> <p>Los tres lados $a, b$ y $c$ de un tri\u00e1ngulo deben satisfacer la desigualdad triangular: cada uno de los lados no puede ser m\u00e1s largo que la suma de los otros dos.</p> <p>Escriba un programa que reciba como entrada los tres lados de un tri\u00e1ngulo, e indique:</p> <ul> <li>si acaso el tri\u00e1ngulo es inv\u00e1lido</li> <li>si el tri\u00e1ngulo es v\u00e1lido, qu\u00e9 tipo de tri\u00e1ngulo es.</li> </ul> <pre><code>terminal\nIngrese a: 3.9\nIngrese b: 6.0\nIngrese c: 1.2\nNo es un triangulo valido.\n</code></pre> <pre><code>terminal\nIngrese a: 1.9\nIngrese b: 2\nIngrese c: 2\nEl triangulo es isoceles.\n</code></pre> <pre><code>terminal\nIngrese a: 3.0\nIngrese b: 5.0\nIngrese c: 4.0\nEl triangulo es escaleno.\n</code></pre> <pre><code>terminal\nIngrese a: 2\nIngrese b: 2\nIngrese c: 2\nEl triangulo es equilatero.\n</code></pre> In\u00a0[20]: Copied! <pre># respuesta\n</pre> # respuesta <p>Ejercicio 06</p> <p>El riesgo de que una persona sufra enfermedades coronarias depende de su edad y su \u00edndice de masa corporal:</p> edad &lt; 45 edad \u2265 45 IMC &lt; 22.0 bajo medio IMC \u2265 22.0 medio alto <p>El \u00edndice de masa corporal es el cuociente entre el peso del individuo en kilos y el cuadrado de su estatura en metros ($IMC = \\dfrac{peso}{estatura^2} $).</p> <p>Escriba un programa que reciba como entrada la estatura, el peso y la edad de una persona, y le entregue su condici\u00f3n de riesgo.</p> <p>ejemplos</p> <ul> <li>Si el usuario ingresa una estatura de 1.75 metros, un peso de 70 kilogramos y una edad de 30 a\u00f1os, el programa mostrar\u00e1: \"La condici\u00f3n de riesgo es: medio\".</li> <li>Si el usuario ingresa una estatura de 1.65 metros, un peso de 90 kilogramos y una edad de 50 a\u00f1os, el programa mostrar\u00e1: \"La condici\u00f3n de riesgo es: alto\".</li> </ul> In\u00a0[21]: Copied! <pre># respuesta\n</pre> # respuesta <p>Ejercicio 07</p> <p>Un n\u00famero natural es un pal\u00edndromo si se lee igual de izquierda a derecha y de derecha a izquierda.</p> <p>Por ejemplo, $14941$ es un pal\u00edndromo, mientras que $81924$ no lo es.</p> <p>Escriba un programa que indique si el n\u00famero ingresado es o no pal\u00edndromo:</p> <pre><code>terminal\nIngrese un numero: 14941\n14941 es palindromo\n</code></pre> <pre><code>terminal\nIngrese un numero: 81924\n81924 no es palindromo\n\n</code></pre> <p>Hint: Para encontrar el inverso de un string en Python, puedes utilizar la t\u00e9cnica de <code>texto[::-1]</code>.</p> In\u00a0[\u00a0]: Copied! <pre># respuesta\n</pre> # respuesta In\u00a0[22]: Copied! <pre># respuesta\n</pre> # respuesta <p>Ejercicio 02</p> <p>Solicita al usuario un n\u00famero y calcula la suma de todos los n\u00fameros pares desde 2 hasta ese n\u00famero. Utiliza la declaraci\u00f3n <code>while</code> para resolver este problema.</p> <pre><code>Ingrese un n\u00famero: 10\nLa suma de n\u00fameros pares desde 2 hasta 10 es 30\n</code></pre> In\u00a0[23]: Copied! <pre># respuesta\n</pre> # respuesta <p>Ejercicio 03</p> <p>Solicita al usuario un n\u00famero entero y suma todos sus d\u00edgitos. Utiliza la declaraci\u00f3n <code>while</code> para resolver este problema.</p> <pre><code>Ingrese un n\u00famero entero: 12345\nLa suma de los d\u00edgitos es 15\n</code></pre> In\u00a0[23]: Copied! <pre># respuesta\n</pre> # respuesta <p>Ejercicio 04</p> <p>Pide al usuario un n\u00famero y cuenta cu\u00e1ntos de sus d\u00edgitos son pares. Utiliza la declaraci\u00f3n <code>while</code> para resolver este problema.</p> <pre><code>Ingrese un n\u00famero: 123456\nEl n\u00famero tiene 3 d\u00edgitos pares.\n</code></pre> In\u00a0[23]: Copied! <pre># respuesta\n</pre> # respuesta <p>Ejercicio 05</p> <p>Solicita al usuario un n\u00famero y cuenta cu\u00e1ntos n\u00fameros en el rango de 1 a ese n\u00famero son divisibles por 7. Utiliza la declaraci\u00f3n <code>while</code> para resolver este problema.</p> <pre><code>Ingrese un n\u00famero: 20\nHay 2 n\u00fameros divisibles por 7 en el rango de 1 a 20.\n</code></pre> In\u00a0[3]: Copied! <pre># respuesta\n</pre> # respuesta <p>Ejercicio 06</p> <p>Solicita al usuario un n\u00famero y cuenta cu\u00e1ntos de sus d\u00edgitos son impares. Utiliza la declaraci\u00f3n <code>while</code> para resolver este problema.</p> <pre><code>Ingrese un n\u00famero: 7654321\nEl n\u00famero tiene 4 d\u00edgitos impares.\n</code></pre> In\u00a0[\u00a0]: Copied! <pre># respuesta\n</pre> # respuesta In\u00a0[\u00a0]: Copied! <pre># respuesta\n</pre> # respuesta <p>Ejercicio 02</p> <p>Muestra un contador regresivo desde un n\u00famero ($n$) dado hasta 1. Utiliza la declaraci\u00f3n <code>range</code> para resolver este problema.</p> <pre><code>Ingrese un n\u00famero: 5\nContador regresivo desde 5 hasta 1:\n5\n4\n3\n2\n1\n</code></pre> In\u00a0[\u00a0]: Copied! <pre># respuesta\n</pre> # respuesta <p>Ejercicio 03</p> <p>Muestra la tabla de multiplicar de un n\u00famero dado. Utiliza la declaraci\u00f3n <code>range</code> para resolver este problema.</p> <pre><code>Ingrese un n\u00famero: 7\nTabla de multiplicar del 7:\n7 x 1 = 7\n7 x 2 = 14\n7 x 3 = 21\n7 x 4 = 28\n7 x 5 = 35\n7 x 6 = 42\n7 x 7 = 49\n7 x 8 = 56\n7 x 9 = 63\n7 x 10 = 70\n</code></pre> In\u00a0[\u00a0]: Copied! <pre># respuesta\n</pre> # respuesta <p>Ejercicio 04</p> <p>Escribe un programa que solicite al usuario un n\u00famero entero positivo y luego calcule la suma de los cuadrados de todos los n\u00fameros desde 1 hasta el n\u00famero ingresado. Utiliza la declaraci\u00f3n <code>range</code> para generar los n\u00fameros en el rango y luego suma los cuadrados de esos n\u00fameros.</p> <p>Ejemplos</p> <ol> <li><p>Si el usuario ingresa el n\u00famero 4, el programa calcular\u00e1 la suma de los cuadrados de los n\u00fameros desde 1 hasta 4 de la siguiente manera:</p> <p>Suma = 1^2 + 2^2 + 3^2 + 4^2 = 1 + 4 + 9 + 16 = 30</p> <p>El programa mostrar\u00e1: \"La suma de los cuadrados de los n\u00fameros en el rango de 1 a 4 es 30.\"</p> </li> </ol> In\u00a0[1]: Copied! <pre># respuesta\n</pre> # respuesta In\u00a0[\u00a0]: Copied! <pre># respuesta\n</pre> # respuesta <p>Ejercicio 02</p> <p>Calcula la suma de los n\u00fameros en un rango dado (por ejemplo, de 1 a 10), pero omite los m\u00faltiplos de 3 utilizando la declaraci\u00f3n <code>continue</code>.</p> <pre><code>Ingrese un n\u00famero: 10\nLa suma de los n\u00fameros no divisibles por 3 en el rango de 1 a 10 es 37\n</code></pre> In\u00a0[\u00a0]: Copied! <pre># respuesta\n</pre> # respuesta <p>Ejercicio 03</p> <p>Dada una lista de n\u00fameros enteros, solicita al usuario un n\u00famero objetivo y busca si el n\u00famero est\u00e1 en la lista. Utiliza un bucle con <code>break</code> para detener la b\u00fasqueda una vez que encuentres el n\u00famero o determines que no est\u00e1 en la lista.</p> In\u00a0[\u00a0]: Copied! <pre># respuesta\n</pre> # respuesta <p>Ejercicio 04</p> <p>Simula un juego en el que la computadora \"piensa\" en un n\u00famero y el jugador intenta adivinarlo. Crea un bucle que permita al jugador hacer intentos para adivinar el n\u00famero, y utiliza <code>break</code> para salir del bucle si el jugador adivina el n\u00famero o excede un n\u00famero m\u00e1ximo de intentos.</p> <p>Hint: Considera la siguiente rutina para partir tu c\u00f3digo:</p> <pre>import random\n\n# Generar un n\u00famero aleatorio entre 1 y 100\nnumero_secreto = random.randint(1, 100)\n\n# N\u00famero m\u00e1ximo de intentos permitidos\nintentos_maximos = 10\n\n# ....\n</pre> In\u00a0[2]: Copied! <pre># respuesta\n</pre> # respuesta"},{"location":"flujo/#control-de-flujo","title":"Control de Flujo\u00b6","text":""},{"location":"flujo/#condicional-if-elif-else","title":"Condicional if-elif-else\u00b6","text":""},{"location":"flujo/#condicional-if","title":"Condicional if\u00b6","text":"<p>La sentencia <code>if</code> (\u00absi\u00bb) ejecuta las instrucciones s\u00f3lo si se cumple una condici\u00f3n. Si la condici\u00f3n es falsa, no se hace nada:</p> <p>La sintaxis es la siguiente:</p> <p></p> <pre>if condici\u00f3n:\n    sentencias\n</pre> <p>Ejemplos</p>"},{"location":"flujo/#condicional-if-else","title":"Condicional if-else\u00b6","text":"<p>La sentencia <code>if-else</code> (\u00absi-o-si-no\u00bb) decide qu\u00e9 instrucciones ejecutar dependiendo si una condici\u00f3n es verdadera o falsa:</p> <p></p> <pre>if condici\u00f3n:\n    qu\u00e9 hacer cuando la condici\u00f3n es verdadera\nelse\n    qu\u00e9 hacer cuando la condici\u00f3n es falsa\n</pre>"},{"location":"flujo/#condicional-if-elif-else","title":"Condicional if-elif-else\u00b6","text":"<p>La sentencia <code>if-elif-else</code> depende de dos o m\u00e1s condiciones, que son evaluadas en orden. La primera que es verdadera determina qu\u00e9 instrucciones ser\u00e1n ejecutadas:</p> <p></p> <p>La sintaxis es la siguiente:</p> <pre>if condici\u00f3n1:\n    qu\u00e9 hacer si condici\u00f3n1 es verdadera\nelif condici\u00f3n2:\n    qu\u00e9 hacer si condici\u00f3n2 es verdadera\n...\nelse:\n    qu\u00e9 hacer cuando ninguna de las\n    condiciones anteriores es verdadera\n</pre>"},{"location":"flujo/#while-loop","title":"While Loop\u00b6","text":"<p>El ciclo while (\u00abmientras\u00bb) ejecuta una secuencia de instrucciones mientras una condici\u00f3n sea verdadera:</p> <p>Cada una de las veces que el cuerpo del ciclo es ejecutado se llama iteraci\u00f3n.</p> <p>La condici\u00f3n es evaluada antes de cada iteraci\u00f3n. Si la condici\u00f3n es inicialmente falsa, el ciclo no se ejecutar\u00e1 ninguna vez.</p> <p></p> <p>La sintaxis es la siguiente:</p> <pre>while condici\u00f3n:\n    sentencias\n</pre> <p>Notas adicionales:</p> <ul> <li>A una ejecuci\u00f3n de las instrucciones que componen el ciclo se le llama iteraci\u00f3n.</li> <li>La condici\u00f3n de un while es evaluada antes de cada iteraci\u00f3n.</li> <li>Por lo anterior, es posible que un <code>while</code> no ejecute ninguna iteraci\u00f3n, si la condici\u00f3n es False al inicio.</li> </ul>"},{"location":"flujo/#ejemplo-acumulacion-con-suma","title":"Ejemplo:  acumulaci\u00f3n con suma\u00b6","text":"<p>Escriba un programa que reciba como entrada un n\u00famero entero. El programa debe mostrar el resultado de la suma de los n\u00fameros al cuadrado desde el $1$ hasta el valor ingresado. $$ 1^2+2^2+\\ldots+(n-1)^2+n^2 $$</p>"},{"location":"flujo/#ejemplo-acumulacion-con-multiplicacion","title":"Ejemplo: acumulaci\u00f3n con multiplicaci\u00f3n\u00b6","text":"<p>Escriba una programa que calcule el factorial de un n\u00famero $n$ ingresada como entrada: $10! = 1\\cdot 2 \\cdot 3 ... \\cdot 10$</p>"},{"location":"flujo/#ejemplo-conteo","title":"Ejemplo: conteo\u00b6","text":"<p>Escriba un programa que solicite un n\u00famero entero y calcule cuantos n\u00fameros son divisibles por 3 o 5.</p>"},{"location":"flujo/#ciclo-for-con-rango","title":"Ciclo for con rango\u00b6","text":"<p>El ciclo for con rango ejecuta una secuencia de sentencias una cantidad fija de veces.</p> <p>Para llevar la cuenta, utiliza una variable de control que toma valores distintos en cada iteraci\u00f3n.</p> <p>Una de las sintaxis para usar un for con rango es la siguiente:</p> <pre>for variable in range(fin):\n    qu\u00e9 hacer para cada valor de la variable de control\n</pre> <p>En la primera iteraci\u00f3n, la variable de control toma el valor 0. Al final de cada iteraci\u00f3n, el valor de la variable aumenta autom\u00e1ticamente. El ciclo termina justo antes que la variable tome el valor fin.</p> <p>Por ejemplo, el siguiente programa muestra los cubos de los n\u00fameros del 0 al 20:</p>"},{"location":"flujo/#salir-o-continuar-un-ciclo","title":"Salir o continuar un ciclo\u00b6","text":""},{"location":"flujo/#break","title":"Break\u00b6","text":"<p>Adem\u00e1s de las condiciones de t\u00e9rmino propias de los ciclos <code>while</code> y <code>for</code>, siempre es posible salir de un ciclo en medio de una iteraci\u00f3n usando la sentencia <code>break</code>. Lo l\u00f3gico es que sea usada dentro de un <code>if</code>, para evitar que el ciclo termine prematuramente en la primera iteraci\u00f3n:</p> <p></p>"},{"location":"flujo/#continue","title":"Continue\u00b6","text":"<p>La sentencia <code>continue</code> se usa para saltar a la iteraci\u00f3n siguiente sin llegar al final de la que est\u00e1 en curso.</p> <p></p>"},{"location":"flujo/#ejercicios","title":"Ejercicios\u00b6","text":""},{"location":"flujo/#if-elif-else","title":"if-elif-else\u00b6","text":"<p>Ejercicio 01</p> <p>Escriba un programa que determine si el n\u00famero entero ingresado por el usuario es par o no.</p> <pre><code>terminal\nIngrese un n\u00famero: 4\nSu n\u00famero es par\n</code></pre> <pre><code>terminal\nIngrese un n\u00famero: 3\nSu n\u00famero es impar\n</code></pre>"},{"location":"flujo/#while","title":"While\u00b6","text":"<p>Ejercicio 01</p> <p>Solicita al usuario un n\u00famero y muestra un contador regresivo desde ese n\u00famero hasta 1. Utiliza la declaraci\u00f3n <code>while</code> para resolver este problema.</p> <pre><code>Ingrese un n\u00famero: 5\nContador regresivo desde 5 hasta 1:\n5\n4\n3\n2\n1\n</code></pre>"},{"location":"flujo/#range","title":"Range\u00b6","text":"<p>Ejercicio 01</p> <p>Calcula la suma de todos los n\u00fameros pares desde 1 hasta un n\u00famero dado ($n$). Utiliza la declaraci\u00f3n <code>range</code> para resolver este problema.</p> <pre><code>Ingrese un n\u00famero: 10\nLa suma de n\u00fameros pares desde 1 hasta 10 es 30\n</code></pre>"},{"location":"flujo/#break-continue","title":"Break &amp; Continue\u00b6","text":"<p>Ejercicio 01</p> <p>Solicita al usuario un n\u00famero y cuenta cu\u00e1ntos de sus d\u00edgitos son pares. Utiliza la declaraci\u00f3n <code>continue</code> para omitir los d\u00edgitos impares.</p> <pre><code>Ingrese un n\u00famero: 123456\nEl n\u00famero tiene 3 d\u00edgitos pares.\n</code></pre>"},{"location":"funcional/","title":"Programaci\u00f3n Funcional","text":"In\u00a0[1]: Copied! <pre># funcion suma de dos numeros\ndef suma(val1=0, val2=0):\n    return val1 + val2\n</pre> # funcion suma de dos numeros def suma(val1=0, val2=0):     return val1 + val2  In\u00a0[2]: Copied! <pre>resultado = suma(10,20)\nprint(resultado)\n</pre> resultado = suma(10,20) print(resultado) <pre>30\n</pre> In\u00a0[3]: Copied! <pre># un argumento\nfuncion = lambda a : 1+a\nprint(funcion(3))\n</pre> # un argumento funcion = lambda a : 1+a print(funcion(3)) <pre>4\n</pre> In\u00a0[4]: Copied! <pre># varios argumentos\nsuma = lambda val1=0, val2=0: val1 + val2\nprint(suma(10,20))\n</pre> # varios argumentos suma = lambda val1=0, val2=0: val1 + val2 print(suma(10,20)) <pre>30\n</pre> In\u00a0[5]: Copied! <pre>#Obtener el cuadrado de todos los elementos en la lista.\n\ndef cuadrado(elemento=0):\n    return elemento * elemento\n</pre> #Obtener el cuadrado de todos los elementos en la lista.  def cuadrado(elemento=0):     return elemento * elemento In\u00a0[6]: Copied! <pre>lista = [1,2,3,4,5,6,7,8,9,10]\nresultado = list( map(cuadrado, lista) )\nprint(resultado)\n</pre> lista = [1,2,3,4,5,6,7,8,9,10] resultado = list( map(cuadrado, lista) ) print(resultado) <pre>[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n</pre> In\u00a0[7]: Copied! <pre>#Obtener la cantidad de elementos mayores a 5 en la tupla.\n\ndef mayor_a_cinco(elemento):\n    return elemento &gt; 5\n</pre> #Obtener la cantidad de elementos mayores a 5 en la tupla.  def mayor_a_cinco(elemento):     return elemento &gt; 5 In\u00a0[8]: Copied! <pre>tupla = (5,2,6,7,8,10,77,55,2,1,30,4,2,3)\nresultado = tuple(filter( mayor_a_cinco, tupla))\nprint(resultado)\n</pre> tupla = (5,2,6,7,8,10,77,55,2,1,30,4,2,3) resultado = tuple(filter( mayor_a_cinco, tupla)) print(resultado) <pre>(6, 7, 8, 10, 77, 55, 30)\n</pre> In\u00a0[9]: Copied! <pre>#Obtener la suma de todos los elementos en la lista\n\nlista = [1,2,3,4]\nacumulador = 0;\n\nfor elemento in lista:\n    acumulador += elemento\n\nprint(acumulador)\n</pre> #Obtener la suma de todos los elementos en la lista  lista = [1,2,3,4] acumulador = 0;  for elemento in lista:     acumulador += elemento  print(acumulador) <pre>10\n</pre> <p>Como observamos, para resolver el problema tuvimos que declarar una variable (acumulador). Variable que comienza con el valor de 0. Al recorrer la lista, el valor de nuestra variable incrementa. Su nuevo valor es el valor actual m\u00e1s el valor del elemento en la lista. Hasta aqu\u00ed no creo que exista alguna duda.</p> <p>Ahora veamos el mismo ejemplo utilizando la funci\u00f3n <code>reduce</code>.</p> In\u00a0[10]: Copied! <pre>from functools import reduce\n\nlista = [1,2,3,4]\n\ndef funcion_acumulador(acumulador=0, elemento=0):\n    return acumulador + elemento\n\nresultado = reduce(funcion_acumulador, lista)\nprint(resultado)\n</pre> from functools import reduce  lista = [1,2,3,4]  def funcion_acumulador(acumulador=0, elemento=0):     return acumulador + elemento  resultado = reduce(funcion_acumulador, lista) print(resultado) <pre>10\n</pre> <p>Por cada elemento de la colecci\u00f3n se ejecuta la funci\u00f3n, <code>funcion_acumulador</code>. La funci\u00f3n retorna la suma de los par\u00e1metros, este valor es almacenado en nuestro acumulador. Al finalizar la iteraci\u00f3n de todos los elementos, <code>reduce</code> retornar\u00e1 el valor del acumulador.</p> <p></p> In\u00a0[\u00a0]: Copied! <pre># respuesta\n</pre> # respuesta <p>Ejercicio 02</p> <p>Ocupando la notaci\u00f3n <code>map</code>, crear una funci\u00f3n que tome una lista de d\u00edgitos y analice si el n\u00famero objetivo es primo o no.</p> In\u00a0[\u00a0]: Copied! <pre># respuesta\n</pre> # respuesta <p>Ejercicio 03</p> <p>Ocupando la notaci\u00f3n <code>filter</code>, crear una funci\u00f3n que tome una lista de d\u00edgitos y analice si el n\u00famero objetivo es un cuadrado perfecto o no.</p> In\u00a0[\u00a0]: Copied! <pre># respuesta\n</pre> # respuesta <p>Ejercicio 04</p> <p>Ocupando la notaci\u00f3n <code>reduce</code>, crear una funci\u00f3n que tome una lista de d\u00edgitos y devuelva al n\u00famero al que corresponden.</p> <p>Por ejemplo <code>[1,2,3]</code> corresponde a el numero ciento veintitr\u00e9s ($123$).</p> In\u00a0[\u00a0]: Copied! <pre># respuesta\n</pre> # respuesta"},{"location":"funcional/#programacion-funcional","title":"Programaci\u00f3n Funcional\u00b6","text":""},{"location":"funcional/#paradigmas-de-programacion","title":"Paradigmas de programaci\u00f3n\u00b6","text":"<p>Python es un lenguaje de programaci\u00f3n interpretado cuya filosof\u00eda hace hincapi\u00e9 en la legibilidad de su c\u00f3digo. Se trata de un lenguaje de programaci\u00f3n multiparadigma, ya que soporta orientaci\u00f3n a objetos, programaci\u00f3n imperativa y, en menor medida, programaci\u00f3n funcional.</p> <p>Quiere decir que acepta diversas formar de trabajar con el lenguaje. B\u00e1sicamente existen 3 paradigmas predominantes, o dicho de otra manera, 3 formatos globales de organizar un c\u00f3digo.</p> <ul> <li><p>Programaci\u00f3n imperativa (estructurada), el c\u00f3digo ser\u00e1 ejecutado desde el principio del fichero al final sin seguir ning\u00fan tipo de desviaci\u00f3n. Su mayor ventaja radica en su simplicidad y poco peso. Su peligrosidad es el c\u00f3digo espagueti, archivos con centenares o miles de l\u00edneas donde solo unos pocos seres humanos son capaces de modificar y salir victoriosos.</p> </li> <li><p>Programaci\u00f3n orientada a objetos (OOP o Object Oriented Programming), donde se encapsulan las variables y funciones en peque\u00f1os m\u00f3dulos capaces de clonarse y modificarse. Su punto fuerte es la capacidad de re-utilizaci\u00f3n y aislamiento para evitar problemas con otras funcionalidades. La parte negativa recae en la complejidad de crear buenos objetos y la depuraci\u00f3n.</p> </li> <li><p>Programaci\u00f3n funcional (FP o Functional programming), donde el c\u00f3digo se reparte en sencillas funciones capaces de ser invocadas con variables u otras funciones. Su facilidad de uso por atomicidad logra un mantenimiento s\u00f3lido y compatible con casi cualquier lenguaje. Adem\u00e1s su inmutabilidad de variables evita gran parte de los problemas que si sufre la programaci\u00f3n orientada a objetos.</p> </li> </ul> <p>Para seguir profundizando, leer el libro Clean Architecture - Robert C. Martin.</p>"},{"location":"funcional/#principios-de-la-programacion-funcional","title":"Principios de la programaci\u00f3n funcional\u00b6","text":"<ul> <li><p>Uso de funciones: Como su nombre indica, todo se construye por medio de funciones.</p> </li> <li><p>Funciones de primera clase: Las funciones son tratadas como una variable m\u00e1s. Incluso pueden ser devueltas.</p> </li> <li><p>Funciones puras: Totalmente predictivo, los mismos datos de entrada producir\u00e1n los mismos datos de salida. Puedes sustituir el par\u00e1metro de entrada de sin que ello altere el flujo del programa.</p> </li> <li><p>Recursividad: Las funciones se pueden llamar a si mismas simplificando tareas como recorrer \u00e1rboles de datos o la gesti\u00f3n de bucles controlados.</p> </li> <li><p>Inmutabilidad: No hay variables, solo constantes.</p> </li> <li><p>Evaluaci\u00f3n perezosa (no estricta): En la programaci\u00f3n funcional podemos trabajar con expresiones que no han sido evaluadas, o dicho de otra manera, podemos disponer de variables con operaciones cuyo resultado a\u00fan no se conoce.</p> </li> </ul>"},{"location":"funcional/#funciones","title":"Funciones\u00b6","text":"<p>Las funciones en Python es que estas pueden ser asignadas a variables, lo cual nos abre la puerta a que funciones puedan ser usadas como argumento de otras funciones y que funciones retornen funciones.</p>"},{"location":"funcional/#funciones-anonimas-o-lambdas","title":"Funciones an\u00f3nimas o lambdas\u00b6","text":"<p>Habr\u00e1 ocasiones en las cuales necesitemos crear funciones de manera r\u00e1pida, en tiempo de ejecuci\u00f3n. Funciones las cuales realizan una tarea en concreto, regularmente peque\u00f1a. En estos casos haremos uso de funciones <code>lambda</code>.</p> <p>Una funci\u00f3n <code>lambda</code> es una funci\u00f3n an\u00f3nima, una funci\u00f3n que no posee un nombre. En Python la estructura de una funci\u00f3n <code>lambda</code> es la siguiente.</p> <pre><code>terminal\nlambda argumentos : cuerpo de la funci\u00f3n\n\n</code></pre>"},{"location":"funcional/#funcion-map","title":"Funci\u00f3n map\u00b6","text":"<p>La funci\u00f3n <code>map</code>  permite aplicar una funci\u00f3n a una secuencia de elementos como un iterable (Listas, tuplas, etc...). Es una forma r\u00e1pida, limpia y, lo que es m\u00e1s importante, legible de realizar la operaci\u00f3n.</p> <p>La estructura de la funci\u00f3n es la siguiente.</p> <pre><code>terminal\nmap(funci\u00f3n a aplicar, objeto iterable)\n</code></pre>"},{"location":"funcional/#funcion-filter","title":"Funci\u00f3n filter\u00b6","text":"<p>La funci\u00f3n <code>filter</code>, es quiz\u00e1s, una de las funciones m\u00e1s utilizadas al momento de trabajar con colecciones. C\u00f3mo su nombre lo indica, esta funci\u00f3n nos permite realizar un filtro sobre los elementos de la colecci\u00f3n.</p> <p>La estructura de la funci\u00f3n es la siguiente.</p> <pre><code>terminal\nfilter(funci\u00f3n a aplicar, objeto iterable)\n</code></pre>"},{"location":"funcional/#funcion-reduce","title":"Funci\u00f3n reduce\u00b6","text":"<p>Usaremos la funci\u00f3n <code>reduce</code> cuando poseamos una colecci\u00f3n de elementos y necesitemos generar un \u00fanico resultado. reduce nos permitir\u00e1 reducir los elementos de la colecci\u00f3n. Podemos ver a esta funci\u00f3n como un acumulador.</p> <p>La estructura de la funci\u00f3n es la siguiente.</p> <pre><code>terminal\nreduce(funci\u00f3n a aplicar, objeto iterable)\n</code></pre>"},{"location":"funcional/#ejercicios","title":"Ejercicios\u00b6","text":"<p>Ejercicio 01</p> <p>Ocupando la notaci\u00f3n <code>lambda</code>, crear las funciones operacionales b\u00e1sicas, es decir,</p> <ul> <li>suma</li> <li>resta</li> <li>multiplicaici\u00f3n</li> <li>divisi\u00f3n</li> <li>resto</li> <li>potencia</li> </ul>"},{"location":"funciones/","title":"Funciones","text":"In\u00a0[1]: Copied! <pre>def suma(a, b):\n    return a + b\n\nresultado = suma(3, 5)\nprint(resultado)\n</pre> def suma(a, b):     return a + b  resultado = suma(3, 5) print(resultado) <pre>8\n</pre> <p>En este ejemplo se define una funci\u00f3n llamada <code>suma</code> que recibe dos par\u00e1metros <code>a</code> y <code>b</code> y devuelve la suma de ambos. Se llama a la funci\u00f3n con los valores <code>3</code> y <code>5</code> y se almacena el resultado en una variable llamada <code>resultado</code>. Finalmente, se imprime el valor de <code>resultado</code>.</p> <p>Por otro lado, dado que no se especifica el tipo de datos, podemos sumar dos <code>strings</code></p> In\u00a0[3]: Copied! <pre>resultado = suma(\"Hola \",\"Mundo\")\nprint(resultado)\n</pre> resultado = suma(\"Hola \",\"Mundo\") print(resultado) <pre>Hola Mundo\n</pre> <p>Por lo que se debe tener cuidado tanto con el nombre de la funci\u00f3n (se espera que pueda resumir la funcion en una o dos palabras) y el tipo de argumentos que queremos que reciba.</p> <p>Las funciones tambi\u00e9n pueden tener argumentos opcionales que tienen un valor por defecto. Para definir un argumento opcional se utiliza el operador <code>=</code> para asignarle un valor por defecto. El valor por defecto se utiliza si el argumento no es especificado al llamar a la funci\u00f3n.</p> In\u00a0[4]: Copied! <pre>def saludo(nombre, saludo=\"Hola\"):\n    print(saludo, nombre)\n\nsaludo(\"Pedro\")\nsaludo(\"Maria\", \"Buenos d\u00edas\")\n</pre> def saludo(nombre, saludo=\"Hola\"):     print(saludo, nombre)  saludo(\"Pedro\") saludo(\"Maria\", \"Buenos d\u00edas\") <pre>Hola Pedro\nBuenos d\u00edas Maria\n</pre> <p>En este ejemplo se define una funci\u00f3n llamada <code>saludo</code> que recibe dos argumentos, <code>nombre</code> y <code>saludo</code>. El argumento saludo tiene un valor por defecto de <code>\"Hola\"</code>. La funci\u00f3n imprime el mensaje de saludo utilizando los valores de <code>saludo</code> y <code>nombre</code>. Se llama a la funci\u00f3n con diferentes valores de argumentos.</p> <p>A continuaci\u00f3n, se crear\u00e1 la funci\u00f3n <code>factorial</code>, la cual entregar\u00e1 el factorial de un n\u00famero entero no negativo.</p> In\u00a0[5]: Copied! <pre>def factorial(n):\n    \"\"\"\n    factorial de un numero entero no negativo\n    \"\"\"\n    f = 1\n    for i in range(1, n + 1):\n        f *= i\n    return f\n</pre> def factorial(n):     \"\"\"     factorial de un numero entero no negativo     \"\"\"     f = 1     for i in range(1, n + 1):         f *= i     return f <p>En este ejemplo, el resultado que entrega una llamada a la funci\u00f3n es el valor que tiene la variable <code>f</code> al llegar a la \u00faltima l\u00ednea de la funci\u00f3n.</p> <p>Una vez creada, la funci\u00f3n puede ser usada como cualquier otra, todas las veces que sea necesario:</p> In\u00a0[6]: Copied! <pre>print(factorial(0))\n</pre> print(factorial(0)) <pre>1\n</pre> In\u00a0[7]: Copied! <pre>print(factorial(2) + factorial(5))\n</pre> print(factorial(2) + factorial(5)) <pre>122\n</pre> <p>Las variables que son creadas dentro de la funci\u00f3n (incluyendo los par\u00e1metros y el resultado) se llaman variables locales, y s\u00f3lo son visibles dentro de la funci\u00f3n, no desde el resto del programa.</p> <p>Por otra parte, las variables creadas fuera de alguna funci\u00f3n se llaman variables globales, y son visibles desde cualquier parte del programa. Sin embargo, su valor no puede ser modificado, ya que una asignaci\u00f3n crear\u00eda una variable local del mismo nombre.</p> In\u00a0[8]: Copied! <pre># ejemplo variable global\n\nvalor = 10 # variable global\n\ndef funcion_01(x):\n    return valor*x\n</pre> # ejemplo variable global  valor = 10 # variable global  def funcion_01(x):     return valor*x In\u00a0[27]: Copied! <pre>print(funcion_01(5))\n</pre> print(funcion_01(5)) <pre>50\n</pre> In\u00a0[10]: Copied! <pre># ejemplo variable local\n\ndef funcion_02(x,valor):\n    \n    resultado = valor*x\n    \n    return resultado\n</pre> # ejemplo variable local  def funcion_02(x,valor):          resultado = valor*x          return resultado In\u00a0[28]: Copied! <pre>print(funcion_02(5,2))\n</pre> print(funcion_02(5,2)) <pre>10\n</pre> <p>Nota: Dependiendo del uso que le d\u00e9 a su c\u00f3digo es que ocupar\u00e1 variables globales o no, sin embargo, es preferible definir su funci\u00f3n solo con variables locales, puesto que esto deja expl\u00edcita la dependencia de dicha variable dentro de su funci\u00f3n objetivo.</p> <p>Por otro lado, existen funciones que no necesariamente reciben argumentos.</p> In\u00a0[12]: Copied! <pre>def imprimir_pantalla():\n    return \"Mensaje random\"\n</pre> def imprimir_pantalla():     return \"Mensaje random\" In\u00a0[13]: Copied! <pre>imprimir_pantalla()\n</pre> imprimir_pantalla() Out[13]: <pre>'Mensaje random'</pre> <p>Tambi\u00e9n, existen funciones que no retornan valores:</p> In\u00a0[14]: Copied! <pre>def imprimir_nombre(nombre):\n    print(nombre)\n</pre> def imprimir_nombre(nombre):     print(nombre) In\u00a0[15]: Copied! <pre>imprimir_nombre(\"nombre_01\")\n</pre> imprimir_nombre(\"nombre_01\") <pre>nombre_01\n</pre> In\u00a0[16]: Copied! <pre># funcion factorial (recursivo)\n\ndef factorial(n):\n    \"\"\"\n    Funcion factorial de manera recursiva\n    \"\"\"\n    if n == 1:\n        return 1\n    else:\n        return (n * factorial(n-1))\n</pre> # funcion factorial (recursivo)  def factorial(n):     \"\"\"     Funcion factorial de manera recursiva     \"\"\"     if n == 1:         return 1     else:         return (n * factorial(n-1))     <p>Analicemos recursivamente el factorial del n\u00famero $3$.</p> <p> </p> In\u00a0[17]: Copied! <pre>num = 3\nprint(f\"El factorial de {num} es {factorial(num)}\")\n</pre> num = 3 print(f\"El factorial de {num} es {factorial(num)}\")  <pre>El factorial de 3 es 6\n</pre> <p>Funci\u00f3n Definida de Manera Convencional:</p> In\u00a0[1]: Copied! <pre>def cuadrado_normal(x):\n    \"\"\"\n    Funci\u00f3n que eleva al cuadrado un n\u00famero.\n    \"\"\"\n    return x ** 2\n\n# Llamamos a la funci\u00f3n convencional\nresultado_normal = cuadrado_normal(5)\nprint(resultado_normal)\n</pre> def cuadrado_normal(x):     \"\"\"     Funci\u00f3n que eleva al cuadrado un n\u00famero.     \"\"\"     return x ** 2  # Llamamos a la funci\u00f3n convencional resultado_normal = cuadrado_normal(5) print(resultado_normal) <pre>25\n</pre> <p>Funci\u00f3n Lambda:</p> In\u00a0[2]: Copied! <pre># Definimos una funci\u00f3n lambda para elevar al cuadrado un n\u00famero\ncuadrado = lambda x: x ** 2\n\n# Llamamos a la funci\u00f3n lambda\nresultado_lambda = cuadrado(5)\nprint(resultado_lambda)\n</pre> # Definimos una funci\u00f3n lambda para elevar al cuadrado un n\u00famero cuadrado = lambda x: x ** 2  # Llamamos a la funci\u00f3n lambda resultado_lambda = cuadrado(5) print(resultado_lambda) <pre>25\n</pre> <p>Explicaci\u00f3n:</p> <ul> <li><p>En el primer ejemplo, se define una funci\u00f3n convencional llamada <code>cuadrado_normal</code> que toma un argumento <code>x</code> y devuelve el cuadrado de <code>x</code> utilizando la declaraci\u00f3n <code>return</code>.</p> </li> <li><p>En el segundo ejemplo, se crea una funci\u00f3n lambda que realiza la misma operaci\u00f3n. La funci\u00f3n lambda se define como <code>lambda x: x ** 2</code>, donde <code>x</code> es el argumento de entrada y <code>x ** 2</code> es la expresi\u00f3n que se eval\u00faa y devuelve.</p> </li> <li><p>Luego, llamamos tanto a la funci\u00f3n convencional como a la funci\u00f3n lambda con un valor de <code>5</code> como argumento, y guardamos los resultados en las variables <code>resultado_normal</code> y <code>resultado_lambda</code>, respectivamente.</p> </li> <li><p>Finalmente, imprimimos los resultados, que ser\u00e1n <code>25</code> tanto para la funci\u00f3n convencional como para la funci\u00f3n lambda, ya que ambas calculan el cuadrado de <code>5</code>.</p> </li> </ul> In\u00a0[3]: Copied! <pre>def sumar_numeros(*numeros):\n    suma = 0\n    for numero in numeros:\n        suma += numero\n    return suma\n\nresultado = sumar_numeros(1, 2, 3, 4)\nprint(resultado)\n</pre> def sumar_numeros(*numeros):     suma = 0     for numero in numeros:         suma += numero     return suma  resultado = sumar_numeros(1, 2, 3, 4) print(resultado) <pre>10\n</pre> <p>En el primer ejemplo, se define la funci\u00f3n <code>sumar_numeros</code>, que toma un n\u00famero variable de argumentos no nombrados. La funci\u00f3n suma todos los argumentos recibidos y devuelve el resultado. En este caso, llamamos a la funci\u00f3n con los n\u00fameros <code>1, 2, 3, 4</code>, y la suma se almacena en <code>resultado</code>.</p> <p>**Usando <code>**kwargs</code>:**</p> In\u00a0[4]: Copied! <pre>def imprimir_datos(**datos):\n    for llave, valor in datos.items():\n        print(llave, \":\", valor)\n\nimprimir_datos(nombre=\"Juan\", edad=25, ciudad=\"Lima\")\n</pre> def imprimir_datos(**datos):     for llave, valor in datos.items():         print(llave, \":\", valor)  imprimir_datos(nombre=\"Juan\", edad=25, ciudad=\"Lima\") <pre>nombre : Juan\nedad : 25\nciudad : Lima\n</pre> <p>En el segundo ejemplo, se define la funci\u00f3n <code>imprimir_datos</code>, que toma un n\u00famero variable de argumentos con nombre. La funci\u00f3n itera a trav\u00e9s del diccionario <code>datos</code> y muestra las claves y sus valores asociados. Llamamos a la funci\u00f3n con argumentos con nombre, como \"nombre\", \"edad\" y \"ciudad\", y se imprime la informaci\u00f3n correspondiente.</p> <p>Nota: Es importante recordar que aunque <code>*args</code> y <code>**kwargs</code> son \u00fatiles, se recomienda ser expl\u00edcito en la definici\u00f3n de tus funciones siempre que sea posible para hacer el c\u00f3digo m\u00e1s legible y mantenible.</p> <p>Ejercicio 01</p> <p>Escriba una funci\u00f3n que se llame <code>saludar</code> que reciba como input un string s y devuelva como output \"Hola + valor de s\".</p> <ul> <li>Ejemplo: saludar(\"mundo\") = \"Hola mundo\"</li> </ul> In\u00a0[\u00a0]: Copied! <pre># respuesta\n</pre> # respuesta <p>Ejercicio 02</p> <p>Escriba una funci\u00f3n que se llame <code>es_par</code> que reciba como input un n\u00famero entero n y devuelva como output True si el n\u00famero es par, y False en otro caso.</p> <ul> <li>Ejemplo:<ul> <li>es_par(4) = True</li> <li>es_par(3) = False</li> </ul> </li> </ul> In\u00a0[\u00a0]: Copied! <pre># respuesta\n</pre> # respuesta <p>Ejercicio 03</p> <p>Escriba la funci\u00f3n <code>invertir_digitos(n)</code> que reciba un n\u00famero entero n y entregue como resultado el n\u00famero <code>n</code> con los d\u00edgitos en el orden inverso:</p> <pre><code>terminal\n &gt;&gt;&gt; invertir_digitos(142)\n241\n</code></pre> <p>A continuaci\u00f3n, escriba un programa que indique si el n\u00famero ingresado es pal\u00edndromo o no, usando la funci\u00f3n <code>invertir_digitos</code>:</p> <pre><code>terminal\nIngrese n: 81418\nEs pal\u00edndromo\n</code></pre> In\u00a0[\u00a0]: Copied! <pre># respuesta\n</pre> # respuesta <p>Ejercicio 04</p> <p>Muchos de estos programas s\u00f3lo ten\u00edan peque\u00f1as diferencias entre ellos, por lo que hab\u00eda que repetir mucho c\u00f3digo al escribirlos. En este ejercicio, usted deber\u00e1 implementar algunos de esos programas como funciones, reutilizando componentes para evitar escribir c\u00f3digo repetido.</p> <p>Ejercicio 041</p> <p>Escriba la funci\u00f3n <code>es_divisible(n, d)</code> que indique si <code>n</code> es divisible por <code>d</code>:</p> <pre><code>&gt;&gt;&gt; es_divisible(15, 5)\nTrue\n&gt;&gt;&gt; es_divisible(15, 6)\nFalse\n</code></pre> <p>Ejercicio 042</p> <p>Usando la funci\u00f3n es_divisible, escriba una funci\u00f3n <code>es_primo(n)</code> que determine si un n\u00famero es primo o no:</p> <pre><code>&gt;&gt;&gt; es_primo(17)\nTrue\n&gt;&gt;&gt; es_primo(221)\nFalse\n</code></pre> <p>Ejercicio 043</p> <p>Usando la funci\u00f3n <code>es_primo</code>, escriba la funci\u00f3n <code>i_esimo_primo(i)</code> que entregue el i-\u00e9simo n\u00famero primo.</p> <pre><code>&gt;&gt;&gt; i_esimo_primo(1)\n2\n&gt;&gt;&gt; i_esimo_primo(20)\n71\n</code></pre> <p>Ejercicio 044</p> <p>Usando las funciones anteriores, escriba la funci\u00f3n <code>primeros_primos(m)</code> que entregue una lista de los primeros m n\u00fameros primos:</p> <pre><code>&gt;&gt;&gt; primeros_primos(10)\n[2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n</code></pre> <p>Ejercicio 045</p> <p>Usando las funciones anteriores, escriba la funci\u00f3n <code>primos_hasta(m)</code> que entregue una lista de los primos menores o iguales que <code>m</code>:</p> <pre><code>&gt;&gt;&gt; primos_hasta(19)\n[2, 3, 5, 7, 11, 13, 17, 19]\n</code></pre> <p>Ejercicio 046</p> <p>Un primo de Mersenne es un n\u00famero primo de la forma $2p\u22121$. Una propiedad conocida de los primos de Mersenne es que $p$ debe ser tambi\u00e9n un n\u00famero primo.</p> <p>Escriba la funci\u00f3n <code>mersenne</code> que pregunte al usuario un n\u00famero $n$, y muestre como salida los primeros <code>n</code> primos de Mersenne:</p> <pre><code>&gt;&gt;&gt; mersenne(5)\n3\n7\n31\n127\n8191\n</code></pre> In\u00a0[\u00a0]: Copied! <pre># respuesta\n</pre> # respuesta <p>Ejercicio 05</p> <p>La suma natural de los primeros n n\u00fameros naturales esta dado por: $$\\displaystyle S = \\sum_{k=1}^{n} k = 1 +2 +3 +...+n = \\dfrac{n(n+1)}{2} $$</p> <p>Escriba una funci\u00f3n que se llame <code>suma_numeros_naturales</code> que reciba como input un n\u00famero entero n y devuelva como output la suma de los primeros n n\u00fameros naturales.</p> <p>Para esto:</p> <ul> <li>a) Programe la funci\u00f3n ocupando la f\u00f3rmula manual: $S = 1+2+3+..+n$</li> <li>b) Programe la funci\u00f3n ocupando la f\u00f3rmula cerrada: $S =\\dfrac{n(n+1)}{2} $</li> </ul> <p>Ejemplo:</p> <ul> <li>suma_numeros_naturales(1) = 1</li> <li>suma_numeros_naturales(10) = 55</li> <li>suma_numeros_naturales(100) = 5050</li> </ul> In\u00a0[\u00a0]: Copied! <pre># respuesta\n</pre> # respuesta  <p>Ejercicio 06</p> <p>En los siglos XVII y XVIII, James Gregory y Gottfried Leibniz descubrieron una serie infinita que sirve para calcular $\\pi$:</p> <p>$$\\displaystyle \\pi = 4 \\sum_{k=1}^{\\infty}\\dfrac{(-1)^{k+1}}{2k-1} = 4(1-\\dfrac{1}{3}+\\dfrac{1}{5}-\\dfrac{1}{7} + ...) $$</p> <p>Desarolle un programa para estimar el valor de $\\pi$ ocupando el m\u00e9todo de Leibniz, donde la entrada del programa debe ser un n\u00famero entero $n$ que indique cu\u00e1ntos t\u00e9rminos de la suma se utilizar\u00e1.</p> <ul> <li>Ejemplo:<ul> <li>calcular_pi(3) = 3.466666666666667</li> <li>calcular_pi(1000) = 3.140592653839794</li> </ul> </li> </ul> In\u00a0[\u00a0]: Copied! <pre># respuesta\n</pre> # respuesta <p>Ejercicio 07</p> <p>Euler realiz\u00f3 varios aportes en relaci\u00f3n a $e$, pero no fue hasta 1748 cuando public\u00f3 su Introductio in analysin infinitorum que dio un tratamiento definitivo a las ideas sobre $e$. All\u00ed mostr\u00f3 que:</p> <p>En los siglos XVII y XVIII, James Gregory y Gottfried Leibniz descubrieron una serie infinita que sirve para calcular \u03c0:</p> <p>$$\\displaystyle e = \\sum_{k=0}^{\\infty}\\dfrac{1}{k!} = 1+\\dfrac{1}{2!}+\\dfrac{1}{3!}+\\dfrac{1}{4!} + ... $$</p> <p>Desarolle un programa para estimar el valor de $e$ ocupando el m\u00e9todo de Euler, donde la entrada del programa debe ser un n\u00famero entero $n$ que indique cu\u00e1ntos t\u00e9rminos de la suma se utilizar\u00e1.</p> <p>Para esto:</p> <ul> <li><p>a) Defina la funci\u00f3n <code>factorial</code>, donde la entrada sea un n\u00famero natural  $n$ y la salida sea el factorial de dicho n\u00famero.</p> <ul> <li>Ejemplo: factorial(3) =3, factorial(5) = 120</li> </ul> </li> <li><p>b) Ocupe la funci\u00f3n <code>factorial</code> dentro de la funci\u00f3n <code>calcular_e</code>.</p> <ul> <li>Ejemplo: calcular_e(3) = 2.6666666666666665, calcular_e(1000) = 2.7182818284590455</li> </ul> </li> </ul> In\u00a0[\u00a0]: Copied! <pre># respuesta\n</pre> # respuesta  <p>Ejercicio 08</p> <p>Sea $\\sigma(n)$ definido como la suma de los divisores propios de $n$ (n\u00fameros menores que n que se dividen en $n$).</p> <p>Los n\u00fameros amigos son  enteros positivos $n_1$ y $n_2$ tales que la suma de los divisores propios de uno es igual al otro n\u00famero y viceversa, es decir, $\\sigma(n_1)=\\sigma(n_2)$ y $\\sigma(n_2)=\\sigma(n_1)$.</p> <p>Por ejemplo, los n\u00fameros 220 y 284 son n\u00fameros amigos.</p> <ul> <li>los divisores propios de 220 son 1, 2, 4, 5, 10, 11, 20, 22, 44, 55 y 110; por lo tanto $\\sigma(220) = 284$.</li> <li>los divisores propios de 284 son 1, 2, 4, 71 y 142; entonces $\\sigma(284) = 220$.</li> </ul> <p>Implemente una funci\u00f3n llamada <code>amigos</code> cuyo input sean dos n\u00fameros naturales $n_1$ y $n_2$, cuyo output sea verifique si los n\u00fameros son amigos o no.</p> <p>Para esto:</p> <ul> <li><p>a) Defina la funci\u00f3n <code>divisores_propios</code>, donde la entrada sea un n\u00famero natural $n$ y la salida sea una lista con los divisores propios de dicho n\u00famero.</p> <ul> <li>Ejemplo: divisores_propios(220) = [1, 2, 4, 5, 10, 11, 20, 22, 44, 55 y 110], divisores_propios(284) = [1, 2, 4, 71 y 142]</li> </ul> </li> <li><p>b) Ocupe la funci\u00f3n <code>divisores_propios</code> dentro de la funci\u00f3n <code>amigos</code>.</p> <ul> <li>Ejemplo: amigos(220,284) = True, amigos(6,5) = False</li> </ul> </li> </ul> In\u00a0[\u00a0]: Copied! <pre># respuesta\n</pre> # respuesta <p>Ejercicio 09</p> <p>La conjetura de Collatz, conocida tambi\u00e9n como conjetura $3n+1$ o conjetura de Ulam (entre otros nombres), fue enunciada por el matem\u00e1tico Lothar Collatz en 1937, y a la fecha no se ha resuelto.</p> <p>Sea la siguiente operaci\u00f3n, aplicable a cualquier n\u00famero entero positivo:</p> <ul> <li>Si el n\u00famero es par, se divide entre 2.</li> <li>Si el n\u00famero es impar, se multiplica por 3 y se suma 1.</li> </ul> <p>La conjetura dice que siempre alcanzaremos el 1 (y por tanto el ciclo 4, 2, 1) para cualquier n\u00famero con el que comencemos.</p> <p>Implemente una funci\u00f3n llamada <code>collatz</code> cuyo input sea un n\u00famero natural positivo $N$ y como output devulva la secuencia de n\u00fameros hasta llegar a 1.</p> <ul> <li>Ejemplo: collatz(9) = [9, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]</li> </ul> In\u00a0[\u00a0]: Copied! <pre># respuesta\n</pre> # respuesta <p>Ejercicio 10</p> <p>La conjetura de Goldbach es uno de los problemas abiertos m\u00e1s antiguos en matem\u00e1ticas. Concretamente, G.H. Hardy, en 1921, en su famoso discurso pronunciado en la Sociedad Matem\u00e1tica de Copenhague, coment\u00f3 que probablemente la conjetura de Goldbach no es solo uno de los problemas no resueltos m\u00e1s dif\u00edciles de la teor\u00eda de n\u00fameros, sino de todas las matem\u00e1ticas. Su enunciado es el siguiente:</p> <p>Todo n\u00famero par mayor que 2 puede escribirse como suma de dos n\u00fameros primos - Christian Goldbach (1742)</p> <p>Implemente una funci\u00f3n llamada <code>goldbach</code> cuyo input sea un n\u00famero natural positivo $n$ y como output devuelva la suma de dos primos ($n_1$ y $n_2$) tal que: $n_1+n_2=n$.</p> <p>Para esto:</p> <ul> <li><p>a) Defina la funci\u00f3n <code>es_primo</code>, donde la entrada sea un n\u00famero natural $n$ y la salida sea True si el n\u00famero es primo y False en otro caso.</p> <ul> <li>Ejemplo: es_primo(3) = True, es_primo(4) = False</li> </ul> </li> <li><p>b)  Defina la funci\u00f3n <code>lista_de_primos</code>, donde la entrada sea un n\u00famero natural par $n$ mayor que dos y la salida sea una lista con todos los n\u00famero primos entre 2 y $n$.</p> <ul> <li>Ejemplo: lista_de_primos(4) = [2,3], lista_de_primos(6) = [2,3,5], lista_de_primos(8) = [2,3,5,7]</li> </ul> </li> <li><p>c) Ocupe la funci\u00f3n <code>lista_de_primos</code> dentro de la funci\u00f3n <code>goldbash</code>.</p> </li> <li><p>Ejemplo: goldbash(4) = (2,2), goldbash(6) = (3,3) , goldbash(8) = (3,5)</p> </li> </ul> <p>Ejercicio 11</p> <p>El producto interno de dos listas de n\u00fameros es la suma de los productos de los t\u00e9rminos correspondientes de ambas.</p> <p>Por ejemplo, si:</p> <pre><code>a = [5, 1, 6]\nb = [1, -2, 8]\n</code></pre> <p>entonces el producto interno entre $a$ y $b$ es:</p> <pre><code>(5 * 1) + (1 * -2) + (6 * 8)\n</code></pre> <ol> <li><p>Escriba la funci\u00f3n <code>producto_interno(a, b)</code> que entregue el producto interno de <code>a</code> y <code>b</code>:</p> <pre><code>&gt;&gt;&gt; a = [7, 1, 4, 9, 8]\n&gt;&gt;&gt; b = range(5)\n&gt;&gt;&gt; producto_interno(a, b)\n68\n</code></pre> </li> <li><p>Dos listas de n\u00fameros son ortogonales si su producto interno es cero. Escriba la funci\u00f3n <code>son_ortogonales(a, b)</code> que indique si <code>a</code> y <code>b</code> son ortogonales:</p> <pre><code>&gt;&gt;&gt; son_ortogonales([2, 1], [-3, 6])\nTrue\n</code></pre> </li> </ol> In\u00a0[\u00a0]: Copied! <pre># respuesta\n</pre> # respuesta <p>Ejercicio 12</p> <p>Una fecha puede ser representada como una tupla <code>(anno, mes, dia)</code>.</p> <ol> <li><p>Escriba la funci\u00f3n <code>dia_siguiente(f)</code> que reciba como par\u00e1metro una fecha <code>f</code> y entegue cu\u00e1l es la fecha siguiente:</p> <pre><code>&gt;&gt;&gt; dia_siguiente((2011, 4, 11))\n(2011, 4, 12)\n&gt;&gt;&gt; dia_siguiente((2011, 4, 30))\n(2011, 5, 1)\n&gt;&gt;&gt; dia_siguiente((2011, 12, 31))\n(2012, 1, 1)\n</code></pre> <p>Como recomendaci\u00f3n, dentro de su funci\u00f3n use una lista con la cantidad de d\u00edas que tiene cada mes:</p> <pre><code>dias_mes = [31, 28, 31, 30,\n        31, 30, 31, 31,\n        30, 31, 30, 31]\n</code></pre> </li> <li><p>Escriba la funci\u00f3n <code>dias_entre(f1, f2)</code> que retorne la cantidad de d\u00edas que han transcurrido entre las fechas <code>f1</code> y <code>f2</code>:</p> <pre><code>&gt;&gt;&gt; hoy = (2011, 4, 11)\n&gt;&gt;&gt; navidad = (2011, 12, 25)\n&gt;&gt;&gt; dias_entre(hoy, navidad)\n258\n&gt;&gt;&gt; dias_entre(hoy, hoy)\n0\n</code></pre> </li> </ol> In\u00a0[\u00a0]: Copied! <pre># respuesta\n</pre> # respuesta <p>Ejercicio 13</p> <p>El conjunto potencia de un conjunto $S$ es el conjunto de todos los subconjuntos de $S$.</p> <p>Por ejemplo, el conjunto potencia de $\\{1,2,3\\}$ es:</p> <p>$$\\{\\emptyset,\\{1\\},\\{2\\},\\{3\\},\\{1,2\\},\\{1,3\\},\\{2,3\\},\\{1,2,3\\}\\}$$</p> <p>En Python, un conjunto no puede contener a otros conjuntos, ya que no puede tener elementos mutables, y los conjuntos lo son:</p> <pre>&gt;&gt;&gt; a = set()\n&gt;&gt;&gt; a.add({1, 2})        # :(\nTraceback (most recent call last):\n  File \"&lt;console&gt;\", line 1, in &lt;module&gt;\nTypeError: unhashable type: 'set'\n</pre> <p>Lo que s\u00ed podemos crear es una lista de conjuntos:</p> <pre>&gt;&gt;&gt; l = list()\n&gt;&gt;&gt; l.append({1, 2})     # :)\n&gt;&gt;&gt; l\n[set([1, 2])]\n</pre> <p>Escriba la <code>funci\u00f3n conjunto_potencia(s)</code> que reciba como par\u00e1metro un conjunto cualquiera <code>s</code> y retorne su \u00ablista potencia\u00bb (la lista de todos sus subconjuntos):</p> <pre>&gt;&gt;&gt; conjunto_potencia({6, 1, 4})\n[set(), set([6]), set([1]), set([4]), set([6, 1]), set([6, 4]), set([1, 4]), set([6, 1, 4])]\n</pre> In\u00a0[\u00a0]: Copied! <pre># respuesta\n</pre> # respuesta <p>Ejercicio 14</p> <p>Para este ejercicio considere lo siguiente:</p> <p>Para obtener la lista de palabras de la oraci\u00f3n, puede usar el m\u00e9todo <code>split</code> de los strings:</p> <pre>&gt;&gt;&gt; s = 'el gato y el pato'\n&gt;&gt;&gt; s.split()\n['el', 'gato', 'y', 'el', 'pato']\n</pre> <p>Para obtener un string en min\u00fasculas, puede usar el m\u00e9todo lower:</p> <pre>&gt;&gt;&gt; s = 'Venezuela'\n&gt;&gt;&gt; s.lower()\n'venezuela'\n</pre> <ol> <li><p>Escriba la funci\u00f3n <code>contar_letras(oracion)</code> que retorne un diccionario asociando a cada letra la cantidad de veces que aparece en la oracion:</p> <pre><code>&gt;&gt;&gt; contar_letras('El elefante avanza hacia Asia')\n{'a': 8, 'c': 1, 'e': 4, 'f': 1, 'h': 1, 'i': 2, 'l': 2, 'n': 2, 's': 1, 't': 1, 'v': 1, 'z': 1}\n</code></pre> <p>Cada valor del diccionario debe considerar tanto las apariciones en may\u00fascula como en min\u00fascula de la letra correspondiente. Los espacios deben ser ignorados.</p> </li> <li><p>Escriba la funci\u00f3n <code>contar_vocales(oracion)</code> que retorne un diccionario asociando a cada vocal la cantidad de veces que aparece en la oracion. Si una vocal no aparece en la oraci\u00f3n, de todos modos debe estar en el diccionario asociada al valor 0:</p> <pre><code>&gt;&gt;&gt; contar_vocales('El elefante avanza hacia Asia')\n{'a': 8, 'e': 4, 'i': 2, 'o': 0, 'u': 0}\n</code></pre> </li> <li><p>Escriba la funci\u00f3n <code>contar_iniciales(oracion)</code> que retorne un diccionario asociando a cada letra la cantidad de veces que aparece al principio de una palabra:</p> <pre><code>&gt;&gt;&gt; contar_iniciales('El elefante avanza hacia Asia')\n{'e': 2, 'h': 1, 'a': 2}\n&gt;&gt;&gt; contar_iniciales('Varias vacas vuelan sobre Venezuela')\n{'s': 1', 'v': 4}\n</code></pre> </li> <li><p>Escriba la funci\u00f3n <code>obtener_largo_palabras(oracion)</code> que retorne un diccionario asociando a cada palabra su cantidad de letras:</p> <pre><code>&gt;&gt;&gt; obtener_largo_palabras('el gato y el pato son amigos')\n{'el': 2, 'son': 3, 'gato': 4, 'y': 1, 'amigos': 6, 'pato': 4}\n</code></pre> </li> <li><p>Escriba la funci\u00f3n <code>contar_palabras(oracion)</code> que retorne un diccionario asociando a cada palabra la cantidad de veces que aparece en la oraci\u00f3n:</p> <pre><code>&gt;&gt;&gt; contar_palabras('El sobre esta sobre el pupitre')\n{'sobre': 2, 'pupitre': 1, 'el': 2, 'esta': 1}\n</code></pre> </li> <li><p>Escriba la funci\u00f3n <code>palabras_repetidas(oracion)</code> que retorne una lista con las palabras que est\u00e1n repetidas:</p> <pre><code>&gt;&gt;&gt; palabras_repetidas('El partido termino cero a cero')\n['cero']\n&gt;&gt;&gt; palabras_repetidas('El sobre esta sobre el mueble')\n['el', 'sobre']\n&gt;&gt;&gt; palabras_repetidas('Ay, ahi no hay pan')\n[]\n</code></pre> </li> </ol> In\u00a0[\u00a0]: Copied! <pre># respuesta\n</pre> # respuesta"},{"location":"funciones/#funciones","title":"Funciones\u00b6","text":""},{"location":"funciones/#introduccion","title":"Introducci\u00f3n\u00b6","text":"<p>Las funciones en Python son bloques de c\u00f3digo que pueden ser llamados en cualquier momento del programa. Estos bloques de c\u00f3digo reciben uno o varios argumentos y pueden devolver un valor. Las funciones son muy \u00fatiles porque te permiten escribir c\u00f3digo una vez y reutilizarlo en distintas partes del programa, lo que puede ahorrar mucho tiempo y esfuerzo.</p> <p>Formalmente, una funci\u00f3n tiene tres componentes importantes:</p> <ul> <li>los par\u00e1metros, que son los valores que recibe la funci\u00f3n como entrada;</li> <li>el c\u00f3digo de la funci\u00f3n, que son las operaciones que hace la funci\u00f3n; y</li> <li>el resultado (o valor de retorno), que es el valor final que entrega la funci\u00f3n.</li> </ul> <p>En esencia, una funci\u00f3n es un mini programa. Sus tres componentes son an\u00e1logos a la entrada, el proceso y la salida de un programa.</p> <p>Definici\u00f3n de funciones</p> <p>Las funciones en Python lucen de la siguiente forma:</p> <pre>def nombre(parametro_1,...,parametro_n):\n    \"\"\"\n    Descripcion de la funcion (opcional)\n    \"\"\"\n    # c\u00f3digo de la funci\u00f3n\n    resultado = operacion(parametro_1,...,parametro_n)\n    return resultado # output de la funcion\n</pre> <p>Se utiliza la palabra clave <code>def</code> seguida del nombre de la funci\u00f3n, los par\u00e1metros que recibe entre par\u00e9ntesis y dos puntos <code>:</code>. El cuerpo de la funci\u00f3n va indentado y puede contener cualquier c\u00f3digo que se quiera ejecutar. Para devolver un valor se utiliza la palabra clave <code>return</code>.</p>"},{"location":"funciones/#formas-de-escribir-una-funcion","title":"Formas de escribir una funci\u00f3n\u00b6","text":""},{"location":"funciones/#recursion","title":"Recursion\u00b6","text":"<p>Una funci\u00f3n que se llama a s\u00ed misma se conoce como funci\u00f3n recursiva y este proceso se llama recursividad. Cada funci\u00f3n recursiva debe tener una condici\u00f3n base que detenga la recursividad o, de lo contrario, la funci\u00f3n se llama a s\u00ed misma infinitamente.</p>"},{"location":"funciones/#lambda","title":"Lambda\u00b6","text":"<p>En Python, puedes definir funciones sin nombre utilizando funciones lambda o, como tambi\u00e9n se les conoce, funciones an\u00f3nimas. Estas funciones son \u00fatiles para realizar operaciones simples en una sola l\u00ednea de c\u00f3digo. Para crear una funci\u00f3n lambda, se utiliza la palabra clave <code>lambda</code>. A continuaci\u00f3n, te presento una comparaci\u00f3n entre una funci\u00f3n definida de manera convencional y una funci\u00f3n lambda:</p>"},{"location":"funciones/#utilizando-args-y-kwargs","title":"Utilizando <code>*args</code> y <code>**kwargs</code>\u00b6","text":"<p>En Python, puedes utilizar <code>*args</code> y <code>**kwargs</code> para manejar un n\u00famero variable de argumentos en una funci\u00f3n. Estos nombres, <code>args</code> y <code>kwargs</code>, son convenciones comunes, pero en realidad puedes nombrarlos como desees. Ahora, profundicemos en estos conceptos:</p> <ul> <li><p><code>*args</code>: Es una convenci\u00f3n para indicar que se acepta un n\u00famero variable de argumentos no nombrados (posicionales). Los argumentos se almacenan en una tupla.</p> </li> <li><p><code>**kwargs</code>: Es una convenci\u00f3n para indicar que se acepta un n\u00famero variable de argumentos con nombre. Los argumentos se almacenan en un diccionario, donde las claves se convierten en los nombres de los par\u00e1metros y los valores son los argumentos asociados.</p> </li> </ul> <p>Usando <code>*args</code>:</p>"},{"location":"funciones/#ejercicios","title":"Ejercicios\u00b6","text":""},{"location":"intro_progra/","title":"\ud83d\udcbb Programaci\u00f3n","text":"<p>Al dise\u00f1ar un programa, el desaf\u00edo principal es crear y describir un procedimiento que est\u00e9 completamente bien definido, sin ambig\u00fcedades, y que efectivamente resuelva el problema.</p> <p>Por tanto, la programaci\u00f3n no se centra tanto en los computadores como en resolver problemas de manera estructurada. Su objeto de estudio principal son los algoritmos.</p> <p>Un algoritmo es un procedimiento bien definido para resolver un problema. Todos utilizamos algoritmos a diario, incluso sin darnos cuenta:</p> <p>a) Receta de cocina</p> <p>Una receta de cocina es un ejemplo de algoritmo; aunque algunos pasos puedan parecer ambiguos (\u00bfcu\u00e1nto es \u00abuna pizca de sal\u00bb? \u00bfqu\u00e9 significa \u00abagregar a gusto\u00bb?), en general las instrucciones est\u00e1n lo suficientemente bien definidas para seguirlas sin problemas.</p> <p>La entrada de una receta son los ingredientes y ciertos datos como: \u00bfpara cu\u00e1ntas personas se est\u00e1 cocinando? El proceso es la serie de pasos para manipular los ingredientes. La salida es el plato terminado.</p> <p>En principio, si una receta est\u00e1 suficientemente bien explicada, cualquiera podr\u00eda preparar el plato incluso sin conocimientos previos de cocina.</p> <p>b) M\u00e9todo de multiplicaci\u00f3n</p> <p>El m\u00e9todo para multiplicar n\u00fameros a mano que aprendemos en la escuela es otro ejemplo de algoritmo. Siguiendo paso a paso el procedimiento, siempre obtendremos el producto.</p> <p>La entrada del algoritmo de multiplicaci\u00f3n son los dos factores. El proceso consiste en una secuencia de pasos donde los d\u00edgitos se multiplican, las reservas se suman, y los productos intermedios se suman finalmente. La salida del algoritmo es el producto obtenido.</p> <p>El inicio y el final del algoritmo son representados con bloques circulares. El algoritmo siempre debe ser capaz llegar desde uno hasta el otro, sin importar por qu\u00e9 camino lo hace. Un algoritmo no puede \u00abquedarse pegado\u00bb en la mitad.</p> <p>La entrada y la salida de datos son representadas con romboides, que en la figura de arriba est\u00e1n pintados de verde.</p> <p>Los diamantes representan condiciones en las que el algoritmo sigue uno de dos caminos. que est\u00e1n etiquetados con s\u00ed o no, dependiendo si la condici\u00f3n es verdadera o falsa.</p> <p>Tambi\u00e9n puede haber ciclos, representados por flechas que regresan a bloques anteriores. En este ejemplo, no hay ciclos.</p> <p>Otras sentencias van dentro de rect\u00e1ngulos, que en la figura est\u00e1n pintados de azul. En este ejemplo, las sentencias son asignaciones, representadas en la forma <code>nombre = valor</code>.</p> <p>Los diagramas de flujo no son usados en la pr\u00e1ctica para programar, pero son \u00fatiles para ilustrar c\u00f3mo funcionan algoritmos sencillos.</p> <p>Pseudoc\u00f3digo</p> <p>El pseudoc\u00f3digo es una descripci\u00f3n estructurada de un algoritmo basada en ciertas convenciones notacionales. Si bien es muy parecido al c\u00f3digo que finalmente se escribir\u00e1 en el computador, el pseudoc\u00f3digo est\u00e1 pensado para ser le\u00eddo por humanos.</p> <p>Una manera de escribir el algoritmo para la ecuaci\u00f3n cuadr\u00e1tica en pseudoc\u00f3digo es la siguiente:</p> <pre><code>leer a\nleer b\nleer c\n\ndiscriminante = b\u00b2 - 4ac\n\nsi discriminante &lt; 0:\n    escribir 'La ecuaci\u00f3n no tiene soluciones reales'\n\no si no, si discriminante = 0:\n    x = -b / 2a\n    escribir 'La soluci\u00f3n \u00fanica es', x\n\no si no:\n    x1 = (-b - \u221adiscriminante) / 2a\n    x2 = (-b + \u221adiscriminante) / 2a\n    escribir 'Las dos soluciones reales son:'\n    escribir x1\n    escribir x2\n</code></pre> <p>Las l\u00edneas que comienzan con <code>leer</code> y <code>escribir</code> denotan, respectivamente, la entrada y la salida del programa. Los diferentes casos son representados usando sentencias <code>si</code> y o <code>si no</code>. Las asignaciones siguen la misma notaci\u00f3n que en el caso de los diagramas de flujo.</p> <p>La notaci\u00f3n de pseudoc\u00f3digo es bien liberal. Uno puede mezclar notaci\u00f3n de matem\u00e1ticas con frases en espa\u00f1ol, siempre que quede absolutamente claro para el lector qu\u00e9 representa cada una de las l\u00edneas del algoritmo.</p> <p>C\u00f3digo</p> <p>El producto final de la programaci\u00f3n siempre debe ser c\u00f3digo que pueda ser ejecutado en el computador. Esto requiere describir los algoritmos en un lenguaje de programaci\u00f3n. Los lenguajes de programaci\u00f3n definen un conjunto limitado de conceptos b\u00e1sicos, en funci\u00f3n de los cuales uno puede expresar cualquier algoritmo.</p> <p>En esta asignatura, usaremos el lenguaje de programaci\u00f3n Python para escribir nuestros programas.</p> <p>El c\u00f3digo en Python para resolver la ecuaci\u00f3n cuadr\u00e1tica es el siguiente:</p> <pre>a = float(raw_input('Ingrese a: '))\nb = float(raw_input('Ingrese b: '))\nc = float(raw_input('Ingrese c: '))\n\ndiscriminante = b ** 2 - 4 * a * c\nif discriminante &lt; 0:\n    print 'La ecuacion no tiene soluciones reales'\nelif discriminante == 0:\n    x = -b / (2 * a)\n    print 'La solucion unica es x =', x\nelse:\n    x1 = (-b - (discriminante ** 0.5)) / (2 * a)\n    x2 = (-b + (discriminante ** 0.5)) / (2 * a)\n    print 'Las dos soluciones reales son:'\n    print 'x1 =', x1\n    print 'x2 =', x2\n\nraw_input()\n</pre> <p>A partir de ahora, usted aprender\u00e1 a entender, escribir y ejecutar c\u00f3digos como \u00e9ste.</p>"},{"location":"intro_progra/#programacion","title":"\ud83d\udcbb Programaci\u00f3n\u00b6","text":""},{"location":"intro_progra/#introduccion","title":"Introducci\u00f3n\u00b6","text":"<p>\u201cSe dice que uno no comprende verdaderamente algo hasta que puede explic\u00e1rselo a otro. En realidad, uno no lo entiende completamente hasta que puede explic\u00e1rselo a una computadora.\u201d -- Donald Knuth</p> <p>Si tuvi\u00e9ramos que resumir el prop\u00f3sito de la programaci\u00f3n en una frase, ser\u00eda:</p> <p>Automatizar tareas para que la computadora las realice por nosotros.</p> <p>Las computadoras son expertas en llevar a cabo tareas rutinarias. Idealmente, cualquier labor tediosa y repetitiva deber\u00eda ser delegada a una computadora, permitiendo as\u00ed que los humanos se enfoquen en los problemas verdaderamente interesantes: aquellos que demandan creatividad, pensamiento cr\u00edtico y subjetividad.</p> <p>La programaci\u00f3n es el proceso de traducir un enfoque para resolver problemas en t\u00e9rminos comprensibles para la computadora.</p> <p>Adem\u00e1s, la programaci\u00f3n abarca una amplia gama de lenguajes y paradigmas, cada uno con sus propias caracter\u00edsticas y aplicaciones. Desde los cl\u00e1sicos como C y Java hasta los modernos como Python y JavaScript, cada lenguaje tiene sus fortalezas y debilidades, y la elecci\u00f3n del lenguaje adecuado depende del contexto y los requisitos del proyecto.</p> <p>La programaci\u00f3n no se limita solo a escribir c\u00f3digo. Tambi\u00e9n implica planificaci\u00f3n, dise\u00f1o y depuraci\u00f3n de software. Los programadores deben comprender los requisitos del usuario, dise\u00f1ar soluciones eficientes y depurar errores para garantizar que el software funcione correctamente.</p>"},{"location":"intro_progra/#algoritmos","title":"Algoritmos\u00b6","text":"<p>\u201cLa inform\u00e1tica se trata de computadores tanto como la astronom\u00eda se trata de telescopios.\u201d -- Edsger Dijkstra</p>"},{"location":"intro_progra/#componentes-de-un-algoritmo","title":"Componentes de un algoritmo\u00b6","text":"<p>Conceptualmente, un algoritmo consta de tres elementos principales:</p> <ul> <li>Entrada: Representa los datos iniciales o inputs que el algoritmo utilizar\u00e1 para llevar a cabo su tarea.</li> <li>Proceso: Consiste en la serie de pasos l\u00f3gicos y operaciones que el algoritmo realiza utilizando la entrada para producir un resultado.</li> <li>Salida: Es el resultado final o output que proporciona el algoritmo despu\u00e9s de ejecutar el proceso.</li> </ul> <p>El proceso se describe mediante una secuencia ordenada de instrucciones. Adem\u00e1s, puede incluir estructuras como ciclos, que repiten un conjunto de instrucciones un n\u00famero determinado de veces, y condicionales, que determinan qu\u00e9 conjunto de instrucciones se ejecutar\u00e1n seg\u00fan ciertas condiciones.</p>"},{"location":"intro_progra/#como-describir-un-algoritmo","title":"C\u00f3mo describir un algoritmo\u00b6","text":"<p>Consideremos un ejemplo sencillo: un algoritmo para resolver ecuaciones cuadr\u00e1ticas.</p> <p>Una ecuaci\u00f3n cuadr\u00e1tica es una ecuaci\u00f3n de la forma $ax^2+bx+c=0$, donde $a, b$ y $c$ son datos dados, con $a\\neq0$, y $x$ es la inc\u00f3gnita cuyo valor que se desea determinar.</p> <p>Por ejemplo, $2x^2\u22125x+2=0$ es una ecuaci\u00f3n cuadr\u00e1tica con $a=2$, $b=\u22125$ y $c=2$. Sus soluciones son $x_1=1/2$ y $x_2=2$, como se puede comprobar f\u00e1cilmente al reemplazar estos valores en la ecuaci\u00f3n. El problema es c\u00f3mo obtener estos valores en primer lugar.</p> <p>El problema computacional de resolver una ecuaci\u00f3n cuadr\u00e1tica puede ser planteado as\u00ed:</p> <p>Dados $a, b$ y $c$, entontrar los valores reales de $x$ que satisfacen $ax^2+bx+c=0$.</p> <p>La entrada del algoritmo, pues, son los valores $a, b$ y $c$, y la salida son las ra\u00edces reales $x$ (que pueden ser cero, una o dos) de la ecuaci\u00f3n. En un programa computacional, los valores de $a, b$ y $c$ deber\u00edan ser ingresados usando el teclado, y las soluciones $x$ deber\u00edan ser mostradas a continuaci\u00f3n en la pantalla.</p> <p>Al estudiar \u00e1lgebra aprendemos un algoritmo para resolver este problema. Es lo suficientemente detallado para que pueda usarlo cualquier persona, incluso sin saber qu\u00e9 es una ecuaci\u00f3n cuadr\u00e1tica, o para que lo pueda hacer un computador. A continuaci\u00f3n veremos algunas maneras de describir el procedimiento.</p> <p>Lenguaje natural</p> <p>Durante el proceso mental de dise\u00f1ar un algoritmo, es com\u00fan pensar y describir los pasos en la misma manera en que hablamos a diario. Por ejemplo:</p> <p>Teniendo los valores de $a, b$ y $c$, calcular el discriminante $D=b^2\u22124ac$. Si es discriminante es negativo, entonces la ecuaci\u00f3n no tiene soluciones reales. Si es discriminante es igual a cero, entonces la ecuaci\u00f3n tiene una \u00fanica soluci\u00f3n real, que es $x=\u2212b/2a$. Si el discriminante es positivo, entonces la ecuaci\u00f3n tiene dos soluciones reales, que son $x_1=(\u2212b\u2212\\sqrt{D})/2a$ y $x_2=(\u2212b+\\sqrt{D})/2a$.</p> <p>Esta manera de expresar un algoritmo no es ideal, ya que el lenguaje natural es:</p> <ul> <li>impreciso: puede tener ambig\u00fcedades;</li> <li>no universal: personas distintas describir\u00e1n el proceso de maneras distintas; y</li> <li>no estructurado: la descripci\u00f3n no est\u00e1 expresada en funci\u00f3n de componentes simples.</li> </ul> <p>A\u00fan as\u00ed, es posible identificar los pasos del algoritmo. Por ejemplo, hay que evaluar la expresi\u00f3n $b^2\u22124ac$, y ponerle el nombre $D$ a su resultado. Esto se llama asignaci\u00f3n, y es un tipo de instrucci\u00f3n que aparece en casi todos los algoritmos. Despu\u00e9s de eso, el algoritmo puede usar el nombre $D$ para referirse al valor calculado.</p> <p>Diagrama de flujo Un diagrama de flujo es una representaci\u00f3n gr\u00e1fica de un algoritmo. Los pasos son representados por varios tipos de bloques, y el flujo de ejecuci\u00f3n es indicado por flechas que conectan los bloques:</p>"},{"location":"intro_progra/#referencias","title":"Referencias\u00b6","text":"<ul> <li>Programaci\u00f3n - USM</li> </ul>"},{"location":"intro_python/","title":"\ud83d\udc0d Python","text":"<p>Una gran ventaja de Python es la amplia selecci\u00f3n de librer\u00edas y frameworks que ofrece.</p> <p>Hay librer\u00edas para distintos t\u00f3picos:</p> <ul> <li>Manipulaci\u00f3n de datos</li> <li>Visualizaci\u00f3n de datos</li> <li>Aprendizaje autom\u00e1tico</li> <li>Ciencia de los datos</li> <li>Procesamiento natural del lenguaje</li> <li>Big Data</li> </ul> <p>Lo mismo es cierto para los <code>frameworks</code>, que ayudan a despegar su proyecto y le ahorran tiempo y esfuerzo. Hay una variedad de marcos para elegir, dependiendo de sus necesidades, por ejemplo, para el desarrollo web tenemos:</p> <ul> <li><p>Django: Es un framework de Python que se utiliza para el desarrollo de aplicaciones web. Ofrece una arquitectura de modelo-vista-controlador (MVC) y herramientas para la administraci\u00f3n de bases de datos, la autenticaci\u00f3n y la seguridad.</p> </li> <li><p>Flask: Es un framework de Python que se utiliza para el desarrollo de aplicaciones web de menor escala y m\u00e1s simples. Ofrece una amplia gama de herramientas y extensiones para la creaci\u00f3n de aplicaciones web.</p> </li> </ul>"},{"location":"intro_python/#python","title":"\ud83d\udc0d Python\u00b6","text":"<p>Python es un lenguaje de programaci\u00f3n interpretado de alto nivel, dise\u00f1ado para ser f\u00e1cil de leer y escribir. Fue creado a finales de la d\u00e9cada de 1980 por Guido van Rossum y se ha convertido en uno de los lenguajes de programaci\u00f3n m\u00e1s populares en la actualidad. Python es un lenguaje vers\u00e1til que se puede utilizar para una variedad de tareas, desde el desarrollo web y la ciencia de datos hasta la automatizaci\u00f3n de tareas y la programaci\u00f3n de sistemas.</p> <p>Algunas caracter\u00edsticas de Python:</p> <ul> <li><p>sintaxis clara y concisa: f\u00e1cil de aprender y de entender para los programadores novatos. Adem\u00e1s, cuenta con una amplia biblioteca est\u00e1ndar que proporciona una gran cantidad de herramientas y m\u00f3dulos para realizar tareas comunes.</p> </li> <li><p>lenguaje interpretado: el c\u00f3digo se ejecuta l\u00ednea por l\u00ednea, en lugar de ser compilado de antemano. Esto lo hace muy flexible y adecuado para prototipos r\u00e1pidos y experimentaci\u00f3n.</p> </li> <li><p>c\u00f3digo abierto: el c\u00f3digo fuente est\u00e1 disponible p\u00fablicamente y se puede modificar y distribuir libremente. Hay una gran comunidad de desarrolladores de Python que contribuyen con m\u00f3dulos y herramientas \u00fatiles, y que brindan soporte y ayuda a otros usuarios.</p> </li> </ul>"},{"location":"intro_python/#popularidad","title":"Popularidad\u00b6","text":"<p>Python es uno de los lenguajes de programaci\u00f3n m\u00e1s populares y ampliamente utilizados en la actualidad. Seg\u00fan los \u00edndices de popularidad de lenguajes de programaci\u00f3n, Python ha estado en constante aumento en popularidad en los \u00faltimos a\u00f1os.</p> <p>El \u00edndice TIOBE, que mide la popularidad de los lenguajes de programaci\u00f3n seg\u00fan la frecuencia con la que se buscan en los motores de b\u00fasqueda, ha situado a Python entre los tres lenguajes de programaci\u00f3n m\u00e1s populares en los \u00faltimos a\u00f1os, despu\u00e9s de Java y C.</p> <p>Adem\u00e1s, en la encuesta anual Stack Overflow Developer Survey 2021, Python fue el tercer lenguaje de programaci\u00f3n m\u00e1s popular, despu\u00e9s de JavaScript y HTML/CSS. Tambi\u00e9n se ha convertido en uno de los lenguajes m\u00e1s populares para la ciencia de datos y el aprendizaje autom\u00e1tico.</p>"},{"location":"intro_python/#es-buena-la-popularidad-de-python","title":"\u00bfEs buena la popularidad de Python?\u00b6","text":"<p>S\u00ed, la popularidad de Python es una se\u00f1al de su relevancia en el mundo de la programaci\u00f3n y puede tener varias ventajas para los usuarios y la comunidad en general.</p> <p>En primer lugar, una mayor popularidad significa que hay una amplia comunidad de desarrolladores y usuarios de Python en todo el mundo, lo que hace que sea m\u00e1s f\u00e1cil encontrar recursos, soporte y ayuda en l\u00ednea. Adem\u00e1s, una gran comunidad de usuarios tambi\u00e9n implica que hay una gran cantidad de bibliotecas y m\u00f3dulos disponibles, lo que permite a los usuarios aprovechar el c\u00f3digo existente y acelerar el desarrollo.</p> <p>En segundo lugar, la popularidad de Python lo convierte en una habilidad valiosa en el mercado laboral, con una amplia gama de oportunidades de carrera en diferentes sectores, incluyendo la ciencia de datos, la inteligencia artificial, el desarrollo web, la automatizaci\u00f3n y la programaci\u00f3n de sistemas.</p> <p>Por \u00faltimo, la popularidad de Python tambi\u00e9n puede significar que hay una gran inversi\u00f3n en su desarrollo y mejora continua, lo que resulta en una mayor calidad y eficiencia del lenguaje de programaci\u00f3n.</p> <p>En general, la popularidad de Python es una buena se\u00f1al y es una de las razones por las que se ha convertido en un lenguaje de programaci\u00f3n tan popular y utilizado en todo el mundo.</p>"},{"location":"intro_python/#librerias-y-frameworks","title":"Librer\u00edas y frameworks\u00b6","text":""},{"location":"intro_python/#performance","title":"Performance\u00b6","text":"<p>Python es un lenguaje de programaci\u00f3n interpretado de alto nivel, lo que significa que su rendimiento puede ser m\u00e1s lento que otros lenguajes de programaci\u00f3n de menor nivel, como C o C++. Sin embargo, Python ofrece varias t\u00e9cnicas y herramientas para mejorar el rendimiento y la eficiencia de sus programas. Aqu\u00ed hay algunas de ellas:</p> <ul> <li><p>Compilaci\u00f3n JIT: Python ofrece la opci\u00f3n de utilizar un compilador Just-In-Time (JIT), como PyPy, que puede mejorar significativamente el rendimiento de los programas al compilar el c\u00f3digo en tiempo de ejecuci\u00f3n.</p> </li> <li><p>CPython: Python tambi\u00e9n se puede ejecutar en una implementaci\u00f3n de C llamada CPython, lo que puede mejorar el rendimiento de algunos programas.</p> </li> <li><p>Uso de bibliotecas nativas: Python ofrece la capacidad de usar bibliotecas nativas, como NumPy, que est\u00e1n escritas en lenguajes de bajo nivel como C y Fortran para realizar operaciones num\u00e9ricas de manera m\u00e1s eficiente.</p> </li> <li><p>Uso de estructuras de datos eficientes: Python ofrece varias estructuras de datos, como las listas y los diccionarios, que se pueden usar de manera eficiente para mejorar el rendimiento de los programas.</p> </li> <li><p>Uso de algoritmos eficientes: El uso de algoritmos eficientes tambi\u00e9n puede mejorar significativamente el rendimiento de los programas en Python.</p> </li> </ul> <p>En general, Python puede ofrecer un buen rendimiento en comparaci\u00f3n con otros lenguajes de programaci\u00f3n interpretados, y hay varias t\u00e9cnicas y herramientas disponibles para mejorar a\u00fan m\u00e1s su rendimiento y eficiencia. Sin embargo, es importante recordar que el rendimiento depender\u00e1 en gran medida del uso que se le d\u00e9 al lenguaje y de c\u00f3mo se escriban los programas.</p>"},{"location":"intro_python/#referencia","title":"Referencia\u00b6","text":"<ol> <li>Tutorial de Python 3.8 documentation</li> </ol>"},{"location":"modulo_01/","title":"Modulo 01","text":"In\u00a0[\u00a0]: Copied! <pre>def sumar(a, b):\n    return a + b\n</pre> def sumar(a, b):     return a + b"},{"location":"solucion/","title":"Soluci\u00f3n Ejercicios","text":"<p>Ejercicio 01</p> <p>Escriba un programa que pida al usuario que escriba su nombre, y lo salude llam\u00e1ndolo por su nombre.</p> <pre><code>terminal\nIngrese su nombre: Python\nHola, Python\n</code></pre> In\u00a0[1]: Copied! <pre># Solicita al usuario que ingrese su nombre y lo almacena en la variable \"nombre\"\nnombre = \"Python\"\n\n# Imprime un saludo personalizado utilizando el nombre ingresado por el usuario\nprint(f\"Hola, {nombre}!\")\n</pre> # Solicita al usuario que ingrese su nombre y lo almacena en la variable \"nombre\" nombre = \"Python\"  # Imprime un saludo personalizado utilizando el nombre ingresado por el usuario print(f\"Hola, {nombre}!\") <pre>Hola, Python!\n</pre> <p>Ejercicio 02</p> <p>Escriba un programa que reciba como entrada el radio de un c\u00edrculo y entregue como salida su per\u00edmetro y su \u00e1rea:</p> <pre><code>terminal\nIngrese el radio: 5\nPerimetro: 31.4\n\u00c1rea: 78.5\n</code></pre> In\u00a0[2]: Copied! <pre># Solicitar al usuario que ingrese el radio del c\u00edrculo\nradio = 5\n\n# Definir la variable para el valor de Pi\npi = 3.14159265359\n\n# Calcular el per\u00edmetro y el \u00e1rea del c\u00edrculo\nperimetro = 2 * pi * radio\narea = pi * radio ** 2\n\n# Imprimir el resultado con un formato m\u00e1s claro\nprint(f\"Per\u00edmetro: {perimetro:.1f}\")\nprint(f\"\u00c1rea: {area:.1f}\")\n</pre> # Solicitar al usuario que ingrese el radio del c\u00edrculo radio = 5  # Definir la variable para el valor de Pi pi = 3.14159265359  # Calcular el per\u00edmetro y el \u00e1rea del c\u00edrculo perimetro = 2 * pi * radio area = pi * radio ** 2  # Imprimir el resultado con un formato m\u00e1s claro print(f\"Per\u00edmetro: {perimetro:.1f}\") print(f\"\u00c1rea: {area:.1f}\") <pre>Per\u00edmetro: 31.4\n\u00c1rea: 78.5\n</pre> <p>Ejercicio 03</p> <p>Escriba un programa que calcule el promedio de 4 notas ingresadas por el usuario:</p> <pre><code>terminal\nPrimera nota: 55\nSegunda nota: 71\nTercera nota: 46\nCuarta nota: 87\nEl promedio es: 64.75\n</code></pre> In\u00a0[4]: Copied! <pre># Solicitar al usuario que ingrese las 4 notas\nnota1 = 55\nnota2 = 71\nnota3 = 46\nnota4 = 87\n\n# Calcular el promedio\npromedio = (nota1 + nota2 + nota3 + nota4) / 4\n\n# Imprimir el resultado\nprint(f\"El promedio es: {promedio:.2f}\")\n</pre> # Solicitar al usuario que ingrese las 4 notas nota1 = 55 nota2 = 71 nota3 = 46 nota4 = 87  # Calcular el promedio promedio = (nota1 + nota2 + nota3 + nota4) / 4  # Imprimir el resultado print(f\"El promedio es: {promedio:.2f}\") <pre>El promedio es: 64.75\n</pre> <p>Ejercicio 04</p> <p>Escriba un programa que convierta de cent\u00edmetros a pulgadas. Una pulgada es igual a 2.54 cent\u00edmetros.</p> <pre><code>terminal\nIngrese longitud: 45\n45 cm = 17.7165 in\n</code></pre> In\u00a0[5]: Copied! <pre># Solicitar al usuario que ingrese la longitud en cent\u00edmetros\nlongitud_cm = 45\n\n# Realizar la conversi\u00f3n a pulgadas\nlongitud_in = longitud_cm / 2.54\n\n# Imprimir el resultado\nprint(f\"{longitud_cm} cm = {longitud_in:.4f} in\")\n</pre> # Solicitar al usuario que ingrese la longitud en cent\u00edmetros longitud_cm = 45  # Realizar la conversi\u00f3n a pulgadas longitud_in = longitud_cm / 2.54  # Imprimir el resultado print(f\"{longitud_cm} cm = {longitud_in:.4f} in\") <pre>45 cm = 17.7165 in\n</pre> <p>Ejercicio 05</p> <p>Escriba un programa que reciba como entrada las longitudes de los dos catetos $a$ y $b$ de un tri\u00e1ngulo rect\u00e1ngulo, y que entregue como salida el largo de la hipotenusa $c$ del triangulo, dado por el teorema de Pit\u00e1goras: $c^2=a^2+b^2$.</p> <pre><code>terminal\nIngrese cateto a: 7\nIngrese cateto b: 5\nLa hipotenusa es 8.6023252670426267\n</code></pre> In\u00a0[6]: Copied! <pre># Solicitar al usuario que ingrese la longitud de los catetos\ncateto_a = 7\ncateto_b = 5\n\n# Calcular la hipotenusa utilizando el teorema de Pit\u00e1goras\nhipotenusa = (cateto_a ** 2 + cateto_b ** 2) ** 0.5\n\n# Imprimir el resultado\nprint(f\"La hipotenusa es {hipotenusa}\")\n</pre> # Solicitar al usuario que ingrese la longitud de los catetos cateto_a = 7 cateto_b = 5  # Calcular la hipotenusa utilizando el teorema de Pit\u00e1goras hipotenusa = (cateto_a ** 2 + cateto_b ** 2) ** 0.5  # Imprimir el resultado print(f\"La hipotenusa es {hipotenusa}\") <pre>La hipotenusa es 8.602325267042627\n</pre> <p>Ejercicio 06</p> <p>Escriba un programa que pregunte al usuario la hora actual $t$ del reloj y un n\u00famero entero de horas $h$, que indique qu\u00e9 hora marcar\u00e1 el reloj dentro de $h$ horas:</p> <pre><code>terminal\nHora actual: 23\nCantidad de horas: 5\nEn 5 horas, el reloj marcara las 4\n</code></pre> In\u00a0[8]: Copied! <pre># Solicitar al usuario la hora actual y la cantidad de horas\nhora_actual = 23\nhoras_pasadas = 5\n\n# Calcular la nueva hora\nnueva_hora = (hora_actual + horas_pasadas) % 24\n\n# Imprimir el resultado\nprint(f\"En {horas_pasadas} horas, el reloj marcar\u00e1 las {nueva_hora}\")\n</pre> # Solicitar al usuario la hora actual y la cantidad de horas hora_actual = 23 horas_pasadas = 5  # Calcular la nueva hora nueva_hora = (hora_actual + horas_pasadas) % 24  # Imprimir el resultado print(f\"En {horas_pasadas} horas, el reloj marcar\u00e1 las {nueva_hora}\") <pre>En 5 horas, el reloj marcar\u00e1 las 4\n</pre> <p>Ejercicio 07</p> <p>Un alumno desea saber que nota necesita en el tercer certamen para aprobar un ramo.</p> <p>El promedio del ramo se calcula con la siguiente formula.</p> <p>$$N_C=(C_1+C_2+C_3)/3$$ $$ N_F=N_C\u22c50.7+N_L\u22c50.3$$</p> <p>Donde $N_C$ es el promedio de cert\u00e1menes, $N_L$ el promedio de laboratorio y $N_F$ la nota final.</p> <p>Escriba un programa que pregunte al usuario las notas de los dos primeros certamen y la nota de laboratorio, y muestre la nota que necesita el alumno para aprobar el ramo con nota final 60.</p> <pre><code>terminal\nIngrese nota certamen 1: 45\nIngrese nota certamen 2: 55\nIngrese nota laboratorio: 65\nNecesita nota 74 en el certamen 3\n</code></pre> In\u00a0[14]: Copied! <pre># Solicitar al usuario las notas de los dos primeros cert\u00e1menes y la nota de laboratorio\ncertamen1 = 45\ncertamen2 = 55\nlaboratorio = 65\n\n\n# Calcular la nota necesaria en el tercer certamen para aprobar con nota final 60\nnota_necesaria = 3*((60-0.3*laboratorio)/0.7)-certamen1-certamen2\n\n# Imprimir la nota necesaria en el tercer certamen\nprint(f\"Necesita nota {nota_necesaria:.0f} en el certamen 3\")\n</pre> # Solicitar al usuario las notas de los dos primeros cert\u00e1menes y la nota de laboratorio certamen1 = 45 certamen2 = 55 laboratorio = 65   # Calcular la nota necesaria en el tercer certamen para aprobar con nota final 60 nota_necesaria = 3*((60-0.3*laboratorio)/0.7)-certamen1-certamen2  # Imprimir la nota necesaria en el tercer certamen print(f\"Necesita nota {nota_necesaria:.0f} en el certamen 3\") <pre>Necesita nota 74 en el certamen 3\n</pre> <p>Ejercicio 08</p> <p>Realice un programa que calcule el \u00e1rea de un tri\u00e1ngulo a partir de las longitudes de sus lados.</p> <p>Para calcularlo puede utilizar la f\u00f3rmula de Her\u00f3n:</p> <p>$$     A = \\sqrt{s\\,(s-a)(s-b)(s-c)}, $$ donde $a$, $b$ y $c$ son las longitudes de cada lado y $s=\\dfrac{a+b+c}{2}$ es el semiper\u00edmetro.</p> <pre><code>terminal\nIngrese longitud de lado 1: 3\nIngrese longitud de lado 2: 4\nIngrese longitud de lado 3: 5\nEl \u00e1rea del tri\u00e1ngulo es 6.0\n</code></pre> In\u00a0[15]: Copied! <pre>import math\n\n# Solicitar al usuario las longitudes de los lados del tri\u00e1ngulo\nlado1 = 3\nlado2 = 4\nlado3 = 5\n\n# Calcular el semiper\u00edmetro\ns = (lado1 + lado2 + lado3) / 2\n\n# Calcular el \u00e1rea utilizando la f\u00f3rmula de Her\u00f3n\narea = math.sqrt(s * (s - lado1) * (s - lado2) * (s - lado3))\n\n# Imprimir el resultado\nprint(f\"El \u00e1rea del tri\u00e1ngulo es {area:.1f}\")\n</pre> import math  # Solicitar al usuario las longitudes de los lados del tri\u00e1ngulo lado1 = 3 lado2 = 4 lado3 = 5  # Calcular el semiper\u00edmetro s = (lado1 + lado2 + lado3) / 2  # Calcular el \u00e1rea utilizando la f\u00f3rmula de Her\u00f3n area = math.sqrt(s * (s - lado1) * (s - lado2) * (s - lado3))  # Imprimir el resultado print(f\"El \u00e1rea del tri\u00e1ngulo es {area:.1f}\") <pre>El \u00e1rea del tri\u00e1ngulo es 6.0\n</pre> In\u00a0[17]: Copied! <pre># Solicitar al usuario que ingrese un n\u00famero entero\n\n# Caso 01\nnumero = 4 \n\n# Caso 02\n#numero = 3\n\n# Verificar si el n\u00famero es par o impar\nif numero % 2 == 0:\n    print(\"Su n\u00famero es par\")\nelse:\n    print(\"Su n\u00famero es impar\")\n</pre> # Solicitar al usuario que ingrese un n\u00famero entero  # Caso 01 numero = 4   # Caso 02 #numero = 3  # Verificar si el n\u00famero es par o impar if numero % 2 == 0:     print(\"Su n\u00famero es par\") else:     print(\"Su n\u00famero es impar\") <pre>Su n\u00famero es par\n</pre> <p>Ejercicio 02</p> <p>Escriba un programa que pida dos n\u00fameros enteros y que calcule la divisi\u00f3n, indicando si la divisi\u00f3n es exacta o no.</p> <pre><code>terminal\nDividendo: 14\nDivisor: 5\n\nLa divisi\u00f3n no es exacta.\nCociente: 2\nResto: 4\n</code></pre> <pre>Dividendo: 100\nDivisor: 10\n\nLa divisi\u00f3n es exacta.\nCociente: 10\nResto: 0\n</pre> In\u00a0[20]: Copied! <pre># Solicitar al usuario que ingrese el dividendo y el divisor\n\n# Caso 01\ndividendo = 14\ndivisor = 5\n\n# Caso 02\n#dividendo = 100\n#divisor = 10\n\n# Calcular el cociente y el resto de la divisi\u00f3n\ncociente = dividendo // divisor\nresto = dividendo % divisor\n\n# Verificar si la divisi\u00f3n es exacta\nif resto == 0:\n    print(\"La divisi\u00f3n es exacta.\")\nelse:\n    print(\"La divisi\u00f3n no es exacta.\")\n\n# Imprimir el cociente y el resto\nprint(f\"Cociente: {cociente}\")\nprint(f\"Resto: {resto}\")\n</pre> # Solicitar al usuario que ingrese el dividendo y el divisor  # Caso 01 dividendo = 14 divisor = 5  # Caso 02 #dividendo = 100 #divisor = 10  # Calcular el cociente y el resto de la divisi\u00f3n cociente = dividendo // divisor resto = dividendo % divisor  # Verificar si la divisi\u00f3n es exacta if resto == 0:     print(\"La divisi\u00f3n es exacta.\") else:     print(\"La divisi\u00f3n no es exacta.\")  # Imprimir el cociente y el resto print(f\"Cociente: {cociente}\") print(f\"Resto: {resto}\") <pre>La divisi\u00f3n no es exacta.\nCociente: 2\nResto: 4\n</pre> <p>Ejercicio 03</p> <p>Escriba un programa que pida al usuario dos palabras, y que indique cu\u00e1l de ellas es la m\u00e1s larga y por cu\u00e1ntas letras lo es.</p> <pre><code>terminal\nPalabra 1: edificio\nPalabra 2: tren\nLa palabra edificio tiene 4 letras mas que tren.\n</code></pre> <pre><code>terminal\nPalabra 1: sol\nPalabra 2: paralelepipedo\nLa palabra paralelepipedo tiene 11 letras mas que sol\n</code></pre> <pre><code>terminal\nPalabra 1: plancha\nPalabra 2: lapices\nLas dos palabras tienen el mismo largo\n</code></pre> In\u00a0[22]: Copied! <pre># Solicitar al usuario que ingrese las dos palabras\n\n# Caso 01\npalabra1 = 'edificio'\npalabra2 = 'tren'\n\n# Caso 02\n#palabra1 = 'sol'\n#palabra2 = 'paralelepipedo'\n\n# Caso 03\n#palabra1 = 'plancha'\n#palabra2 = 'lapices'\n\n# Calcular la diferencia en la longitud de las palabras\ndiferencia = abs(len(palabra1) - len(palabra2))\n\n# Determinar cu\u00e1l palabra es m\u00e1s larga y construir el mensaje\nif len(palabra1) &gt; len(palabra2):\n    mensaje = f\"La palabra {palabra1} tiene {diferencia} letras m\u00e1s que {palabra2}.\"\nelif len(palabra1) &lt; len(palabra2):\n    mensaje = f\"La palabra {palabra2} tiene {diferencia} letras m\u00e1s que {palabra1}.\"\nelse:\n    mensaje = \"Las dos palabras tienen el mismo largo.\"\n\n# Imprimir el resultado\nprint(mensaje)\n</pre> # Solicitar al usuario que ingrese las dos palabras  # Caso 01 palabra1 = 'edificio' palabra2 = 'tren'  # Caso 02 #palabra1 = 'sol' #palabra2 = 'paralelepipedo'  # Caso 03 #palabra1 = 'plancha' #palabra2 = 'lapices'  # Calcular la diferencia en la longitud de las palabras diferencia = abs(len(palabra1) - len(palabra2))  # Determinar cu\u00e1l palabra es m\u00e1s larga y construir el mensaje if len(palabra1) &gt; len(palabra2):     mensaje = f\"La palabra {palabra1} tiene {diferencia} letras m\u00e1s que {palabra2}.\" elif len(palabra1) &lt; len(palabra2):     mensaje = f\"La palabra {palabra2} tiene {diferencia} letras m\u00e1s que {palabra1}.\" else:     mensaje = \"Las dos palabras tienen el mismo largo.\"  # Imprimir el resultado print(mensaje) <pre>La palabra edificio tiene 4 letras m\u00e1s que tren.\n</pre> <p>Ejercicio 04</p> <p>Un a\u00f1o es bisiesto si es divisible por $4$, excepto si es divisible por $100$ y no por $400$. Escriba un programa que reciba un a\u00f1o como entrada e indique <code>True</code> si un a\u00f1o es bisiesto o <code>False</code> si no lo es.</p> <pre><code>terminal\nIngrese un anno: 1988\n1988 es bisiesto\n</code></pre> <pre><code>terminal\nIngrese un anno: 2011\n2011 no es bisiesto\n</code></pre> <pre><code>terminal\nIngrese un anno: 1700\n1700 no es bisiesto\n</code></pre> <pre><code>terminal\nIngrese un anno: 2400\n2400 es bisiesto\n</code></pre> In\u00a0[25]: Copied! <pre># Solicitar al usuario que ingrese un a\u00f1o\n\n# Caso 01\nanno = 1988\n\n# Caso 02\n#anno = 2011\n\n# Caso 03\n#anno = 1700\n\n# Caso 04\n#anno = 2400\n\n# Verificar si el a\u00f1o es bisiesto\nif (anno % 4 == 0 and anno % 100 != 0) or anno % 400 == 0:\n    print(f\"{anno} es bisiesto\")\nelse:\n    print(f\"{anno} no es bisiesto\")\n</pre> # Solicitar al usuario que ingrese un a\u00f1o  # Caso 01 anno = 1988  # Caso 02 #anno = 2011  # Caso 03 #anno = 1700  # Caso 04 #anno = 2400  # Verificar si el a\u00f1o es bisiesto if (anno % 4 == 0 and anno % 100 != 0) or anno % 400 == 0:     print(f\"{anno} es bisiesto\") else:     print(f\"{anno} no es bisiesto\") <pre>1988 es bisiesto\n</pre> <p>Ejercicio 05</p> <p>Los tres lados $a, b$ y $c$ de un tri\u00e1ngulo deben satisfacer la desigualdad triangular: cada uno de los lados no puede ser m\u00e1s largo que la suma de los otros dos.</p> <p>Escriba un programa que reciba como entrada los tres lados de un tri\u00e1ngulo, e indique:</p> <ul> <li>si acaso el tri\u00e1ngulo es inv\u00e1lido</li> <li>si el tri\u00e1ngulo es v\u00e1lido, qu\u00e9 tipo de tri\u00e1ngulo es.</li> </ul> <pre><code>terminal\nIngrese a: 3.9\nIngrese b: 6.0\nIngrese c: 1.2\nNo es un triangulo valido.\n</code></pre> <pre><code>terminal\nIngrese a: 1.9\nIngrese b: 2\nIngrese c: 2\nEl triangulo es isoceles.\n</code></pre> <pre><code>terminal\nIngrese a: 3.0\nIngrese b: 5.0\nIngrese c: 4.0\nEl triangulo es escaleno.\n</code></pre> <pre><code>terminal\nIngrese a: 2\nIngrese b: 2\nIngrese c: 2\nEl triangulo es equilatero.\n</code></pre> In\u00a0[31]: Copied! <pre># Solicitar al usuario que ingrese los lados del tri\u00e1ngulo\n\n# Caso 01\na = 3.9\nb = 6.0\nc = 1.2\n\n# Caso 02\n#a = 1.9\n#b = 1.9\n#c = 2.0\n\n# Caso 03\n#a = 3.0\n#b = 5.0\n#c = 4.0\n\n# Caso 04\n#a = 2.0\n#b = 2.0\n#c = 2.0\n\n# Verificar si es un tri\u00e1ngulo v\u00e1lido\nif a + b &gt; c and a + c &gt; b and b + c &gt; a:\n    if a == b == c:\n        print(\"El tri\u00e1ngulo es equil\u00e1tero.\")\n    elif a == b or a == c or b == c:\n        print(\"El tri\u00e1ngulo es is\u00f3sceles.\")\n    else:\n        print(\"El tri\u00e1ngulo es escaleno.\")\nelse:\n    print(\"No es un tri\u00e1ngulo v\u00e1lido.\")\n</pre> # Solicitar al usuario que ingrese los lados del tri\u00e1ngulo  # Caso 01 a = 3.9 b = 6.0 c = 1.2  # Caso 02 #a = 1.9 #b = 1.9 #c = 2.0  # Caso 03 #a = 3.0 #b = 5.0 #c = 4.0  # Caso 04 #a = 2.0 #b = 2.0 #c = 2.0  # Verificar si es un tri\u00e1ngulo v\u00e1lido if a + b &gt; c and a + c &gt; b and b + c &gt; a:     if a == b == c:         print(\"El tri\u00e1ngulo es equil\u00e1tero.\")     elif a == b or a == c or b == c:         print(\"El tri\u00e1ngulo es is\u00f3sceles.\")     else:         print(\"El tri\u00e1ngulo es escaleno.\") else:     print(\"No es un tri\u00e1ngulo v\u00e1lido.\") <pre>No es un tri\u00e1ngulo v\u00e1lido.\n</pre> <p>Ejercicio 06</p> <p>El riesgo de que una persona sufra enfermedades coronarias depende de su edad y su \u00edndice de masa corporal:</p> edad &lt; 45 edad \u2265 45 IMC &lt; 22.0 bajo medio IMC \u2265 22.0 medio alto <p>El \u00edndice de masa corporal es el cuociente entre el peso del individuo en kilos y el cuadrado de su estatura en metros ($IMC = \\dfrac{peso}{estatura^2} $).</p> <p>Escriba un programa que reciba como entrada la estatura, el peso y la edad de una persona, y le entregue su condici\u00f3n de riesgo.</p> <p>ejemplos</p> <ul> <li>Si el usuario ingresa una estatura de 1.75 metros, un peso de 70 kilogramos y una edad de 30 a\u00f1os, el programa mostrar\u00e1: \"La condici\u00f3n de riesgo es: medio\".</li> <li>Si el usuario ingresa una estatura de 1.65 metros, un peso de 90 kilogramos y una edad de 50 a\u00f1os, el programa mostrar\u00e1: \"La condici\u00f3n de riesgo es: alto\".</li> </ul> In\u00a0[35]: Copied! <pre># Solicitar al usuario que ingrese la estatura, peso y edad\nestatura = 1.65\npeso = 180\nedad = 45\n\n# Calcular el \u00edndice de masa corporal (IMC)\nimc = peso / (estatura ** 2)\n\n# Determinar la condici\u00f3n de riesgo\nif edad &lt; 45:\n    if imc &lt; 22.0:\n        riesgo = \"bajo\"\n    else:\n        riesgo = \"medio\"\nelse:\n    if imc &lt; 22.0:\n        riesgo = \"medio\"\n    else:\n        riesgo = \"alto\"\n\n# Imprimir la condici\u00f3n de riesgo\nprint(f\"La condici\u00f3n de riesgo es: {riesgo}\")\n</pre> # Solicitar al usuario que ingrese la estatura, peso y edad estatura = 1.65 peso = 180 edad = 45  # Calcular el \u00edndice de masa corporal (IMC) imc = peso / (estatura ** 2)  # Determinar la condici\u00f3n de riesgo if edad &lt; 45:     if imc &lt; 22.0:         riesgo = \"bajo\"     else:         riesgo = \"medio\" else:     if imc &lt; 22.0:         riesgo = \"medio\"     else:         riesgo = \"alto\"  # Imprimir la condici\u00f3n de riesgo print(f\"La condici\u00f3n de riesgo es: {riesgo}\") <pre>La condici\u00f3n de riesgo es: alto\n</pre> <p>Ejercicio 07</p> <p>Un n\u00famero natural es un pal\u00edndromo si se lee igual de izquierda a derecha y de derecha a izquierda.</p> <p>Por ejemplo, $14941$ es un pal\u00edndromo, mientras que $81924$ no lo es.</p> <p>Escriba un programa que indique si el n\u00famero ingresado es o no pal\u00edndromo:</p> <pre><code>terminal\nIngrese un numero: 14941\n14941 es palindromo\n</code></pre> <pre><code>terminal\nIngrese un numero: 81924\n81924 no es palindromo\n</code></pre> <p>Hint: Para encontrar el inverso de un string en Python, puedes utilizar la t\u00e9cnica de <code>texto[::-1]</code>.</p> In\u00a0[40]: Copied! <pre># Solicitar al usuario que ingrese un n\u00famero\n\n# Caso 01\nnumero = '14941'\n\n# Caso 02\n#numero = '81924'\n\n\n# Obtener el n\u00famero en su versi\u00f3n invertida\nnumero_invertido = numero[::-1]\n\n# Verificar si el n\u00famero y su versi\u00f3n invertida son iguales\nif numero == numero_invertido:\n    print(f\"{numero} es un pal\u00edndromo\")\nelse:\n    print(f\"{numero} no es un pal\u00edndromo\")\n</pre> # Solicitar al usuario que ingrese un n\u00famero  # Caso 01 numero = '14941'  # Caso 02 #numero = '81924'   # Obtener el n\u00famero en su versi\u00f3n invertida numero_invertido = numero[::-1]  # Verificar si el n\u00famero y su versi\u00f3n invertida son iguales if numero == numero_invertido:     print(f\"{numero} es un pal\u00edndromo\") else:     print(f\"{numero} no es un pal\u00edndromo\") <pre>14941 es un pal\u00edndromo\n</pre> In\u00a0[41]: Copied! <pre># Solicitar al usuario que ingrese un n\u00famero\nnumero = 5\n\n# Mostrar un contador regresivo desde el n\u00famero ingresado hasta 1\nprint(\"Contador regresivo desde\", numero, \"hasta 1:\")\nwhile numero &gt;= 1:\n    print(numero)\n    numero -= 1\n</pre> # Solicitar al usuario que ingrese un n\u00famero numero = 5  # Mostrar un contador regresivo desde el n\u00famero ingresado hasta 1 print(\"Contador regresivo desde\", numero, \"hasta 1:\") while numero &gt;= 1:     print(numero)     numero -= 1 <pre>Contador regresivo desde 5 hasta 1:\n5\n4\n3\n2\n1\n</pre> <p>Ejercicio 02</p> <p>Solicita al usuario un n\u00famero y calcula la suma de todos los n\u00fameros pares desde 2 hasta ese n\u00famero. Utiliza la declaraci\u00f3n <code>while</code> para resolver este problema.</p> <pre><code>Ingrese un n\u00famero: 10\nLa suma de n\u00fameros pares desde 2 hasta 10 es 30\n</code></pre> In\u00a0[42]: Copied! <pre># Solicitar al usuario que ingrese un n\u00famero\nnumero = 10\n\n# Inicializar la suma y el contador\nsuma = 0\ncontador = 2\n\n# Calcular la suma de n\u00fameros pares desde 2 hasta el n\u00famero ingresado\nwhile contador &lt;= numero:\n    suma += contador\n    contador += 2  # Avanzar al siguiente n\u00famero par\n\n# Imprimir el resultado\nprint(f\"La suma de n\u00fameros pares desde 2 hasta {numero} es {suma}\")\n</pre> # Solicitar al usuario que ingrese un n\u00famero numero = 10  # Inicializar la suma y el contador suma = 0 contador = 2  # Calcular la suma de n\u00fameros pares desde 2 hasta el n\u00famero ingresado while contador &lt;= numero:     suma += contador     contador += 2  # Avanzar al siguiente n\u00famero par  # Imprimir el resultado print(f\"La suma de n\u00fameros pares desde 2 hasta {numero} es {suma}\") <pre>La suma de n\u00fameros pares desde 2 hasta 10 es 30\n</pre> <p>Ejercicio 03</p> <p>Solicita al usuario un n\u00famero entero y suma todos sus d\u00edgitos. Utiliza la declaraci\u00f3n <code>while</code> para resolver este problema.</p> <pre><code>Ingrese un n\u00famero entero: 12345\nLa suma de los d\u00edgitos es 15\n</code></pre> In\u00a0[43]: Copied! <pre># Solicitar al usuario que ingrese un n\u00famero entero\nnumero = 12345\n\n# Inicializar la suma y el contador\nsuma_digitos = 0\n\n# Calcular la suma de los d\u00edgitos\nwhile numero &gt; 0:\n    # Obtener el \u00faltimo d\u00edgito y sumarlo\n    digito = numero % 10\n    suma_digitos += digito\n    \n    # Eliminar el \u00faltimo d\u00edgito\n    numero //= 10\n\n# Imprimir el resultado\nprint(f\"La suma de los d\u00edgitos es {suma_digitos}\")\n</pre> # Solicitar al usuario que ingrese un n\u00famero entero numero = 12345  # Inicializar la suma y el contador suma_digitos = 0  # Calcular la suma de los d\u00edgitos while numero &gt; 0:     # Obtener el \u00faltimo d\u00edgito y sumarlo     digito = numero % 10     suma_digitos += digito          # Eliminar el \u00faltimo d\u00edgito     numero //= 10  # Imprimir el resultado print(f\"La suma de los d\u00edgitos es {suma_digitos}\") <pre>La suma de los d\u00edgitos es 15\n</pre> <p>Ejercicio 04</p> <p>Pide al usuario un n\u00famero y cuenta cu\u00e1ntos de sus d\u00edgitos son pares. Utiliza la declaraci\u00f3n <code>while</code> para resolver este problema.</p> <pre><code>Ingrese un n\u00famero: 123456\nEl n\u00famero tiene 3 d\u00edgitos pares.\n</code></pre> In\u00a0[1]: Copied! <pre># Solicitar al usuario que ingrese un n\u00famero\nnumero = 123456\n\n# Inicializar el contador de d\u00edgitos pares\ncontador_pares = 0\n\n# Contar los d\u00edgitos pares\nwhile numero &gt; 0:\n    digito = numero % 10\n    if digito % 2 == 0:\n        contador_pares += 1\n    numero //= 10\n\n# Imprimir el resultado\nprint(f\"El n\u00famero tiene {contador_pares} d\u00edgitos pares.\")\n</pre> # Solicitar al usuario que ingrese un n\u00famero numero = 123456  # Inicializar el contador de d\u00edgitos pares contador_pares = 0  # Contar los d\u00edgitos pares while numero &gt; 0:     digito = numero % 10     if digito % 2 == 0:         contador_pares += 1     numero //= 10  # Imprimir el resultado print(f\"El n\u00famero tiene {contador_pares} d\u00edgitos pares.\") <pre>El n\u00famero tiene 3 d\u00edgitos pares.\n</pre> <p>Ejercicio 05</p> <p>Solicita al usuario un n\u00famero y cuenta cu\u00e1ntos n\u00fameros en el rango de 1 a ese n\u00famero son divisibles por 7. Utiliza la declaraci\u00f3n <code>while</code> para resolver este problema.</p> <pre><code>Ingrese un n\u00famero: 20\nHay 2 n\u00fameros divisibles por 7 en el rango de 1 a 20.\n</code></pre> In\u00a0[2]: Copied! <pre># Solicitar al usuario que ingrese un n\u00famero\nnumero = 20\n\n# Inicializar el contador de n\u00fameros divisibles por 7\ncontador_divisibles = 0\n\n# Contar los n\u00fameros divisibles por 7 en el rango de 1 a numero\nnumero_actual = 1\nwhile numero_actual &lt;= numero:\n    if numero_actual % 7 == 0:\n        contador_divisibles += 1\n    numero_actual += 1\n\n# Imprimir el resultado\nprint(f\"Hay {contador_divisibles} n\u00fameros divisibles por 7 en el rango de 1 a {numero}.\")\n</pre> # Solicitar al usuario que ingrese un n\u00famero numero = 20  # Inicializar el contador de n\u00fameros divisibles por 7 contador_divisibles = 0  # Contar los n\u00fameros divisibles por 7 en el rango de 1 a numero numero_actual = 1 while numero_actual &lt;= numero:     if numero_actual % 7 == 0:         contador_divisibles += 1     numero_actual += 1  # Imprimir el resultado print(f\"Hay {contador_divisibles} n\u00fameros divisibles por 7 en el rango de 1 a {numero}.\") <pre>Hay 2 n\u00fameros divisibles por 7 en el rango de 1 a 20.\n</pre> <p>Ejercicio 06</p> <p>Solicita al usuario un n\u00famero y cuenta cu\u00e1ntos de sus d\u00edgitos son impares. Utiliza la declaraci\u00f3n <code>while</code> para resolver este problema.</p> <pre><code>Ingrese un n\u00famero: 7654321\nEl n\u00famero tiene 4 d\u00edgitos impares.\n</code></pre> In\u00a0[4]: Copied! <pre># Solicitar al usuario que ingrese un n\u00famero\nnumero = 7654321\n\n# Inicializar el contador de d\u00edgitos impares\ncontador_impares = 0\n\n# Contar los d\u00edgitos impares\nwhile numero &gt; 0:\n    digito = numero % 10\n    if digito % 2 != 0:\n        contador_impares += 1\n    numero //= 10\n\n# Imprimir el resultado\nprint(f\"El n\u00famero tiene {contador_impares} d\u00edgitos impares.\")\n</pre> # Solicitar al usuario que ingrese un n\u00famero numero = 7654321  # Inicializar el contador de d\u00edgitos impares contador_impares = 0  # Contar los d\u00edgitos impares while numero &gt; 0:     digito = numero % 10     if digito % 2 != 0:         contador_impares += 1     numero //= 10  # Imprimir el resultado print(f\"El n\u00famero tiene {contador_impares} d\u00edgitos impares.\") <pre>El n\u00famero tiene 4 d\u00edgitos impares.\n</pre> In\u00a0[5]: Copied! <pre># Solicitar al usuario que ingrese un n\u00famero\nn = 10\n\n# Inicializar la suma\nsuma_pares = 0\n\n# Calcular la suma de n\u00fameros pares desde 1 hasta n\nfor i in range(2, n + 1, 2):\n    suma_pares += i\n\n# Imprimir el resultado\nprint(f\"La suma de n\u00fameros pares desde 1 hasta {n} es {suma_pares}\")\n</pre> # Solicitar al usuario que ingrese un n\u00famero n = 10  # Inicializar la suma suma_pares = 0  # Calcular la suma de n\u00fameros pares desde 1 hasta n for i in range(2, n + 1, 2):     suma_pares += i  # Imprimir el resultado print(f\"La suma de n\u00fameros pares desde 1 hasta {n} es {suma_pares}\") <pre>La suma de n\u00fameros pares desde 1 hasta 10 es 30\n</pre> <p>Ejercicio 02</p> <p>Muestra un contador regresivo desde un n\u00famero ($n$) dado hasta 1. Utiliza la declaraci\u00f3n <code>range</code> para resolver este problema.</p> <pre><code>Ingrese un n\u00famero: 5\nContador regresivo desde 5 hasta 1:\n5\n4\n3\n2\n1\n</code></pre> In\u00a0[6]: Copied! <pre># Solicitar al usuario que ingrese un n\u00famero\nn = 5\n\n# Mostrar un contador regresivo desde n hasta 1\nprint(f\"Contador regresivo desde {n} hasta 1:\")\nfor i in range(n, 0, -1):\n    print(i)\n</pre> # Solicitar al usuario que ingrese un n\u00famero n = 5  # Mostrar un contador regresivo desde n hasta 1 print(f\"Contador regresivo desde {n} hasta 1:\") for i in range(n, 0, -1):     print(i) <pre>Contador regresivo desde 5 hasta 1:\n5\n4\n3\n2\n1\n</pre> <p>Ejercicio 03</p> <p>Muestra la tabla de multiplicar de un n\u00famero dado. Utiliza la declaraci\u00f3n <code>range</code> para resolver este problema.</p> <pre><code>Ingrese un n\u00famero: 7\nTabla de multiplicar del 7:\n7 x 1 = 7\n7 x 2 = 14\n7 x 3 = 21\n7 x 4 = 28\n7 x 5 = 35\n7 x 6 = 42\n7 x 7 = 49\n7 x 8 = 56\n7 x 9 = 63\n7 x 10 = 70\n</code></pre> In\u00a0[7]: Copied! <pre># Solicitar al usuario que ingrese un n\u00famero\nn = 7\n\n# Mostrar la tabla de multiplicar de n\nprint(f\"Tabla de multiplicar del {n}:\")\nfor i in range(1, 11):\n    resultado = n * i\n    print(f\"{n} x {i} = {resultado}\")\n</pre> # Solicitar al usuario que ingrese un n\u00famero n = 7  # Mostrar la tabla de multiplicar de n print(f\"Tabla de multiplicar del {n}:\") for i in range(1, 11):     resultado = n * i     print(f\"{n} x {i} = {resultado}\") <pre>Tabla de multiplicar del 7:\n7 x 1 = 7\n7 x 2 = 14\n7 x 3 = 21\n7 x 4 = 28\n7 x 5 = 35\n7 x 6 = 42\n7 x 7 = 49\n7 x 8 = 56\n7 x 9 = 63\n7 x 10 = 70\n</pre> <p>Ejercicio 04</p> <p>Escribe un programa que solicite al usuario un n\u00famero entero positivo y luego calcule la suma de los cuadrados de todos los n\u00fameros desde 1 hasta el n\u00famero ingresado. Utiliza la declaraci\u00f3n <code>range</code> para generar los n\u00fameros en el rango y luego suma los cuadrados de esos n\u00fameros.</p> <p>Ejemplos</p> <ol> <li><p>Si el usuario ingresa el n\u00famero 4, el programa calcular\u00e1 la suma de los cuadrados de los n\u00fameros desde 1 hasta 4 de la siguiente manera:</p> <p>Suma = $1^2 + 2^2 + 3^2 + 4^2 = 1 + 4 + 9 + 16 = 30$</p> <p>El programa mostrar\u00e1: \"La suma de los cuadrados de los n\u00fameros en el rango de 1 a 4 es 30.\"</p> </li> </ol> In\u00a0[9]: Copied! <pre># Solicitar al usuario que ingrese un n\u00famero entero positivo\nn = 4\n\n# Inicializar la suma de cuadrados\nsuma_cuadrados = 0\n\n# Calcular la suma de los cuadrados de los n\u00fameros en el rango de 1 a n\nfor numero in range(1, n + 1):\n    cuadrado = numero ** 2\n    suma_cuadrados += cuadrado\n\n# Imprimir el resultado\nprint(f\"La suma de los cuadrados de los n\u00fameros en el rango de 1 a {n} es {suma_cuadrados}\")\n</pre> # Solicitar al usuario que ingrese un n\u00famero entero positivo n = 4  # Inicializar la suma de cuadrados suma_cuadrados = 0  # Calcular la suma de los cuadrados de los n\u00fameros en el rango de 1 a n for numero in range(1, n + 1):     cuadrado = numero ** 2     suma_cuadrados += cuadrado  # Imprimir el resultado print(f\"La suma de los cuadrados de los n\u00fameros en el rango de 1 a {n} es {suma_cuadrados}\") <pre>La suma de los cuadrados de los n\u00fameros en el rango de 1 a 4 es 30\n</pre> In\u00a0[10]: Copied! <pre># Solicitar al usuario que ingrese un n\u00famero\nnumero = 123456\n\n# Inicializar el contador de d\u00edgitos pares\ncontador_pares = 0\n\n# Contar los d\u00edgitos pares\nwhile numero &gt; 0:\n    digito = numero % 10\n    if digito % 2 != 0:\n        # Si el d\u00edgito es impar, omitirlo\n        numero //= 10\n        continue\n    contador_pares += 1\n    numero //= 10\n\n# Imprimir el resultado\nprint(f\"El n\u00famero tiene {contador_pares} d\u00edgitos pares.\")\n</pre> # Solicitar al usuario que ingrese un n\u00famero numero = 123456  # Inicializar el contador de d\u00edgitos pares contador_pares = 0  # Contar los d\u00edgitos pares while numero &gt; 0:     digito = numero % 10     if digito % 2 != 0:         # Si el d\u00edgito es impar, omitirlo         numero //= 10         continue     contador_pares += 1     numero //= 10  # Imprimir el resultado print(f\"El n\u00famero tiene {contador_pares} d\u00edgitos pares.\") <pre>El n\u00famero tiene 3 d\u00edgitos pares.\n</pre> <p>Ejercicio 02</p> <p>Calcula la suma de los n\u00fameros en un rango dado (por ejemplo, de 1 a 10), pero omite los m\u00faltiplos de 3 utilizando la declaraci\u00f3n <code>continue</code>.</p> <pre><code>Ingrese un n\u00famero: 10\nLa suma de los n\u00fameros no divisibles por 3 en el rango de 1 a 10 es 37\n</code></pre> In\u00a0[12]: Copied! <pre># Solicitar al usuario que ingrese un n\u00famero\nn = 10\n\n# Inicializar la suma\nsuma = 0\n\n# Calcular la suma de los n\u00fameros en el rango de 1 a n, omitiendo los m\u00faltiplos de 3\nfor numero in range(1, n + 1):\n    if numero % 3 == 0:\n        # Si es m\u00faltiplo de 3, omitirlo\n        continue\n    suma += numero\n\n# Imprimir el resultado\nprint(f\"La suma de los n\u00fameros no divisibles por 3 en el rango de 1 a {n} es {suma}\")\n</pre> # Solicitar al usuario que ingrese un n\u00famero n = 10  # Inicializar la suma suma = 0  # Calcular la suma de los n\u00fameros en el rango de 1 a n, omitiendo los m\u00faltiplos de 3 for numero in range(1, n + 1):     if numero % 3 == 0:         # Si es m\u00faltiplo de 3, omitirlo         continue     suma += numero  # Imprimir el resultado print(f\"La suma de los n\u00fameros no divisibles por 3 en el rango de 1 a {n} es {suma}\") <pre>La suma de los n\u00fameros no divisibles por 3 en el rango de 1 a 10 es 37\n</pre> <p>Ejercicio 03</p> <p>Dada una lista de n\u00fameros enteros, solicita al usuario un n\u00famero objetivo y busca si el n\u00famero est\u00e1 en la lista. Utiliza un bucle con <code>break</code> para detener la b\u00fasqueda una vez que encuentres el n\u00famero o determines que no est\u00e1 en la lista.</p> In\u00a0[17]: Copied! <pre># Lista de n\u00fameros\nnumeros = [12, 45, 23, 7, 18, 35, 9, 42]\n\n# Solicitar al usuario un n\u00famero objetivo\nobjetivo = 10\n\n# Inicializar una variable para verificar si se encontr\u00f3 el n\u00famero\nencontrado = False\n\n# Recorrer la lista de n\u00fameros\nfor numero in numeros:\n    if numero == objetivo:\n        encontrado = True\n        break  # Detener la b\u00fasqueda una vez que se encuentra el n\u00famero\n\n# Comprobar si se encontr\u00f3 el n\u00famero o no\nif encontrado:\n    print(f\"El n\u00famero {objetivo} fue encontrado en la lista.\")\nelse:\n    print(f\"El n\u00famero {objetivo} no se encontr\u00f3 en la lista.\")\n</pre> # Lista de n\u00fameros numeros = [12, 45, 23, 7, 18, 35, 9, 42]  # Solicitar al usuario un n\u00famero objetivo objetivo = 10  # Inicializar una variable para verificar si se encontr\u00f3 el n\u00famero encontrado = False  # Recorrer la lista de n\u00fameros for numero in numeros:     if numero == objetivo:         encontrado = True         break  # Detener la b\u00fasqueda una vez que se encuentra el n\u00famero  # Comprobar si se encontr\u00f3 el n\u00famero o no if encontrado:     print(f\"El n\u00famero {objetivo} fue encontrado en la lista.\") else:     print(f\"El n\u00famero {objetivo} no se encontr\u00f3 en la lista.\") <pre>El n\u00famero 10 no se encontr\u00f3 en la lista.\n</pre> <p>Ejercicio 04</p> <p>Simula un juego en el que la computadora \"piensa\" en un n\u00famero y el jugador intenta adivinarlo. Crea un bucle que permita al jugador hacer intentos para adivinar el n\u00famero, y utiliza <code>break</code> para salir del bucle si el jugador adivina el n\u00famero o excede un n\u00famero m\u00e1ximo de intentos.</p> In\u00a0[19]: Copied! <pre>import random\n\n# Generar un n\u00famero aleatorio entre 1 y 100\nnumero_secreto = random.randint(1, 100)\n\n# N\u00famero m\u00e1ximo de intentos permitidos\nintentos_maximos = 10\n\nprint(\"Bienvenido al juego de adivinar el n\u00famero.\")\nprint(f\"Estoy pensando en un n\u00famero entre 1 y 100. Adivina cu\u00e1l es.\")\nprint(f\"Tienes un m\u00e1ximo de {intentos_maximos} intentos.\")\n\n# Bucle principal\nfor intento in range(1, intentos_maximos + 1):\n    # Solicitar al jugador que ingrese un n\u00famero\n    intento_jugador = int(input(f\"Intento {intento}: Ingresa un n\u00famero: \"))\n\n    # Comprobar si el jugador adivin\u00f3 el n\u00famero\n    if intento_jugador == numero_secreto:\n        print(f\"\u00a1Felicidades! Adivinaste el n\u00famero {numero_secreto} en {intento} intentos.\")\n        break  # Salir del bucle, el juego ha terminado\n\n    # Comprobar si el intento es demasiado alto o bajo\n    if intento_jugador &lt; numero_secreto:\n        print(\"El n\u00famero es m\u00e1s alto. Int\u00e9ntalo de nuevo.\")\n    else:\n        print(\"El n\u00famero es m\u00e1s bajo. Int\u00e9ntalo de nuevo.\")\n\n# Si el jugador no adivin\u00f3 despu\u00e9s de los intentos m\u00e1ximos\nelse:\n    print(f\"Agotaste tus {intentos_maximos} intentos. El n\u00famero secreto era {numero_secreto}. \u00a1Mejor suerte la pr\u00f3xima vez!\")\n</pre> import random  # Generar un n\u00famero aleatorio entre 1 y 100 numero_secreto = random.randint(1, 100)  # N\u00famero m\u00e1ximo de intentos permitidos intentos_maximos = 10  print(\"Bienvenido al juego de adivinar el n\u00famero.\") print(f\"Estoy pensando en un n\u00famero entre 1 y 100. Adivina cu\u00e1l es.\") print(f\"Tienes un m\u00e1ximo de {intentos_maximos} intentos.\")  # Bucle principal for intento in range(1, intentos_maximos + 1):     # Solicitar al jugador que ingrese un n\u00famero     intento_jugador = int(input(f\"Intento {intento}: Ingresa un n\u00famero: \"))      # Comprobar si el jugador adivin\u00f3 el n\u00famero     if intento_jugador == numero_secreto:         print(f\"\u00a1Felicidades! Adivinaste el n\u00famero {numero_secreto} en {intento} intentos.\")         break  # Salir del bucle, el juego ha terminado      # Comprobar si el intento es demasiado alto o bajo     if intento_jugador &lt; numero_secreto:         print(\"El n\u00famero es m\u00e1s alto. Int\u00e9ntalo de nuevo.\")     else:         print(\"El n\u00famero es m\u00e1s bajo. Int\u00e9ntalo de nuevo.\")  # Si el jugador no adivin\u00f3 despu\u00e9s de los intentos m\u00e1ximos else:     print(f\"Agotaste tus {intentos_maximos} intentos. El n\u00famero secreto era {numero_secreto}. \u00a1Mejor suerte la pr\u00f3xima vez!\") <pre>Bienvenido al juego de adivinar el n\u00famero.\nEstoy pensando en un n\u00famero entre 1 y 100. Adivina cu\u00e1l es.\nTienes un m\u00e1ximo de 10 intentos.\n</pre> <pre>El n\u00famero es m\u00e1s alto. Int\u00e9ntalo de nuevo.\n</pre> <pre>El n\u00famero es m\u00e1s alto. Int\u00e9ntalo de nuevo.\n</pre> <pre>El n\u00famero es m\u00e1s alto. Int\u00e9ntalo de nuevo.\n</pre> <pre>El n\u00famero es m\u00e1s alto. Int\u00e9ntalo de nuevo.\n</pre> <pre>El n\u00famero es m\u00e1s alto. Int\u00e9ntalo de nuevo.\n</pre> <pre>El n\u00famero es m\u00e1s alto. Int\u00e9ntalo de nuevo.\n</pre> <pre>El n\u00famero es m\u00e1s bajo. Int\u00e9ntalo de nuevo.\n</pre> <pre>\u00a1Felicidades! Adivinaste el n\u00famero 98 en 8 intentos.\n</pre> <p>Respuestas y verificaciones en el computador para las expresiones dadas:</p> <ol> <li><code>a[2]</code>: Resultado: <code>4</code>, Tipo: <code>int</code></li> </ol> <pre>a = [5, 1, 4, 9, 0]\na[2]  # Resultado: 4\n</pre> <ol> <li><code>b[9]</code>: Resultado: <code>29</code>, Tipo: <code>int</code></li> </ol> <pre>b = list(range(3, 10)) + list(range(20, 23))\nb[9]  # Resultado: 29\n</pre> <ol> <li><code>c[1][2]</code>: Resultado: <code>5</code>, Tipo: <code>int</code></li> </ol> <pre>c = [[1, 2], [3, 4, 5], [6, 7]]\nc[1][2]  # Resultado: 5\n</pre> <ol> <li><code>e[0] == e[1]</code>: Resultado: <code>False</code>, Tipo: <code>bool</code></li> </ol> <pre>e = ['a', a, 2 * a]\ne[0] == e[1]  # Resultado: False\n</pre> <ol> <li><code>len(c)</code>: Resultado: <code>3</code>, Tipo: <code>int</code></li> </ol> <pre>len(c)  # Resultado: 3\n</pre> <ol> <li><code>len(c[0])</code>: Resultado: <code>2</code>, Tipo: <code>int</code></li> </ol> <pre>len(c[0])  # Resultado: 2\n</pre> <ol> <li><code>len(e)</code>: Resultado: <code>3</code>, Tipo: <code>int</code></li> </ol> <pre>len(e)  # Resultado: 3\n</pre> <ol> <li><code>c[-1]</code>: Resultado: <code>[6, 7]</code>, Tipo: <code>list</code></li> </ol> <pre>c[-1]  # Resultado: [6, 7]\n</pre> <ol> <li><code>c[-1][+1]</code>: Resultado: <code>7</code>, Tipo: <code>int</code></li> </ol> <pre>c[-1][+1]  # Resultado: 7\n</pre> <ol> <li><code>c[2:] + d[2:]</code>: Resultado: <code>[[6, 7], 'jirafa', 'elefante']</code>, Tipo: <code>list</code></li> </ol> <pre>c[2:] + d[2:]  # Resultado: [[6, 7], 'jirafa', 'elefante']\n</pre> <ol> <li><code>a[3:10]</code>: Resultado: <code>[9, 0]</code>, Tipo: <code>list</code></li> </ol> <pre>a[3:10]  # Resultado: [9, 0]\n</pre> <ol> <li><code>a[3:10:2]</code>: Resultado: <code>[9]</code>, Tipo: <code>list</code></li> </ol> <pre>a[3:10:2]  # Resultado: [9]\n</pre> <ol> <li><code>d.index('jirafa')</code>: Resultado: <code>2</code>, Tipo: <code>int</code></li> </ol> <pre>d = ['perro', 'gato', 'jirafa', 'elefante']\nd.index('jirafa')  # Resultado: 2\n</pre> <ol> <li><code>e[c[0][1]].count(5)</code>: Resultado: <code>0</code>, Tipo: <code>int</code></li> </ol> <pre>e[c[0][1]].count(5)  # Resultado: 0\n</pre> <ol> <li><code>sorted(a)[2]</code>: Resultado: <code>4</code>, Tipo: <code>int</code></li> </ol> <pre>sorted(a)[2]  # Resultado: 4\n</pre> <ol> <li><code>complex(b[0], b[1])</code>: Resultado: <code>(3+4j)</code>, Tipo: <code>complex</code></li> </ol> <pre>complex(b[0], b[1])  # Resultado: (3+4j)\n</pre> <p>Ejercicio 02</p> <p>Escriba una rutina  que cuente cu\u00e1ntos valores en la lista valores son mayores que <code>x</code>:</p> <pre><code>terminal\n&gt;&gt;&gt; numero = 5\n&gt;&gt;&gt; lista = [7, 3, 6, 0, 4, 5, 10]\nExisten 3 numeros mayores que 5 en la lista. \n</code></pre> In\u00a0[20]: Copied! <pre># N\u00famero de referencia\nx = 5\n\n# Lista de valores\nvalores = [7, 3, 6, 0, 4, 5, 10]\n\n# Contador para llevar el seguimiento de los valores mayores que x\ncontador = 0\n\n# Iterar a trav\u00e9s de la lista y contar los valores mayores que x\nfor valor in valores:\n    if valor &gt; x:\n        contador += 1\n\n# Imprimir el resultado\nprint(f\"Existen {contador} n\u00fameros mayores que {x} en la lista.\")\n</pre> # N\u00famero de referencia x = 5  # Lista de valores valores = [7, 3, 6, 0, 4, 5, 10]  # Contador para llevar el seguimiento de los valores mayores que x contador = 0  # Iterar a trav\u00e9s de la lista y contar los valores mayores que x for valor in valores:     if valor &gt; x:         contador += 1  # Imprimir el resultado print(f\"Existen {contador} n\u00fameros mayores que {x} en la lista.\") <pre>Existen 3 n\u00fameros mayores que 5 en la lista.\n</pre> <p>Ejercicio 03</p> <p>El producto interno de dos listas de n\u00fameros es la suma de los productos de los t\u00e9rminos correspondientes de ambas.</p> <p>Por ejemplo, si:</p> <pre><code>a = [5, 1, 6]\nb = [1, -2, 8]\n</code></pre> <p>entonces el producto interno entre $a$ y $b$ es:</p> <pre><code>(5 * 1) + (1 * -2) + (6 * 8)\n</code></pre> <ol> <li><p>Escriba una rutina que entregue el producto interno de <code>a</code> y <code>b</code>:</p> <pre><code>&gt;&gt;&gt; a = [7, 1, 4, 9, 8]\n&gt;&gt;&gt; b = range(5)\nEl producto interno es 68\n</code></pre> </li> <li><p>Dos listas de n\u00fameros son ortogonales si su producto interno es cero. Escriba una rutina que indique si <code>a</code> y <code>b</code> son ortogonales:</p> <pre><code>&gt;&gt;&gt; a = [2, 1]\n&gt;&gt;&gt; b =  [-3, 6]\nLos vectores son ortonormales\n</code></pre> </li> </ol> <p>producto interno</p> In\u00a0[21]: Copied! <pre># Lista de n\u00fameros 'a'\na = [7, 1, 4, 9, 8]\n\n# Lista de n\u00fameros 'b'\nb = list(range(5))\n\n# Inicializar la suma del producto interno\nproducto_interno = 0\n\n# Calcular el producto interno\nfor i in range(len(a)):\n    producto_interno += a[i] * b[i]\n\n# Imprimir el resultado\nprint(f\"El producto interno es {producto_interno}\")\n</pre> # Lista de n\u00fameros 'a' a = [7, 1, 4, 9, 8]  # Lista de n\u00fameros 'b' b = list(range(5))  # Inicializar la suma del producto interno producto_interno = 0  # Calcular el producto interno for i in range(len(a)):     producto_interno += a[i] * b[i]  # Imprimir el resultado print(f\"El producto interno es {producto_interno}\") <pre>El producto interno es 68\n</pre> <p>vectores ortonormales</p> In\u00a0[22]: Copied! <pre># Lista de n\u00fameros 'a'\na = [2, 1]\n\n# Lista de n\u00fameros 'b'\nb = [-3, 6]\n\n# Inicializar la suma del producto interno\nproducto_interno = 0\n\n# Calcular el producto interno\nfor i in range(len(a)):\n    producto_interno += a[i] * b[i]\n\n# Verificar si son ortogonales\nif producto_interno == 0:\n    print(\"Los vectores son ortogonales\")\nelse:\n    print(\"Los vectores no son ortogonales\")\n</pre> # Lista de n\u00fameros 'a' a = [2, 1]  # Lista de n\u00fameros 'b' b = [-3, 6]  # Inicializar la suma del producto interno producto_interno = 0  # Calcular el producto interno for i in range(len(a)):     producto_interno += a[i] * b[i]  # Verificar si son ortogonales if producto_interno == 0:     print(\"Los vectores son ortogonales\") else:     print(\"Los vectores no son ortogonales\") <pre>Los vectores son ortogonales\n</pre> <p>Respuestas y verificaciones en el computador para las expresiones dadas:</p> <ol> <li><code>a &lt; b</code>: Resultado: <code>True</code>, Tipo: <code>bool</code></li> </ol> <pre>a = (2, 10, 1991)\nb = (25, 12, 1990)\na &lt; b  # Resultado: True\n</pre> <ol> <li><code>y + w</code>: Resultado: <code>12</code>, Tipo: <code>int</code></li> </ol> <pre>x, y = ((27, 3), 9)\nz, w = x\ny + w  # Resultado: 12\n</pre> <ol> <li><p><code>x + a</code>: Esto generar\u00e1 un error porque no se pueden sumar una tupla <code>(x)</code> y una tupla <code>(a)</code>.</p> </li> <li><p><code>len(v)</code>: Resultado: <code>2</code>, Tipo: <code>int</code></p> </li> </ol> <pre>v = (x, a)\nlen(v)  # Resultado: 2\n</pre> <ol> <li><p><code>v[1][1]</code>: Esto generar\u00e1 un error porque est\u00e1s tratando de acceder a un \u00edndice en una tupla <code>(a)</code> que est\u00e1 dentro de otra tupla <code>(v)</code>.</p> </li> <li><p><code>c[0][0]</code>: Resultado: <code>'D'</code>, Tipo: <code>str</code></p> </li> </ol> <pre>c = ('Donald', True, b)\nc[0][0]  # Resultado: 'D'\n</pre> <ol> <li><code>z, y</code>: Resultado: <code>(27, 9)</code>, Tipo: <code>tuple</code></li> </ol> <pre>x, y = ((27, 3), 9)\nz, y  # Resultado: (27, 9)\n</pre> <ol> <li><code>a + b[1:5]</code>: Resultado: <code>(2, 10, 1991, 12, 1990)</code>, Tipo: <code>tuple</code></li> </ol> <pre>a = (2, 10, 1991)\nb = (25, 12, 1990)\na + b[1:5]  # Resultado: (2, 10, 1991, 12, 1990)\n</pre> <ol> <li><code>(a + b)[1:5]</code>: Resultado: <code>(10, 1991, 12, 1990)</code>, Tipo: <code>tuple</code></li> </ol> <pre>a = (2, 10, 1991)\nb = (25, 12, 1990)\n(a + b)[1:5]  # Resultado: (10, 1991, 12, 1990)\n</pre> <ol> <li><code>str(a[2]) + str(b[2])</code>: Resultado: <code>'19911990'</code>, Tipo: <code>str</code></li> </ol> <pre>a = (2, 10, 1991)\nb = (25, 12, 1990)\nstr(a[2]) + str(b[2])  # Resultado: '19911990'\n</pre> <ol> <li><code>str(a[2] + b[2])</code>: Resultado: <code>'3981'</code>, Tipo: <code>str</code></li> </ol> <pre>a = (2, 10, 1991)\nb = (25, 12, 1990)\nstr(a[2] + b[2])  # Resultado: '3981'\n</pre> <ol> <li><code>str((a + b)[2])</code>: Resultado: <code>'1991'</code>, Tipo: <code>str</code></li> </ol> <pre>a = (2, 10, 1991)\nb = (25, 12, 1990)\nstr((a + b)[2])  # Resultado: '1991'\n</pre> <ol> <li><code>str(a + b)[2]</code>: Resultado: <code>'('</code>, Tipo: <code>str</code></li> </ol> <pre>a = (2, 10, 1991)\nb = (25, 12, 1990)\nstr(a + b)[2]  # Resultado: '('\n</pre> <p>Respuestas y verificaciones en el computador para las expresiones dadas:</p> <ol> <li><code>len(c)</code>: Resultado: <code>5</code>, Tipo: <code>int</code></li> </ol> <pre>c = {7, 5, 5, 1, 8, 6}\nlen(c)  # Resultado: 5\n</pre> <ol> <li><code>len(set(d))</code>: Resultado: <code>6</code>, Tipo: <code>int</code></li> </ol> <pre>d = [6, 2, 4, 5, 5, 3, 1, 3, 7, 8]\nlen(set(d))  # Resultado: 6\n</pre> <ol> <li><code>a &amp; (b | c)</code>: Resultado: <code>{1, 3, 5}</code>, Tipo: <code>set</code></li> </ol> <pre>a = {5, 2, 3, 9, 4}\nb = {3, 1}\nc = {7, 5, 5, 1, 8, 6}\na &amp; (b | c)  # Resultado: {1, 3, 5}\n</pre> <ol> <li><code>(a &amp; b) | c</code>: Resultado: <code>{1, 2, 3, 4, 5, 6, 7, 8, 9}</code>, Tipo: <code>set</code></li> </ol> <pre>(a &amp; b) | c  # Resultado: {1, 2, 3, 4, 5, 6, 7, 8, 9}\n</pre> <ol> <li><code>c - a</code>: Resultado: <code>{1, 6, 8, 7}</code>, Tipo: <code>set</code></li> </ol> <pre>c - a  # Resultado: {1, 6, 8, 7}\n</pre> <ol> <li><code>max(e)</code>: Resultado: <code>(4, 5)</code>, Tipo: <code>tuple</code></li> </ol> <pre>e = {(2, 3), (3, 4), (4, 5)}\nmax(e)  # Resultado: (4, 5)\n</pre> <ol> <li><code>f[0] &lt; a</code>: Resultado: <code>True</code>, Tipo: <code>bool</code></li> </ol> <pre>f = [{2, 3}, {3, 4}, {4, 5}]\nf[0] &lt; a  # Resultado: True\n</pre> <ol> <li><code>set(range(4)) &amp; a</code>: Resultado: <code>{2, 3}</code>, Tipo: <code>set</code></li> </ol> <pre>set(range(4)) &amp; a  # Resultado: {2, 3}\n</pre> <ol> <li><code>(set(range(4)) &amp; a) in f</code>: Resultado: <code>True</code>, Tipo: <code>bool</code></li> </ol> <pre>(set(range(4)) &amp; a) in f  # Resultado: True\n</pre> <ol> <li><code>len(set('perro'))</code>: Resultado: <code>4</code>, Tipo: <code>int</code></li> </ol> <pre>len(set('perro'))  # Resultado: 4\n</pre> <ol> <li><code>len({'perro'})</code>: Resultado: <code>1</code>, Tipo: <code>int</code></li> </ol> <pre>len({'perro'})  # Resultado: 1\n</pre> <p>Respuestas y verificaciones en el computador para las expresiones dadas:</p> <p>Aqu\u00ed tienes las respuestas y verificaciones en el computador para las expresiones dadas:</p> <ol> <li><code>a['c']</code>: Resultado: <code>88</code>, Tipo: <code>int</code></li> </ol> <pre>a = {'a': 14, 'b': 23, 'c': 88}\na['c']  # Resultado: 88\n</pre> <ol> <li><code>a[23]</code>: Resultado: <code>KeyError</code>, Tipo: <code>Error</code></li> </ol> <pre>a[23]  # Resultado: KeyError\n</pre> <ol> <li><code>b[-2] or b[55]</code>: Resultado: <code>False</code>, Tipo: <code>bool</code></li> </ol> <pre>b = {12: True, 55: False, -2: False}\nb[-2] or b[55]  # Resultado: False\n</pre> <ol> <li><code>23 in a</code>: Resultado: <code>False</code>, Tipo: <code>bool</code></li> </ol> <pre>23 in a  # Resultado: False\n</pre> <ol> <li><code>'a' in a</code>: Resultado: <code>True</code>, Tipo: <code>bool</code></li> </ol> <pre>'a' in a  # Resultado: True\n</pre> <ol> <li><code>5 in d[5]</code>: Resultado: <code>True</code>, Tipo: <code>bool</code></li> </ol> <pre>d = {1: [2, 3, 4], 5: [6, 7, 8, 9], 10: [11]}\n5 in d[5]  # Resultado: True\n</pre> <ol> <li><code>sum(b)</code>: Resultado: <code>65</code>, Tipo: <code>int</code></li> </ol> <pre>b = {12: True, 55: False, -2: False}\nsum(b)  # Resultado: 65\n</pre> <ol> <li><code>len(c)</code>: Resultado: <code>0</code>, Tipo: <code>int</code></li> </ol> <pre>c = dict()\nlen(c)  # Resultado: 0\n</pre> <ol> <li><code>len(d)</code>: Resultado: <code>3</code>, Tipo: <code>int</code></li> </ol> <pre>d = {1: [2, 3, 4], 5: [6, 7, 8, 9], 10: [11]}\nlen(d)  # Resultado: 3\n</pre> <ol> <li><code>len(d[1])</code>: Resultado: <code>3</code>, Tipo: <code>int</code></li> </ol> <pre>len(d[1])  # Resultado: 3\n</pre> <ol> <li><code>len(b.values())</code>: Resultado: <code>3</code>, Tipo: <code>int</code></li> </ol> <pre>len(b.values())  # Resultado: 3\n</pre> <ol> <li><code>len(e)</code>: Resultado: <code>4</code>, Tipo: <code>int</code></li> </ol> <pre>e = {2 + 3: 4, 5: 6 + 7, 8: 9, 10: 11 + 12}\nlen(e)  # Resultado: 4\n</pre> <ol> <li><code>sum(a.values())</code>: Resultado: <code>125</code>, Tipo: <code>int</code></li> </ol> <pre>a = {'a': 14, 'b': 23, 'c': 88}\nsum(a.values())  # Resultado: 125\n</pre> <ol> <li><code>max(list(e))</code>: Resultado: <code>10</code>, Tipo: <code>int</code></li> </ol> <pre>max(list(e))  # Resultado: 10\n</pre> <ol> <li><code>d[1] + d[5] + d[10]</code>: Resultado: <code>[2, 3, 4, 6, 7, 8, 9, 11]</code>, Tipo: <code>list</code></li> </ol> <pre>d[1] + d[5] + d[10]  # Resultado: [2, 3, 4, 6, 7, 8, 9, 11]\n</pre> <p>Ejercicio 01</p> <p>Escriba una funci\u00f3n que se llame <code>saludar</code> que reciba como input un string s y devuelva como output \"Hola + valor de s\".</p> <ul> <li>Ejemplo: saludar(\"mundo\") = \"Hola mundo\"</li> </ul> In\u00a0[23]: Copied! <pre>def saludar(s):\n    return \"Hola \" + s\n</pre> def saludar(s):     return \"Hola \" + s In\u00a0[24]: Copied! <pre>mensaje = saludar(\"mundo\")\nprint(mensaje)\n</pre> mensaje = saludar(\"mundo\") print(mensaje) <pre>Hola mundo\n</pre> <p>Ejercicio 02</p> <p>Escriba una funci\u00f3n que se llame <code>es_par</code> que reciba como input un n\u00famero entero n y devuelva como output True si el n\u00famero es par, y False en otro caso.</p> <ul> <li>Ejemplo:<ul> <li>es_par(4) = True</li> <li>es_par(3) = False</li> </ul> </li> </ul> In\u00a0[26]: Copied! <pre>def es_par(n):\n    return n % 2 == 0\n</pre> def es_par(n):     return n % 2 == 0 In\u00a0[27]: Copied! <pre>resultado1 = es_par(4)\nresultado2 = es_par(3)\n\nprint(resultado1)  # Esto imprimir\u00e1 True\nprint(resultado2)  # Esto imprimir\u00e1 False\n</pre> resultado1 = es_par(4) resultado2 = es_par(3)  print(resultado1)  # Esto imprimir\u00e1 True print(resultado2)  # Esto imprimir\u00e1 False <pre>True\nFalse\n</pre> <p>Ejercicio 03</p> <p>Escriba la funci\u00f3n <code>invertir_digitos(n)</code> que reciba un n\u00famero entero n y entregue como resultado el n\u00famero <code>n</code> con los d\u00edgitos en el orden inverso:</p> <pre><code>terminal\n &gt;&gt;&gt; invertir_digitos(142)\n241\n</code></pre> <p>A continuaci\u00f3n, escriba un programa que indique si el n\u00famero ingresado es pal\u00edndromo o no, usando la funci\u00f3n <code>invertir_digitos</code>:</p> <pre><code>terminal\nIngrese n: 81418\nEs pal\u00edndromo\n</code></pre> In\u00a0[28]: Copied! <pre>def invertir_digitos(n):\n    # Convertir el n\u00famero a cadena para facilitar la inversi\u00f3n\n    str_n = str(n)\n    # Invertir la cadena\n    str_invertida = str_n[::-1]\n    # Convertir la cadena invertida nuevamente a un n\u00famero entero\n    n_invertido = int(str_invertida)\n    return n_invertido\n</pre> def invertir_digitos(n):     # Convertir el n\u00famero a cadena para facilitar la inversi\u00f3n     str_n = str(n)     # Invertir la cadena     str_invertida = str_n[::-1]     # Convertir la cadena invertida nuevamente a un n\u00famero entero     n_invertido = int(str_invertida)     return n_invertido In\u00a0[29]: Copied! <pre>resultado1 = invertir_digitos(142)\nprint(resultado1)\n</pre> resultado1 = invertir_digitos(142) print(resultado1)   <pre>241\n</pre> In\u00a0[31]: Copied! <pre>def es_palindromo(n):\n    num_invertido = invertir_digitos(n)\n    if n == num_invertido:\n        return \"Es pal\u00edndromo\"\n    else:\n        return \"No es pal\u00edndromo\"\n</pre> def es_palindromo(n):     num_invertido = invertir_digitos(n)     if n == num_invertido:         return \"Es pal\u00edndromo\"     else:         return \"No es pal\u00edndromo\" In\u00a0[32]: Copied! <pre>resultado1 = es_palindromo(81418)\nprint(resultado1)\n</pre> resultado1 = es_palindromo(81418) print(resultado1)   <pre>Es pal\u00edndromo\n</pre> <p>Ejercicio 04</p> <p>Muchos de estos programas s\u00f3lo ten\u00edan peque\u00f1as diferencias entre ellos, por lo que hab\u00eda que repetir mucho c\u00f3digo al escribirlos. En este ejercicio, usted deber\u00e1 implementar algunos de esos programas como funciones, reutilizando componentes para evitar escribir c\u00f3digo repetido.</p> <p>Ejercicio 041</p> <p>Escriba la funci\u00f3n <code>es_divisible(n, d)</code> que indique si <code>n</code> es divisible por <code>d</code>:</p> <pre><code>&gt;&gt;&gt; es_divisible(15, 5)\nTrue\n&gt;&gt;&gt; es_divisible(15, 6)\nFalse\n</code></pre> In\u00a0[34]: Copied! <pre>def es_divisible(n, d):\n    return n % d == 0\n</pre> def es_divisible(n, d):     return n % d == 0 In\u00a0[35]: Copied! <pre># Ejemplos\nprint(es_divisible(15, 5))  # True\nprint(es_divisible(15, 6))  # False\n</pre> # Ejemplos print(es_divisible(15, 5))  # True print(es_divisible(15, 6))  # False <pre>True\nFalse\n</pre> <p>Ejercicio 042</p> <p>Usando la funci\u00f3n es_divisible, escriba una funci\u00f3n <code>es_primo(n)</code> que determine si un n\u00famero es primo o no:</p> <pre><code>&gt;&gt;&gt; es_primo(17)\nTrue\n&gt;&gt;&gt; es_primo(221)\nFalse\n</code></pre> In\u00a0[36]: Copied! <pre>def es_primo(n):\n    if n &lt;= 1:\n        return False  # Los n\u00fameros menores o iguales a 1 no son primos\n    elif n &lt;= 3:\n        return True  # 2 y 3 son primos\n    elif n % 2 == 0:\n        return False  # Los n\u00fameros pares mayores que 2 no son primos\n    else:\n        # Verificar divisibilidad hasta la ra\u00edz cuadrada de n\n        for i in range(3, int(n**0.5) + 1, 2):\n            if es_divisible(n, i):\n                return False\n        return True\n</pre> def es_primo(n):     if n &lt;= 1:         return False  # Los n\u00fameros menores o iguales a 1 no son primos     elif n &lt;= 3:         return True  # 2 y 3 son primos     elif n % 2 == 0:         return False  # Los n\u00fameros pares mayores que 2 no son primos     else:         # Verificar divisibilidad hasta la ra\u00edz cuadrada de n         for i in range(3, int(n**0.5) + 1, 2):             if es_divisible(n, i):                 return False         return True In\u00a0[37]: Copied! <pre># Ejemplos\nprint(es_primo(17))  # True (17 es un n\u00famero primo)\nprint(es_primo(221))  # False (221 no es un n\u00famero primo)\n</pre> # Ejemplos print(es_primo(17))  # True (17 es un n\u00famero primo) print(es_primo(221))  # False (221 no es un n\u00famero primo) <pre>True\nFalse\n</pre> <p>Ejercicio 043</p> <p>Usando la funci\u00f3n <code>es_primo</code>, escriba la funci\u00f3n <code>i_esimo_primo(i)</code> que entregue el i-\u00e9simo n\u00famero primo.</p> <pre><code>&gt;&gt;&gt; i_esimo_primo(1)\n2\n&gt;&gt;&gt; i_esimo_primo(20)\n71\n</code></pre> In\u00a0[38]: Copied! <pre>def i_esimo_primo(i):\n    if i &lt;= 0:\n        return None  # N\u00fameros negativos o cero no tienen un i-\u00e9simo n\u00famero primo\n    count = 0\n    num = 2\n    while count &lt; i:\n        if es_primo(num):\n            count += 1\n        if count &lt; i:\n            num += 1\n    return num\n</pre> def i_esimo_primo(i):     if i &lt;= 0:         return None  # N\u00fameros negativos o cero no tienen un i-\u00e9simo n\u00famero primo     count = 0     num = 2     while count &lt; i:         if es_primo(num):             count += 1         if count &lt; i:             num += 1     return num In\u00a0[39]: Copied! <pre># Ejemplos\nprint(i_esimo_primo(1))  # 2 (primer n\u00famero primo)\nprint(i_esimo_primo(20))  # 71 (vig\u00e9simo n\u00famero primo)\n</pre> # Ejemplos print(i_esimo_primo(1))  # 2 (primer n\u00famero primo) print(i_esimo_primo(20))  # 71 (vig\u00e9simo n\u00famero primo) <pre>2\n71\n</pre> <p>Ejercicio 044</p> <p>Usando las funciones anteriores, escriba la funci\u00f3n <code>primeros_primos(m)</code> que entregue una lista de los primeros m n\u00fameros primos:</p> <pre><code>&gt;&gt;&gt; primeros_primos(10)\n[2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n</code></pre> In\u00a0[40]: Copied! <pre>def primeros_primos(m):\n    if m &lt;= 0:\n        return []  # Si m es cero o negativo, no hay primos que encontrar\n    primes = []\n    num = 2\n    while len(primes) &lt; m:\n        if es_primo(num):\n            primes.append(num)\n        num += 1\n    return primes\n</pre> def primeros_primos(m):     if m &lt;= 0:         return []  # Si m es cero o negativo, no hay primos que encontrar     primes = []     num = 2     while len(primes) &lt; m:         if es_primo(num):             primes.append(num)         num += 1     return primes In\u00a0[41]: Copied! <pre># Ejemplo\nprint(primeros_primos(10))  # [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n</pre> # Ejemplo print(primeros_primos(10))  # [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] <pre>[2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n</pre> <p>Ejercicio 045</p> <p>Usando las funciones anteriores, escriba la funci\u00f3n <code>primos_hasta(m)</code> que entregue una lista de los primos menores o iguales que <code>m</code>:</p> <pre><code>&gt;&gt;&gt; primos_hasta(19)\n[2, 3, 5, 7, 11, 13, 17, 19]\n</code></pre> In\u00a0[42]: Copied! <pre>def primos_hasta(m):\n    if m &lt; 2:\n        return []  # No hay primos menores o iguales a 1\n    primes = []\n    for num in range(2, m + 1):\n        if es_primo(num):\n            primes.append(num)\n    return primes\n</pre> def primos_hasta(m):     if m &lt; 2:         return []  # No hay primos menores o iguales a 1     primes = []     for num in range(2, m + 1):         if es_primo(num):             primes.append(num)     return primes In\u00a0[43]: Copied! <pre># Ejemplo\nprint(primos_hasta(19))  # [2, 3, 5, 7, 11, 13, 17, 19]\n</pre> # Ejemplo print(primos_hasta(19))  # [2, 3, 5, 7, 11, 13, 17, 19] <pre>[2, 3, 5, 7, 11, 13, 17, 19]\n</pre> <p>Ejercicio 046</p> <p>Un primo de Mersenne es un n\u00famero primo de la forma $2p\u22121$. Una propiedad conocida de los primos de Mersenne es que $p$ debe ser tambi\u00e9n un n\u00famero primo.</p> <p>Escriba la funci\u00f3n <code>mersenne</code> que pregunte al usuario un n\u00famero $n$, y muestre como salida los primeros <code>n</code> primos de Mersenne:</p> <pre><code>&gt;&gt;&gt; mersenne(5)\n3\n7\n31\n127\n8191\n</code></pre> In\u00a0[52]: Copied! <pre>def mersenne(n):\n    count = 0\n    candidate = 2\n    while count &lt; n:\n        if es_primo(candidate):\n            mersenne_prime = 2 ** candidate - 1\n            if es_primo(mersenne_prime):\n                print(mersenne_prime)\n                count += 1\n        candidate += 1\n</pre> def mersenne(n):     count = 0     candidate = 2     while count &lt; n:         if es_primo(candidate):             mersenne_prime = 2 ** candidate - 1             if es_primo(mersenne_prime):                 print(mersenne_prime)                 count += 1         candidate += 1 In\u00a0[53]: Copied! <pre># Ejemplo\nmersenne(5)\n</pre> # Ejemplo mersenne(5) <pre>3\n7\n31\n127\n8191\n</pre> <p>Ejercicio 05</p> <p>La suma natural de los primeros n n\u00fameros naturales esta dado por: $$\\displaystyle S = \\sum_{k=1}^{n} k = 1 +2 +3 +...+n = \\dfrac{n(n+1)}{2} $$</p> <p>Escriba una funci\u00f3n que se llame <code>suma_numeros_naturales</code> que reciba como input un n\u00famero entero n y devuelva como output la suma de los primeros n n\u00fameros naturales.</p> <p>Para esto:</p> <ul> <li>a) Programe la funci\u00f3n ocupando la f\u00f3rmula manual: $S = 1+2+3+..+n$</li> <li>b) Programe la funci\u00f3n ocupando la f\u00f3rmula cerrada: $S =\\dfrac{n(n+1)}{2} $</li> </ul> <p>Ejemplo:</p> <ul> <li>suma_numeros_naturales(1) = 1</li> <li>suma_numeros_naturales(10) = 55</li> <li>suma_numeros_naturales(100) = 5050</li> </ul> In\u00a0[54]: Copied! <pre># Usando la f\u00f3rmula manual:\ndef suma_numeros_naturales_manual(n):\n    suma = 0\n    for i in range(1, n + 1):\n        suma += i\n    return suma\n</pre> # Usando la f\u00f3rmula manual: def suma_numeros_naturales_manual(n):     suma = 0     for i in range(1, n + 1):         suma += i     return suma In\u00a0[55]: Copied! <pre># Usando la f\u00f3rmula cerrada:\ndef suma_numeros_naturales_cerrada(n):\n    suma = (n * (n + 1)) // 2\n    return suma\n</pre> # Usando la f\u00f3rmula cerrada: def suma_numeros_naturales_cerrada(n):     suma = (n * (n + 1)) // 2     return suma In\u00a0[60]: Copied! <pre>print(\"Usando la f\u00f3rmula manual:\")\nprint(suma_numeros_naturales_manual(1))   # Salida: 1\nprint(suma_numeros_naturales_manual(10))  # Salida: 55\nprint(suma_numeros_naturales_manual(100)) # Salida: 5050\nprint()\nprint(\"Usando la f\u00f3rmula cerrada:\")\nprint(suma_numeros_naturales_cerrada(1))   # Salida: 1\nprint(suma_numeros_naturales_cerrada(10))  # Salida: 55\nprint(suma_numeros_naturales_cerrada(100)) # Salida: 5050\n</pre> print(\"Usando la f\u00f3rmula manual:\") print(suma_numeros_naturales_manual(1))   # Salida: 1 print(suma_numeros_naturales_manual(10))  # Salida: 55 print(suma_numeros_naturales_manual(100)) # Salida: 5050 print() print(\"Usando la f\u00f3rmula cerrada:\") print(suma_numeros_naturales_cerrada(1))   # Salida: 1 print(suma_numeros_naturales_cerrada(10))  # Salida: 55 print(suma_numeros_naturales_cerrada(100)) # Salida: 5050 <pre>Usando la f\u00f3rmula manual:\n1\n55\n5050\n\nUsando la f\u00f3rmula cerrada:\n1\n55\n5050\n</pre> <p>Ejercicio 06</p> <p>En los siglos XVII y XVIII, James Gregory y Gottfried Leibniz descubrieron una serie infinita que sirve para calcular $\\pi$:</p> <p>$$\\displaystyle \\pi = 4 \\sum_{k=1}^{\\infty}\\dfrac{(-1)^{k+1}}{2k-1} = 4(1-\\dfrac{1}{3}+\\dfrac{1}{5}-\\dfrac{1}{7} + ...) $$</p> <p>Desarolle un programa para estimar el valor de $\\pi$ ocupando el m\u00e9todo de Leibniz, donde la entrada del programa debe ser un n\u00famero entero $n$ que indique cu\u00e1ntos t\u00e9rminos de la suma se utilizar\u00e1.</p> <ul> <li>Ejemplo:<ul> <li>calcular_pi(3) = 3.466666666666667</li> <li>calcular_pi(1000) = 3.140592653839794</li> </ul> </li> </ul> In\u00a0[61]: Copied! <pre>def calcular_pi(n):\n    suma = 0\n    for k in range(1, n + 1):\n        termino = (-1) ** (k + 1) / (2 * k - 1)\n        suma += termino\n    pi_estimado = 4 * suma\n    return pi_estimado\n</pre> def calcular_pi(n):     suma = 0     for k in range(1, n + 1):         termino = (-1) ** (k + 1) / (2 * k - 1)         suma += termino     pi_estimado = 4 * suma     return pi_estimado In\u00a0[62]: Copied! <pre># Ejemplos de uso\nn1 = 3\npi1 = calcular_pi(n1)\nprint(f\"Con {n1} t\u00e9rminos, el valor estimado de \u03c0 es {pi1}\")\n</pre> # Ejemplos de uso n1 = 3 pi1 = calcular_pi(n1) print(f\"Con {n1} t\u00e9rminos, el valor estimado de \u03c0 es {pi1}\") <pre>Con 3 t\u00e9rminos, el valor estimado de \u03c0 es 3.466666666666667\n</pre> In\u00a0[63]: Copied! <pre>n2 = 1000\npi2 = calcular_pi(n2)\nprint(f\"Con {n2} t\u00e9rminos, el valor estimado de \u03c0 es {pi2}\")\n</pre> n2 = 1000 pi2 = calcular_pi(n2) print(f\"Con {n2} t\u00e9rminos, el valor estimado de \u03c0 es {pi2}\") <pre>Con 1000 t\u00e9rminos, el valor estimado de \u03c0 es 3.140592653839794\n</pre> <p>Ejercicio 07</p> <p>Euler realiz\u00f3 varios aportes en relaci\u00f3n a $e$, pero no fue hasta 1748 cuando public\u00f3 su Introductio in analysin infinitorum que dio un tratamiento definitivo a las ideas sobre $e$. All\u00ed mostr\u00f3 que:</p> <p>En los siglos XVII y XVIII, James Gregory y Gottfried Leibniz descubrieron una serie infinita que sirve para calcular \u03c0:</p> <p>$$\\displaystyle e = \\sum_{k=0}^{\\infty}\\dfrac{1}{k!} = 1+\\dfrac{1}{2!}+\\dfrac{1}{3!}+\\dfrac{1}{4!} + ... $$</p> <p>Desarolle un programa para estimar el valor de $e$ ocupando el m\u00e9todo de Euler, donde la entrada del programa debe ser un n\u00famero entero $n$ que indique cu\u00e1ntos t\u00e9rminos de la suma se utilizar\u00e1.</p> <p>Para esto:</p> <ul> <li><p>a) Defina la funci\u00f3n <code>factorial</code>, donde la entrada sea un n\u00famero natural  $n$ y la salida sea el factorial de dicho n\u00famero.</p> <ul> <li>Ejemplo: factorial(3) =3, factorial(5) = 120</li> </ul> </li> <li><p>b) Ocupe la funci\u00f3n <code>factorial</code> dentro de la funci\u00f3n <code>calcular_e</code>.</p> <ul> <li>Ejemplo: calcular_e(3) = 2.6666666666666665, calcular_e(1000) = 2.7182818284590455</li> </ul> </li> </ul> In\u00a0[64]: Copied! <pre>def factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n - 1)\n\ndef calcular_e(n):\n    suma = 0\n    for k in range(n):\n        termino = 1 / factorial(k)\n        suma += termino\n    return suma\n</pre> def factorial(n):     if n == 0:         return 1     else:         return n * factorial(n - 1)  def calcular_e(n):     suma = 0     for k in range(n):         termino = 1 / factorial(k)         suma += termino     return suma In\u00a0[65]: Copied! <pre># Ejemplos de uso\nn1 = 3\ne1 = calcular_e(n1)\nprint(f\"Con {n1} t\u00e9rminos, el valor estimado de e es {e1}\")\n</pre> # Ejemplos de uso n1 = 3 e1 = calcular_e(n1) print(f\"Con {n1} t\u00e9rminos, el valor estimado de e es {e1}\") <pre>Con 3 t\u00e9rminos, el valor estimado de e es 2.5\n</pre> In\u00a0[66]: Copied! <pre>n2 = 1000\ne2 = calcular_e(n2)\nprint(f\"Con {n2} t\u00e9rminos, el valor estimado de e es {e2}\")\n</pre> n2 = 1000 e2 = calcular_e(n2) print(f\"Con {n2} t\u00e9rminos, el valor estimado de e es {e2}\") <pre>Con 1000 t\u00e9rminos, el valor estimado de e es 2.7182818284590455\n</pre> <p>Ejercicio 08</p> <p>Sea $\\sigma(n)$ definido como la suma de los divisores propios de $n$ (n\u00fameros menores que n que se dividen en $n$).</p> <p>Los n\u00fameros amigos son  enteros positivos $n_1$ y $n_2$ tales que la suma de los divisores propios de uno es igual al otro n\u00famero y viceversa, es decir, $\\sigma(n_1)=\\sigma(n_2)$ y $\\sigma(n_2)=\\sigma(n_1)$.</p> <p>Por ejemplo, los n\u00fameros 220 y 284 son n\u00fameros amigos.</p> <ul> <li>los divisores propios de 220 son 1, 2, 4, 5, 10, 11, 20, 22, 44, 55 y 110; por lo tanto $\\sigma(220) = 284$.</li> <li>los divisores propios de 284 son 1, 2, 4, 71 y 142; entonces $\\sigma(284) = 220$.</li> </ul> <p>Implemente una funci\u00f3n llamada <code>amigos</code> cuyo input sean dos n\u00fameros naturales $n_1$ y $n_2$, cuyo output sea verifique si los n\u00fameros son amigos o no.</p> <p>Para esto:</p> <ul> <li><p>a) Defina la funci\u00f3n <code>divisores_propios</code>, donde la entrada sea un n\u00famero natural $n$ y la salida sea una lista con los divisores propios de dicho n\u00famero.</p> <ul> <li>Ejemplo: divisores_propios(220) = [1, 2, 4, 5, 10, 11, 20, 22, 44, 55 y 110], divisores_propios(284) = [1, 2, 4, 71 y 142]</li> </ul> </li> <li><p>b) Ocupe la funci\u00f3n <code>divisores_propios</code> dentro de la funci\u00f3n <code>amigos</code>.</p> <ul> <li>Ejemplo: amigos(220,284) = True, amigos(6,5) = False</li> </ul> </li> </ul> In\u00a0[67]: Copied! <pre>def divisores_propios(n):\n    divisores = []\n    for i in range(1, n):\n        if n % i == 0:\n            divisores.append(i)\n    return divisores\n</pre> def divisores_propios(n):     divisores = []     for i in range(1, n):         if n % i == 0:             divisores.append(i)     return divisores In\u00a0[68]: Copied! <pre># Ejemplos de uso\ndivisores_220 = divisores_propios(220)\ndivisores_284 = divisores_propios(284)\nprint(f\"Divisores propios de 220: {divisores_220}\")\nprint(f\"Divisores propios de 284: {divisores_284}\")\n</pre> # Ejemplos de uso divisores_220 = divisores_propios(220) divisores_284 = divisores_propios(284) print(f\"Divisores propios de 220: {divisores_220}\") print(f\"Divisores propios de 284: {divisores_284}\") <pre>Divisores propios de 220: [1, 2, 4, 5, 10, 11, 20, 22, 44, 55, 110]\nDivisores propios de 284: [1, 2, 4, 71, 142]\n</pre> In\u00a0[69]: Copied! <pre>def amigos(n1, n2):\n    suma_divisores_n1 = sum(divisores_propios(n1))\n    suma_divisores_n2 = sum(divisores_propios(n2))\n    \n    return suma_divisores_n1 == n2 and suma_divisores_n2 == n1\n</pre> def amigos(n1, n2):     suma_divisores_n1 = sum(divisores_propios(n1))     suma_divisores_n2 = sum(divisores_propios(n2))          return suma_divisores_n1 == n2 and suma_divisores_n2 == n1 In\u00a0[70]: Copied! <pre># Ejemplos de uso\nn1 = 220\nn2 = 284\nresultado1 = amigos(n1, n2)\nprint(f\"\u00bf{n1} y {n2} son amigos? {resultado1}\")\n\nn3 = 6\nn4 = 5\nresultado2 = amigos(n3, n4)\nprint(f\"\u00bf{n3} y {n4} son amigos? {resultado2}\")\n</pre> # Ejemplos de uso n1 = 220 n2 = 284 resultado1 = amigos(n1, n2) print(f\"\u00bf{n1} y {n2} son amigos? {resultado1}\")  n3 = 6 n4 = 5 resultado2 = amigos(n3, n4) print(f\"\u00bf{n3} y {n4} son amigos? {resultado2}\") <pre>\u00bf220 y 284 son amigos? True\n\u00bf6 y 5 son amigos? False\n</pre> <p>Ejercicio 09</p> <p>La conjetura de Collatz, conocida tambi\u00e9n como conjetura $3n+1$ o conjetura de Ulam (entre otros nombres), fue enunciada por el matem\u00e1tico Lothar Collatz en 1937, y a la fecha no se ha resuelto.</p> <p>Sea la siguiente operaci\u00f3n, aplicable a cualquier n\u00famero entero positivo:</p> <ul> <li>Si el n\u00famero es par, se divide entre 2.</li> <li>Si el n\u00famero es impar, se multiplica por 3 y se suma 1.</li> </ul> <p>La conjetura dice que siempre alcanzaremos el 1 (y por tanto el ciclo 4, 2, 1) para cualquier n\u00famero con el que comencemos.</p> <p>Implemente una funci\u00f3n llamada <code>collatz</code> cuyo input sea un n\u00famero natural positivo $N$ y como output devulva la secuencia de n\u00fameros hasta llegar a 1.</p> <ul> <li>Ejemplo: collatz(9) = [9, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]</li> </ul> In\u00a0[71]: Copied! <pre>def collatz(n):\n    secuencia = [n]\n    while n != 1:\n        if n % 2 == 0:\n            n //= 2\n        else:\n            n = 3 * n + 1\n        secuencia.append(n)\n    return secuencia\n</pre> def collatz(n):     secuencia = [n]     while n != 1:         if n % 2 == 0:             n //= 2         else:             n = 3 * n + 1         secuencia.append(n)     return secuencia In\u00a0[72]: Copied! <pre># Ejemplo de uso\nnumero = 9\nsecuencia_collatz = collatz(numero)\nprint(secuencia_collatz)\n</pre> # Ejemplo de uso numero = 9 secuencia_collatz = collatz(numero) print(secuencia_collatz) <pre>[9, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]\n</pre> <p>Ejercicio 10</p> <p>La conjetura de Goldbach es uno de los problemas abiertos m\u00e1s antiguos en matem\u00e1ticas. Concretamente, G.H. Hardy, en 1921, en su famoso discurso pronunciado en la Sociedad Matem\u00e1tica de Copenhague, coment\u00f3 que probablemente la conjetura de Goldbach no es solo uno de los problemas no resueltos m\u00e1s dif\u00edciles de la teor\u00eda de n\u00fameros, sino de todas las matem\u00e1ticas. Su enunciado es el siguiente:</p> <p>Todo n\u00famero par mayor que 2 puede escribirse como suma de dos n\u00fameros primos - Christian Goldbach (1742)</p> <p>Implemente una funci\u00f3n llamada <code>goldbach</code> cuyo input sea un n\u00famero natural positivo $n$ y como output devuelva la suma de dos primos ($n_1$ y $n_2$) tal que: $n_1+n_2=n$.</p> <p>Para esto:</p> <ul> <li><p>a) Defina la funci\u00f3n <code>es_primo</code>, donde la entrada sea un n\u00famero natural $n$ y la salida sea True si el n\u00famero es primo y False en otro caso.</p> <ul> <li>Ejemplo: es_primo(3) = True, es_primo(4) = False</li> </ul> </li> <li><p>b)  Defina la funci\u00f3n <code>lista_de_primos</code>, donde la entrada sea un n\u00famero natural par $n$ mayor que dos y la salida sea una lista con todos los n\u00famero primos entre 2 y $n$.</p> <ul> <li>Ejemplo: lista_de_primos(4) = [2,3], lista_de_primos(6) = [2,3,5], lista_de_primos(8) = [2,3,5,7]</li> </ul> </li> <li><p>c) Ocupe la funci\u00f3n <code>lista_de_primos</code> dentro de la funci\u00f3n <code>goldbash</code>.</p> </li> <li><p>Ejemplo: goldbash(4) = (2,2), goldbash(6) = (3,3) , goldbash(8) = (3,5)</p> </li> </ul> In\u00a0[74]: Copied! <pre># a) Funci\u00f3n es_primo\ndef es_primo(n):\n    if n &lt;= 1:\n        return False\n    if n &lt;= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i &lt;= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n</pre> # a) Funci\u00f3n es_primo def es_primo(n):     if n &lt;= 1:         return False     if n &lt;= 3:         return True     if n % 2 == 0 or n % 3 == 0:         return False     i = 5     while i * i &lt;= n:         if n % i == 0 or n % (i + 2) == 0:             return False         i += 6     return True In\u00a0[73]: Copied! <pre># Ejemplos de uso\nprint(es_primo(3))  # True\nprint(es_primo(4))  # False\n</pre> # Ejemplos de uso print(es_primo(3))  # True print(es_primo(4))  # False <pre>True\nFalse\n</pre> In\u00a0[75]: Copied! <pre># b) Funci\u00f3n lista_de_primos\ndef lista_de_primos(n):\n    primos = []\n    for num in range(2, n + 1):\n        if es_primo(num):\n            primos.append(num)\n    return primos\n</pre> # b) Funci\u00f3n lista_de_primos def lista_de_primos(n):     primos = []     for num in range(2, n + 1):         if es_primo(num):             primos.append(num)     return primos In\u00a0[76]: Copied! <pre># Ejemplos de uso\nprint(lista_de_primos(4))  # [2, 3]\nprint(lista_de_primos(6))  # [2, 3, 5]\nprint(lista_de_primos(8))  # [2, 3, 5, 7]\n</pre> # Ejemplos de uso print(lista_de_primos(4))  # [2, 3] print(lista_de_primos(6))  # [2, 3, 5] print(lista_de_primos(8))  # [2, 3, 5, 7] <pre>[2, 3]\n[2, 3, 5]\n[2, 3, 5, 7]\n</pre> In\u00a0[77]: Copied! <pre># c) Funci\u00f3n goldbach\ndef goldbach(n):\n    primos = lista_de_primos(n)\n    for primo in primos:\n        if n - primo in primos:\n            return (primo, n - primo)\n</pre> # c) Funci\u00f3n goldbach def goldbach(n):     primos = lista_de_primos(n)     for primo in primos:         if n - primo in primos:             return (primo, n - primo) In\u00a0[78]: Copied! <pre># Ejemplos de uso\nprint(goldbach(4))  # (2, 2)\nprint(goldbach(6))  # (3, 3)\nprint(goldbach(8))  # (3, 5)\n</pre> # Ejemplos de uso print(goldbach(4))  # (2, 2) print(goldbach(6))  # (3, 3) print(goldbach(8))  # (3, 5) <pre>(2, 2)\n(3, 3)\n(3, 5)\n</pre> <p>Ejercicio 11</p> <p>El producto interno de dos listas de n\u00fameros es la suma de los productos de los t\u00e9rminos correspondientes de ambas.</p> <p>Por ejemplo, si:</p> <pre><code>a = [5, 1, 6]\nb = [1, -2, 8]\n</code></pre> <p>entonces el producto interno entre $a$ y $b$ es:</p> <pre><code>(5 * 1) + (1 * -2) + (6 * 8)\n</code></pre> <ol> <li><p>Escriba la funci\u00f3n <code>producto_interno(a, b)</code> que entregue el producto interno de <code>a</code> y <code>b</code>:</p> <pre><code>&gt;&gt;&gt; a = [7, 1, 4, 9, 8]\n&gt;&gt;&gt; b = range(5)\n&gt;&gt;&gt; producto_interno(a, b)\n68\n</code></pre> </li> <li><p>Dos listas de n\u00fameros son ortogonales si su producto interno es cero. Escriba la funci\u00f3n <code>son_ortogonales(a, b)</code> que indique si <code>a</code> y <code>b</code> son ortogonales:</p> <pre><code>&gt;&gt;&gt; son_ortogonales([2, 1], [-3, 6])\nTrue\n</code></pre> </li> </ol> In\u00a0[79]: Copied! <pre># 1. Funci\u00f3n producto_interno\n\ndef producto_interno(a, b):\n    if len(a) != len(b):\n        return None  # Las listas deben tener la misma longitud\n    return sum(a_i * b_i for a_i, b_i in zip(a, b))\n</pre> # 1. Funci\u00f3n producto_interno  def producto_interno(a, b):     if len(a) != len(b):         return None  # Las listas deben tener la misma longitud     return sum(a_i * b_i for a_i, b_i in zip(a, b)) In\u00a0[80]: Copied! <pre># Ejemplo de uso\na = [7, 1, 4, 9, 8]\nb = list(range(5))\nresultado = producto_interno(a, b)\nprint(resultado)  # Salida: 68\n</pre> # Ejemplo de uso a = [7, 1, 4, 9, 8] b = list(range(5)) resultado = producto_interno(a, b) print(resultado)  # Salida: 68 <pre>68\n</pre> In\u00a0[81]: Copied! <pre># 2. Funci\u00f3n son_ortogonales\ndef son_ortogonales(a, b):\n    producto = producto_interno(a, b)\n    return producto == 0\n</pre> # 2. Funci\u00f3n son_ortogonales def son_ortogonales(a, b):     producto = producto_interno(a, b)     return producto == 0 In\u00a0[82]: Copied! <pre># Ejemplo de uso\nresultado = son_ortogonales([2, 1], [-3, 6])\nprint(resultado)  # Salida: True\n</pre> # Ejemplo de uso resultado = son_ortogonales([2, 1], [-3, 6]) print(resultado)  # Salida: True <pre>True\n</pre> <p>Ejercicio 12</p> <p>Una fecha puede ser representada como una tupla <code>(anno, mes, dia)</code>.</p> <ol> <li><p>Escriba la funci\u00f3n <code>dia_siguiente(f)</code> que reciba como par\u00e1metro una fecha <code>f</code> y entegue cu\u00e1l es la fecha siguiente:</p> <pre><code>&gt;&gt;&gt; dia_siguiente((2011, 4, 11))\n(2011, 4, 12)\n&gt;&gt;&gt; dia_siguiente((2011, 4, 30))\n(2011, 5, 1)\n&gt;&gt;&gt; dia_siguiente((2011, 12, 31))\n(2012, 1, 1)\n</code></pre> <p>Como recomendaci\u00f3n, dentro de su funci\u00f3n use una lista con la cantidad de d\u00edas que tiene cada mes:</p> <pre><code>dias_mes = [31, 28, 31, 30,\n        31, 30, 31, 31,\n        30, 31, 30, 31]\n</code></pre> </li> <li><p>Escriba la funci\u00f3n <code>dias_entre(f1, f2)</code> que retorne la cantidad de d\u00edas que han transcurrido entre las fechas <code>f1</code> y <code>f2</code>:</p> <pre><code>&gt;&gt;&gt; hoy = (2011, 4, 11)\n&gt;&gt;&gt; navidad = (2011, 12, 25)\n&gt;&gt;&gt; dias_entre(hoy, navidad)\n258\n&gt;&gt;&gt; dias_entre(hoy, hoy)\n0\n</code></pre> </li> </ol> In\u00a0[84]: Copied! <pre># 1. Funci\u00f3n dia_siguiente\ndef dia_siguiente(fecha):\n    anno, mes, dia = fecha\n    dias_mes = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n    # Comprobamos si es un a\u00f1o bisiesto\n    if (anno % 4 == 0 and anno % 100 != 0) or (anno % 400 == 0):\n        dias_mes[1] = 29\n\n    if dia &lt; dias_mes[mes - 1]:\n        return (anno, mes, dia + 1)\n    elif mes &lt; 12:\n        return (anno, mes + 1, 1)\n    else:\n        return (anno + 1, 1, 1)\n</pre> # 1. Funci\u00f3n dia_siguiente def dia_siguiente(fecha):     anno, mes, dia = fecha     dias_mes = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]      # Comprobamos si es un a\u00f1o bisiesto     if (anno % 4 == 0 and anno % 100 != 0) or (anno % 400 == 0):         dias_mes[1] = 29      if dia &lt; dias_mes[mes - 1]:         return (anno, mes, dia + 1)     elif mes &lt; 12:         return (anno, mes + 1, 1)     else:         return (anno + 1, 1, 1) In\u00a0[85]: Copied! <pre># Ejemplos de uso\nprint(dia_siguiente((2011, 4, 11)))  # Salida: (2011, 4, 12)\nprint(dia_siguiente((2011, 4, 30)))  # Salida: (2011, 5, 1)\nprint(dia_siguiente((2011, 12, 31)))  # Salida: (2012, 1, 1)\n</pre> # Ejemplos de uso print(dia_siguiente((2011, 4, 11)))  # Salida: (2011, 4, 12) print(dia_siguiente((2011, 4, 30)))  # Salida: (2011, 5, 1) print(dia_siguiente((2011, 12, 31)))  # Salida: (2012, 1, 1) <pre>(2011, 4, 12)\n(2011, 5, 1)\n(2012, 1, 1)\n</pre> In\u00a0[86]: Copied! <pre># 2. Funci\u00f3n dias_entre\ndef dias_entre(fecha1, fecha2):\n    from datetime import date\n\n    date1 = date(fecha1[0], fecha1[1], fecha1[2])\n    date2 = date(fecha2[0], fecha2[1], fecha2[2])\n    \n    delta = date2 - date1\n    return delta.days\n</pre> # 2. Funci\u00f3n dias_entre def dias_entre(fecha1, fecha2):     from datetime import date      date1 = date(fecha1[0], fecha1[1], fecha1[2])     date2 = date(fecha2[0], fecha2[1], fecha2[2])          delta = date2 - date1     return delta.days In\u00a0[87]: Copied! <pre># Ejemplos de uso\nhoy = (2011, 4, 11)\nnavidad = (2011, 12, 25)\nprint(dias_entre(hoy, navidad))  # Salida: 258\nprint(dias_entre(hoy, hoy))  # Salida: 0\n</pre> # Ejemplos de uso hoy = (2011, 4, 11) navidad = (2011, 12, 25) print(dias_entre(hoy, navidad))  # Salida: 258 print(dias_entre(hoy, hoy))  # Salida: 0 <pre>258\n0\n</pre> <p>Ejercicio 13</p> <p>El conjunto potencia de un conjunto $S$ es el conjunto de todos los subconjuntos de $S$.</p> <p>Por ejemplo, el conjunto potencia de $\\{1,2,3\\}$ es:</p> <p>$$\\{\\emptyset,\\{1\\},\\{2\\},\\{3\\},\\{1,2\\},\\{1,3\\},\\{2,3\\},\\{1,2,3\\}\\}$$</p> <p>En Python, un conjunto no puede contener a otros conjuntos, ya que no puede tener elementos mutables, y los conjuntos lo son:</p> <pre>&gt;&gt;&gt; a = set()\n&gt;&gt;&gt; a.add({1, 2})        # :(\nTraceback (most recent call last):\n  File \"&lt;console&gt;\", line 1, in &lt;module&gt;\nTypeError: unhashable type: 'set'\n</pre> <p>Lo que s\u00ed podemos crear es una lista de conjuntos:</p> <pre>&gt;&gt;&gt; l = list()\n&gt;&gt;&gt; l.append({1, 2})     # :)\n&gt;&gt;&gt; l\n[set([1, 2])]\n</pre> <p>Escriba la <code>funci\u00f3n conjunto_potencia(s)</code> que reciba como par\u00e1metro un conjunto cualquiera <code>s</code> y retorne su \u00ablista potencia\u00bb (la lista de todos sus subconjuntos):</p> <pre>&gt;&gt;&gt; conjunto_potencia({6, 1, 4})\n[set(), set([6]), set([1]), set([4]), set([6, 1]), set([6, 4]), set([1, 4]), set([6, 1, 4])]\n</pre> In\u00a0[89]: Copied! <pre>def conjunto_potencia(s):\n    # Convierte el conjunto en una lista para poder iterar sobre sus elementos\n    elementos = list(s)\n    n = len(elementos)\n    potencia = []\n\n    for i in range(2**n):\n        subconjunto = set()\n        for j in range(n):\n            # Verifica si el j-\u00e9simo bit de i est\u00e1 encendido\n            if (i &gt;&gt; j) &amp; 1:\n                subconjunto.add(elementos[j])\n        potencia.append(subconjunto)\n\n    return potencia\n</pre> def conjunto_potencia(s):     # Convierte el conjunto en una lista para poder iterar sobre sus elementos     elementos = list(s)     n = len(elementos)     potencia = []      for i in range(2**n):         subconjunto = set()         for j in range(n):             # Verifica si el j-\u00e9simo bit de i est\u00e1 encendido             if (i &gt;&gt; j) &amp; 1:                 subconjunto.add(elementos[j])         potencia.append(subconjunto)      return potencia In\u00a0[90]: Copied! <pre># Ejemplo de uso\nconjunto = {6, 1, 4}\nresultado = conjunto_potencia(conjunto)\nprint(resultado)\n</pre> # Ejemplo de uso conjunto = {6, 1, 4} resultado = conjunto_potencia(conjunto) print(resultado) <pre>[set(), {1}, {4}, {1, 4}, {6}, {1, 6}, {4, 6}, {1, 4, 6}]\n</pre> <p>Ejercicio 14</p> <p>Para este ejercicio considere lo siguiente:</p> <p>Para obtener la lista de palabras de la oraci\u00f3n, puede usar el m\u00e9todo <code>split</code> de los strings:</p> <pre>&gt;&gt;&gt; s = 'el gato y el pato'\n&gt;&gt;&gt; s.split()\n['el', 'gato', 'y', 'el', 'pato']\n</pre> <p>Para obtener un string en min\u00fasculas, puede usar el m\u00e9todo lower:</p> <pre>&gt;&gt;&gt; s = 'Venezuela'\n&gt;&gt;&gt; s.lower()\n'venezuela'\n</pre> <ol> <li><p>Escriba la funci\u00f3n <code>contar_letras(oracion)</code> que retorne un diccionario asociando a cada letra la cantidad de veces que aparece en la oracion:</p> <pre><code>&gt;&gt;&gt; contar_letras('El elefante avanza hacia Asia')\n{'a': 8, 'c': 1, 'e': 4, 'f': 1, 'h': 1, 'i': 2, 'l': 2, 'n': 2, 's': 1, 't': 1, 'v': 1, 'z': 1}\n</code></pre> <p>Cada valor del diccionario debe considerar tanto las apariciones en may\u00fascula como en min\u00fascula de la letra correspondiente. Los espacios deben ser ignorados.</p> </li> <li><p>Escriba la funci\u00f3n <code>contar_vocales(oracion)</code> que retorne un diccionario asociando a cada vocal la cantidad de veces que aparece en la oracion. Si una vocal no aparece en la oraci\u00f3n, de todos modos debe estar en el diccionario asociada al valor 0:</p> <pre><code>&gt;&gt;&gt; contar_vocales('El elefante avanza hacia Asia')\n{'a': 8, 'e': 4, 'i': 2, 'o': 0, 'u': 0}\n</code></pre> </li> <li><p>Escriba la funci\u00f3n <code>contar_iniciales(oracion)</code> que retorne un diccionario asociando a cada letra la cantidad de veces que aparece al principio de una palabra:</p> <pre><code>&gt;&gt;&gt; contar_iniciales('El elefante avanza hacia Asia')\n{'e': 2, 'h': 1, 'a': 2}\n&gt;&gt;&gt; contar_iniciales('Varias vacas vuelan sobre Venezuela')\n{'s': 1', 'v': 4}\n</code></pre> </li> <li><p>Escriba la funci\u00f3n <code>obtener_largo_palabras(oracion)</code> que retorne un diccionario asociando a cada palabra su cantidad de letras:</p> <pre><code>&gt;&gt;&gt; obtener_largo_palabras('el gato y el pato son amigos')\n{'el': 2, 'son': 3, 'gato': 4, 'y': 1, 'amigos': 6, 'pato': 4}\n</code></pre> </li> <li><p>Escriba la funci\u00f3n <code>contar_palabras(oracion)</code> que retorne un diccionario asociando a cada palabra la cantidad de veces que aparece en la oraci\u00f3n:</p> <pre><code>&gt;&gt;&gt; contar_palabras('El sobre esta sobre el pupitre')\n{'sobre': 2, 'pupitre': 1, 'el': 2, 'esta': 1}\n</code></pre> </li> <li><p>Escriba la funci\u00f3n <code>palabras_repetidas(oracion)</code> que retorne una lista con las palabras que est\u00e1n repetidas:</p> <pre><code>&gt;&gt;&gt; palabras_repetidas('El partido termino cero a cero')\n['cero']\n&gt;&gt;&gt; palabras_repetidas('El sobre esta sobre el mueble')\n['el', 'sobre']\n&gt;&gt;&gt; palabras_repetidas('Ay, ahi no hay pan')\n[]\n</code></pre> </li> </ol> In\u00a0[91]: Copied! <pre># Funci\u00f3n contar_letras:\n\ndef contar_letras(oracion):\n    oracion = oracion.lower()\n    letras = [letra for letra in oracion if letra.isalpha()]\n    contador = {}\n    for letra in letras:\n        if letra in contador:\n            contador[letra] += 1\n        else:\n            contador[letra] = 1\n    return contador\n</pre> # Funci\u00f3n contar_letras:  def contar_letras(oracion):     oracion = oracion.lower()     letras = [letra for letra in oracion if letra.isalpha()]     contador = {}     for letra in letras:         if letra in contador:             contador[letra] += 1         else:             contador[letra] = 1     return contador In\u00a0[92]: Copied! <pre># Ejemplo de uso\noracion = 'El elefante avanza hacia Asia'\nresultado = contar_letras(oracion)\nprint(resultado)\n</pre> # Ejemplo de uso oracion = 'El elefante avanza hacia Asia' resultado = contar_letras(oracion) print(resultado) <pre>{'e': 4, 'l': 2, 'f': 1, 'a': 8, 'n': 2, 't': 1, 'v': 1, 'z': 1, 'h': 1, 'c': 1, 'i': 2, 's': 1}\n</pre> In\u00a0[93]: Copied! <pre># Funci\u00f3n contar_vocales:\ndef contar_vocales(oracion):\n    oracion = oracion.lower()\n    vocales = 'aeiou'\n    contador = {vocal: 0 for vocal in vocales}\n    for letra in oracion:\n        if letra in contador:\n            contador[letra] += 1\n    return contador\n</pre> # Funci\u00f3n contar_vocales: def contar_vocales(oracion):     oracion = oracion.lower()     vocales = 'aeiou'     contador = {vocal: 0 for vocal in vocales}     for letra in oracion:         if letra in contador:             contador[letra] += 1     return contador In\u00a0[94]: Copied! <pre># Ejemplo de uso\noracion = 'El elefante avanza hacia Asia'\nresultado = contar_vocales(oracion)\nprint(resultado)\n</pre> # Ejemplo de uso oracion = 'El elefante avanza hacia Asia' resultado = contar_vocales(oracion) print(resultado) <pre>{'a': 8, 'e': 4, 'i': 2, 'o': 0, 'u': 0}\n</pre> In\u00a0[95]: Copied! <pre># Funci\u00f3n contar_iniciales:\ndef contar_iniciales(oracion):\n    oracion = oracion.lower()\n    palabras = oracion.split()\n    contador = {}\n    for palabra in palabras:\n        if palabra:\n            inicial = palabra[0]\n            if inicial in contador:\n                contador[inicial] += 1\n            else:\n                contador[inicial] = 1\n    return contador\n</pre> # Funci\u00f3n contar_iniciales: def contar_iniciales(oracion):     oracion = oracion.lower()     palabras = oracion.split()     contador = {}     for palabra in palabras:         if palabra:             inicial = palabra[0]             if inicial in contador:                 contador[inicial] += 1             else:                 contador[inicial] = 1     return contador In\u00a0[96]: Copied! <pre># Ejemplo de uso\noracion = 'El elefante avanza hacia Asia'\nresultado = contar_iniciales(oracion)\nprint(resultado)\n</pre> # Ejemplo de uso oracion = 'El elefante avanza hacia Asia' resultado = contar_iniciales(oracion) print(resultado) <pre>{'e': 2, 'a': 2, 'h': 1}\n</pre> In\u00a0[97]: Copied! <pre># Funci\u00f3n obtener_largo_palabras:\ndef obtener_largo_palabras(oracion):\n    palabras = oracion.split()\n    contador = {}\n    for palabra in palabras:\n        contador[palabra] = len(palabra)\n    return contador\n</pre> # Funci\u00f3n obtener_largo_palabras: def obtener_largo_palabras(oracion):     palabras = oracion.split()     contador = {}     for palabra in palabras:         contador[palabra] = len(palabra)     return contador In\u00a0[98]: Copied! <pre># Ejemplo de uso\noracion = 'el gato y el pato son amigos'\nresultado = obtener_largo_palabras(oracion)\nprint(resultado)\n</pre> # Ejemplo de uso oracion = 'el gato y el pato son amigos' resultado = obtener_largo_palabras(oracion) print(resultado) <pre>{'el': 2, 'gato': 4, 'y': 1, 'pato': 4, 'son': 3, 'amigos': 6}\n</pre> In\u00a0[99]: Copied! <pre># Funci\u00f3n contar_palabras:\ndef contar_palabras(oracion):\n    oracion = oracion.lower()\n    palabras = oracion.split()\n    contador = {}\n    for palabra in palabras:\n        if palabra in contador:\n            contador[palabra] += 1\n        else:\n            contador[palabra] = 1\n    return contador\n</pre> # Funci\u00f3n contar_palabras: def contar_palabras(oracion):     oracion = oracion.lower()     palabras = oracion.split()     contador = {}     for palabra in palabras:         if palabra in contador:             contador[palabra] += 1         else:             contador[palabra] = 1     return contador In\u00a0[100]: Copied! <pre># Ejemplo de uso\noracion = 'El sobre esta sobre el pupitre'\nresultado = contar_palabras(oracion)\nprint(resultado)\n</pre> # Ejemplo de uso oracion = 'El sobre esta sobre el pupitre' resultado = contar_palabras(oracion) print(resultado) <pre>{'el': 2, 'sobre': 2, 'esta': 1, 'pupitre': 1}\n</pre> In\u00a0[101]: Copied! <pre># Funci\u00f3n palabras_repetidas:\ndef palabras_repetidas(oracion):\n    oracion = oracion.lower()\n    palabras = oracion.split()\n    contador = {}\n    repetidas = []\n    for palabra in palabras:\n        if palabra in contador:\n            contador[palabra] += 1\n        else:\n            contador[palabra] = 1\n    for palabra, cantidad in contador.items():\n        if cantidad &gt; 1:\n            repetidas.append(palabra)\n    return repetidas\n</pre> # Funci\u00f3n palabras_repetidas: def palabras_repetidas(oracion):     oracion = oracion.lower()     palabras = oracion.split()     contador = {}     repetidas = []     for palabra in palabras:         if palabra in contador:             contador[palabra] += 1         else:             contador[palabra] = 1     for palabra, cantidad in contador.items():         if cantidad &gt; 1:             repetidas.append(palabra)     return repetidas In\u00a0[102]: Copied! <pre># Ejemplo de uso\noracion = 'El sobre esta sobre el mueble'\nresultado = palabras_repetidas(oracion)\nprint(resultado)\n</pre> # Ejemplo de uso oracion = 'El sobre esta sobre el mueble' resultado = palabras_repetidas(oracion) print(resultado) <pre>['el', 'sobre']\n</pre>"},{"location":"solucion/#solucion-ejercicios","title":"Soluci\u00f3n Ejercicios\u00b6","text":""},{"location":"solucion/#nomenclatura","title":"Nomenclatura\u00b6","text":""},{"location":"solucion/#control-de-flujo","title":"Control de Flujo\u00b6","text":""},{"location":"solucion/#if-elif-else","title":"if-elif-else\u00b6","text":"<p>Ejercicio 01</p> <p>Escriba un programa que determine si el n\u00famero entero ingresado por el usuario es par o no.</p> <pre><code>terminal\nIngrese un n\u00famero: 4\nSu n\u00famero es par\n</code></pre> <pre><code>terminal\nIngrese un n\u00famero: 3\nSu n\u00famero es impar\n</code></pre>"},{"location":"solucion/#while","title":"While\u00b6","text":"<p>Ejercicio 01</p> <p>Solicita al usuario un n\u00famero y muestra un contador regresivo desde ese n\u00famero hasta 1. Utiliza la declaraci\u00f3n <code>while</code> para resolver este problema.</p> <pre><code>Ingrese un n\u00famero: 5\nContador regresivo desde 5 hasta 1:\n5\n4\n3\n2\n1\n</code></pre>"},{"location":"solucion/#range","title":"Range\u00b6","text":"<p>Ejercicio 01</p> <p>Calcula la suma de todos los n\u00fameros pares desde 1 hasta un n\u00famero dado ($n$). Utiliza la declaraci\u00f3n <code>range</code> para resolver este problema.</p> <pre><code>Ingrese un n\u00famero: 10\nLa suma de n\u00fameros pares desde 1 hasta 10 es 30\n</code></pre>"},{"location":"solucion/#break-continue","title":"Break &amp; Continue\u00b6","text":"<p>Ejercicio 01</p> <p>Solicita al usuario un n\u00famero y cuenta cu\u00e1ntos de sus d\u00edgitos son pares. Utiliza la declaraci\u00f3n <code>continue</code> para omitir los d\u00edgitos impares.</p> <pre><code>Ingrese un n\u00famero: 123456\nEl n\u00famero tiene 3 d\u00edgitos pares.\n</code></pre>"},{"location":"solucion/#estructura-de-datos","title":"Estructura de Datos\u00b6","text":""},{"location":"solucion/#listas","title":"Listas\u00b6","text":"<p>Ejercicio 01</p> <p>Considere las siguientes listas:</p> <pre>a = [5, 1, 4, 9, 0]\nb = range(3, 10) + range(20, 23)\nc = [[1, 2], [3, 4, 5], [6, 7]]\nd = ['perro', 'gato', 'jirafa', 'elefante']\ne = ['a', a, 2 * a]\n</pre> <p>Sin usar el computador, indique cu\u00e1l es el resultado y el tipo de las siguientes expresiones. A continuaci\u00f3n, verifique sus respuestas en el computador.</p> <pre>a[2]\nb[9]\nc[1][2]\ne[0] == e[1]\nlen(c)\nlen(c[0])\nlen(e)\nc[-1]\nc[-1][+1]\nc[2:] + d[2:]\na[3:10]\na[3:10:2]\nd.index('jirafa')\ne[c[0][1]].count(5)\nsorted(a)[2]\ncomplex(b[0], b[1])\n</pre>"},{"location":"solucion/#tuplas","title":"Tuplas\u00b6","text":"<p>Ejercicio 01</p> <p>Considere las siguientes asignaciones:</p> <pre>a = (2, 10, 1991)\nb = (25, 12, 1990)\nc = ('Donald', True, b)\nx, y = ((27, 3), 9)\nz, w = x\nv = (x, a)\n</pre> <p>Sin usar el computador, indique cu\u00e1l es el resultado y el tipo de las siguientes expresiones. A continuaci\u00f3n, verifique sus respuestas en el computador.</p> <pre>a &lt; b\ny + w\nx + a\nlen(v)\nv[1][1]\nc[0][0]\nz, y\na + b[1:5]\n(a + b)[1:5]\nstr(a[2]) + str(b[2])\nstr(a[2] + b[2])\nstr((a + b)[2])\nstr(a + b)[2]\n</pre>"},{"location":"solucion/#conjuntos","title":"Conjuntos\u00b6","text":"<p>Ejercicio 01</p> <p>Considere las siguientes asignaciones:</p> <pre>a = {5, 2, 3, 9, 4}\nb = {3, 1}\nc = {7, 5, 5, 1, 8, 6}\nd = [6, 2, 4, 5, 5, 3, 1, 3, 7, 8]\ne = {(2, 3), (3, 4), (4, 5)}\nf = [{2, 3}, {3, 4}, {4, 5}]\n</pre> <p>Sin usar el computador, indique cu\u00e1l es el resultado y el tipo de las siguientes expresiones. A continuaci\u00f3n, verifique sus respuestas en el computador.</p> <pre>len(c)\nlen(set(d))\na &amp; (b | c)\n(a &amp; b) | c\nc - a\nmax(e)\nf[0] &lt; a\nset(range(4)) &amp; a\n(set(range(4)) &amp; a) in f\nlen(set('perro'))\nlen({'perro'})\n</pre>"},{"location":"solucion/#diccionarios","title":"Diccionarios\u00b6","text":"<p>Ejercicio 01</p> <p>Considere las siguientes asignaciones:</p> <pre>a = {'a': 14, 'b': 23, 'c': 88}\nb = {12: True, 55: False, -2: False}\nc = dict()\nd = {1: [2, 3, 4], 5: [6, 7, 8, 9], 10: [11]}\ne = {2 + 3: 4, 5: 6 + 7, 8: 9, 10: 11 + 12}\n</pre> <p>Sin usar el computador, indique cu\u00e1l es el resultado y el tipo de las siguientes expresiones. A continuaci\u00f3n, verifique sus respuestas en el computador.</p> <pre>a['c']\na[23]\nb[-2] or b[55]\n23 in a\n'a' in a\n5 in d[5]\nsum(b)\nlen(c)\nlen(d)\nlen(d[1])\nlen(b.values())\nlen(e)\nsum(a.values())\nmax(list(e))\nd[1] + d[5] + d[10]\n</pre>"},{"location":"solucion/#funciones","title":"Funciones\u00b6","text":""}]}